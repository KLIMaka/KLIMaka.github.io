/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/builded.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return contains; });
function contains(parent, child) {
  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (isShadow) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBoundingClientRect; });
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getClippingRect; });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");












function getInnerBoundingClientRect(element) {
  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__["viewport"] ? Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_10__["default"])(Object(_getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) : Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(clippingParent) ? getInnerBoundingClientRect(clippingParent) : Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_10__["default"])(Object(_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = Object(_listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(element) ? Object(_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element) : element;

  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clipperElement)) {
    return [];
  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clippingParent) && Object(_contains_js__WEBPACK_IMPORTED_MODULE_9__["default"])(clippingParent, clipperElement);
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCompositeRect; });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");






 // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent);
  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(elementOrVirtualElement);
  var isOffsetParentAnElement = Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement)) {
      scroll = Object(_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);
    }

    if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent)) {
      offsets = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getComputedStyle; });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentElement; });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe: assume body is always available
  return (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__["isElement"])(element) ? element.ownerDocument : element.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentRect; });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var body = element.ownerDocument.body;
  var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  var y = -winScroll.scrollTop;

  if (Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body || html).direction === 'rtl') {
    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHTMLElementScroll; });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getLayoutRect; });
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getNodeName; });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getNodeScroll; });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node) || !Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__["isHTMLElement"])(node)) {
    return Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  } else {
    return Object(_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getOffsetParent; });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");







function getTrueOffsetParent(element) {
  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(element) || // https://github.com/popperjs/popper-core/issues/837
  Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var currentNode = Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);

  while (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(currentNode) && ['html', 'body'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode)) < 0) {
    var css = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.

    if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange !== 'auto') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && Object(_isTableElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === 'body' && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getParentNode; });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");


function getParentNode(element) {
  if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getScrollParent; });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) >= 0) {
    // $FlowFixMe: assume body is always available
    return node.ownerDocument.body;
  }

  if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(node) && Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node)) {
    return node;
  }

  return getScrollParent(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getViewportRect; });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");



function getViewportRect(element) {
  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindow; });
/*:: import type { Window } from '../types'; */

/*:: declare function getWindow(node: Node | Window): Window; */
function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScroll; });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScrollBarX; });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/*! exports provided: isElement, isHTMLElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return isElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHTMLElement", function() { return isHTMLElement; });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */

function isElement(node) {
  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isScrollParent; });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isTableElement; });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listScrollParents; });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");





/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the 
reference element's position.
*/

function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = Object(_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) === 'body';
  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/*! exports provided: top, bottom, right, left, auto, basePlacements, start, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "top", function() { return top; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return bottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "right", function() { return right; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "left", function() { return left; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return auto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return basePlacements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "end", function() { return end; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return clippingParents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return viewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return popper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return reference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return variationPlacements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return placements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return beforeRead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "read", function() { return read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return afterRead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return beforeMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "main", function() { return main; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return afterMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return beforeWrite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "write", function() { return write; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return afterWrite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return modifierPhases; });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/*! exports provided: top, bottom, right, left, auto, basePlacements, start, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases, popperGenerator, createPopper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return popperGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "top", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["top"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["bottom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "right", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["right"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "left", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["left"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["auto"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["basePlacements"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "start", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["start"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "end", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["end"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["clippingParents"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["viewport"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["popper"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["reference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["variationPlacements"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["placements"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["beforeRead"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "read", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["read"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["afterRead"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["beforeMain"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "main", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["main"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["afterMain"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["beforeWrite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "write", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["write"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["afterWrite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_12__["modifierPhases"]; });















var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);
        state.scrollParents = {
          reference: Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_11__["isElement"])(reference) ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],
          popper: Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = Object(_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = Object(_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          Object(_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__["default"])(modifiers);

          if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_12__["auto"]) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: Object(_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(reference, Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper), state.options.strategy === 'fixed'),
          popper: Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Object(_utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator();

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__["isHTMLElement"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__["isHTMLElement"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);
  var axis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_8__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"]].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["left"];
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"];
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_5__["default"])(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__["isHTMLElement"])(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!Object(_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: Object(_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__["default"])(typeof padding !== 'number' ? padding : Object(_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_8__["basePlacements"]))
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/*! exports provided: mapToStyles, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapToStyles", function() { return mapToStyles; });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsets(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive;

  var _roundOffsets = roundOffsets(offsets),
      x = _roundOffsets.x,
      y = _roundOffsets.y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"];
  var win = window;

  if (adaptive) {
    var offsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper);

    if (offsetParent === Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)) {
      offsetParent = Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper);
    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    /*:: offsetParent = (offsetParent: Element); */


    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"]) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"];
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref3) {
  var state = _ref3.state,
      options = _ref3.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

  if (true) {
    var transitionProperty = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false
    })));
  }

  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"]) {
    return [];
  }

  var oppositePlacement = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  return [Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement), oppositePlacement, Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"] ? Object(_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);

    var isStartVariation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["start"];
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["right"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["left"] : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["top"];

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);
    }

    var altVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/*! exports provided: distanceAndSkiddingToXY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceAndSkiddingToXY", function() { return distanceAndSkiddingToXY; });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");


function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["top"]].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {}, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["right"]].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"].reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = Object(_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");











function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement);
  var altAxis = Object(_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : Object(_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];

    var _offset = popperOffsets[altAxis];

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var _preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_min, _offset, _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/*! exports provided: createPopper, popperGenerator, defaultModifiers, detectOverflow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultModifiers", function() { return defaultModifiers; });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/@popperjs/core/lib/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"]; });

/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });












var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__["default"]];
var createPopper = /*#__PURE__*/Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"])({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeAutoPlacement; });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





/*:: type OverflowsMap = { [ComputedPlacement]: number }; */

/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"] : _options$allowedAutoP;
  var variation = Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var placements = (variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"] : _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"].filter(function (placement) {
    return Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_1__["basePlacements"]).filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  }); // $FlowFixMe: Flow seems to have problems with two array unions...

  var overflows = placements.reduce(function (acc, placement) {
    acc[placement] = Object(_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeOffsets; });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["top"]:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["bottom"]:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["right"]:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["left"]:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? Object(_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["start"]:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["end"]:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return detectOverflow; });
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["clippingParents"] : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["viewport"] : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = Object(_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(typeof padding !== 'number' ? padding : Object(_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_5__["basePlacements"]));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["reference"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"];
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = Object(_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__["isElement"])(element) ? element : element.contextElement || Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = Object(_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(referenceElement);
  var popperOffsets = Object(_computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = Object(_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(Object.assign(Object.assign({}, popperRect), popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return expandToHashMap; });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return format; });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getAltAxis; });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBasePlacement; });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFreshSideObject; });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getMainAxisFromPlacement; });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getOppositePlacement; });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getOppositeVariationPlacement; });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getVariation; });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergeByName; });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {
      options: Object.assign(Object.assign({}, existing.options), current.options),
      data: Object.assign(Object.assign({}, existing.data), current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergePaddingObject; });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, Object(_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])()), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return orderModifiers; });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__["modifierPhases"].reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rectToClientRect; });
function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), {}, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueBy; });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return validateModifiers; });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].indexOf(modifier.phase) < 0) {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return within; });
function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

/***/ }),

/***/ "./node_modules/solid-js/dist/dom/index.js":
/*!*************************************************!*\
  !*** ./node_modules/solid-js/dist/dom/index.js ***!
  \*************************************************/
/*! exports provided: ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, assignProps, createComponent, currentContext, effect, Dynamic, Portal, assign, classList, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, hydrate, insert, memo, render, renderDOMToString, renderToString, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrClassList, ssrSpread, ssrStyle, style, template */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dynamic", function() { return Dynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Portal", function() { return Portal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classList", function() { return classList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearDelegatedEvents", function() { return clearDelegatedEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delegateEvents", function() { return delegateEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dynamicProperty", function() { return dynamicProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return escape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateHydrationScript", function() { return generateHydrationScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHydrationKey", function() { return getHydrationKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextElement", function() { return getNextElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextMarker", function() { return getNextMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return hydrate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return insert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return memo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDOMToString", function() { return renderDOMToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderToString", function() { return renderToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runHydrationEvents", function() { return runHydrationEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttribute", function() { return setAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttributeNS", function() { return setAttributeNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spread", function() { return spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssr", function() { return ssr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssrClassList", function() { return ssrClassList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssrSpread", function() { return ssrSpread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssrStyle", function() { return ssrStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "template", function() { return template; });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ "./node_modules/solid-js/dist/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorBoundary", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["ErrorBoundary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "For", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["For"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Index", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["Index"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Match", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["Match"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Show", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["Show"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["Suspense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["SuspenseList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["Switch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assignProps", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["assignProps"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createComponent", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["createComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "currentContext", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["getContextOwner"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "effect", function() { return _index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"]; });




const Types = {
  ATTRIBUTE: "attribute",
  PROPERTY: "property"
},
      Attributes = {
  href: {
    type: Types.ATTRIBUTE
  },
  style: {
    type: Types.PROPERTY,
    alias: "style.cssText"
  },
  for: {
    type: Types.PROPERTY,
    alias: "htmlFor"
  },
  class: {
    type: Types.PROPERTY,
    alias: "className"
  },
  role: {
    type: Types.ATTRIBUTE
  },
  spellCheck: {
    type: Types.PROPERTY,
    alias: "spellcheck"
  },
  allowFullScreen: {
    type: Types.PROPERTY,
    alias: "allowFullscreen"
  },
  autoCapitalize: {
    type: Types.PROPERTY,
    alias: "autocapitalize"
  },
  autoFocus: {
    type: Types.PROPERTY,
    alias: "autofocus"
  },
  autoPlay: {
    type: Types.PROPERTY,
    alias: "autoplay"
  }
},
      SVGAttributes = {
  innerHTML: {
    type: Types.PROPERTY
  },
  textContent: {
    type: Types.PROPERTY
  },
  innerText: {
    type: Types.PROPERTY
  },
  className: {
    type: Types.ATTRIBUTE,
    alias: "class"
  },
  htmlFor: {
    type: Types.ATTRIBUTE,
    alias: "for"
  },
  tabIndex: {
    type: Types.ATTRIBUTE,
    alias: "tabindex"
  },
  allowReorder: {
    type: Types.ATTRIBUTE
  },
  attributeName: {
    type: Types.ATTRIBUTE
  },
  attributeType: {
    type: Types.ATTRIBUTE
  },
  autoReverse: {
    type: Types.ATTRIBUTE
  },
  baseFrequency: {
    type: Types.ATTRIBUTE
  },
  calcMode: {
    type: Types.ATTRIBUTE
  },
  clipPathUnits: {
    type: Types.ATTRIBUTE
  },
  contentScriptType: {
    type: Types.ATTRIBUTE
  },
  contentStyleType: {
    type: Types.ATTRIBUTE
  },
  diffuseConstant: {
    type: Types.ATTRIBUTE
  },
  edgeMode: {
    type: Types.ATTRIBUTE
  },
  externalResourcesRequired: {
    type: Types.ATTRIBUTE
  },
  filterRes: {
    type: Types.ATTRIBUTE
  },
  filterUnits: {
    type: Types.ATTRIBUTE
  },
  gradientTransform: {
    type: Types.ATTRIBUTE
  },
  gradientUnits: {
    type: Types.ATTRIBUTE
  },
  kernelMatrix: {
    type: Types.ATTRIBUTE
  },
  kernelUnitLength: {
    type: Types.ATTRIBUTE
  },
  keyPoints: {
    type: Types.ATTRIBUTE
  },
  keySplines: {
    type: Types.ATTRIBUTE
  },
  keyTimes: {
    type: Types.ATTRIBUTE
  },
  lengthAdjust: {
    type: Types.ATTRIBUTE
  },
  limitingConeAngle: {
    type: Types.ATTRIBUTE
  },
  markerHeight: {
    type: Types.ATTRIBUTE
  },
  markerUnits: {
    type: Types.ATTRIBUTE
  },
  maskContentUnits: {
    type: Types.ATTRIBUTE
  },
  maskUnits: {
    type: Types.ATTRIBUTE
  },
  numOctaves: {
    type: Types.ATTRIBUTE
  },
  pathLength: {
    type: Types.ATTRIBUTE
  },
  patternContentUnits: {
    type: Types.ATTRIBUTE
  },
  patternTransform: {
    type: Types.ATTRIBUTE
  },
  patternUnits: {
    type: Types.ATTRIBUTE
  },
  pointsAtX: {
    type: Types.ATTRIBUTE
  },
  pointsAtY: {
    type: Types.ATTRIBUTE
  },
  pointsAtZ: {
    type: Types.ATTRIBUTE
  },
  preserveAlpha: {
    type: Types.ATTRIBUTE
  },
  preserveAspectRatio: {
    type: Types.ATTRIBUTE
  },
  primitiveUnits: {
    type: Types.ATTRIBUTE
  },
  refX: {
    type: Types.ATTRIBUTE
  },
  refY: {
    type: Types.ATTRIBUTE
  },
  repeatCount: {
    type: Types.ATTRIBUTE
  },
  repeatDur: {
    type: Types.ATTRIBUTE
  },
  requiredExtensions: {
    type: Types.ATTRIBUTE
  },
  requiredFeatures: {
    type: Types.ATTRIBUTE
  },
  specularConstant: {
    type: Types.ATTRIBUTE
  },
  specularExponent: {
    type: Types.ATTRIBUTE
  },
  spreadMethod: {
    type: Types.ATTRIBUTE
  },
  startOffset: {
    type: Types.ATTRIBUTE
  },
  stdDeviation: {
    type: Types.ATTRIBUTE
  },
  stitchTiles: {
    type: Types.ATTRIBUTE
  },
  surfaceScale: {
    type: Types.ATTRIBUTE
  },
  systemLanguage: {
    type: Types.ATTRIBUTE
  },
  tableValues: {
    type: Types.ATTRIBUTE
  },
  targetX: {
    type: Types.ATTRIBUTE
  },
  targetY: {
    type: Types.ATTRIBUTE
  },
  textLength: {
    type: Types.ATTRIBUTE
  },
  viewBox: {
    type: Types.ATTRIBUTE
  },
  viewTarget: {
    type: Types.ATTRIBUTE
  },
  xChannelSelector: {
    type: Types.ATTRIBUTE
  },
  yChannelSelector: {
    type: Types.ATTRIBUTE
  },
  zoomAndPan: {
    type: Types.ATTRIBUTE
  }
};
const NonComposedEvents = new Set(["abort", "animationstart", "animationend", "animationiteration", "blur", "change", "copy", "cut", "error", "focus", "gotpointercapture", "load", "loadend", "loadstart", "lostpointercapture", "mouseenter", "mouseleave", "paste", "progress", "reset", "scroll", "select", "submit", "transitionstart", "transitioncancel", "transitionend", "transitionrun"]);
const SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};

function memo(fn, equal) {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createMemo"])(fn, undefined, equal);
}

function reconcileArrays(parentNode, a, b) {
  let bLength = b.length,
      aEnd = a.length,
      bEnd = bLength,
      aStart = 0,
      bStart = 0,
      after = a[aEnd - 1].nextSibling,
      map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) parentNode.removeChild(a[aStart]);
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (aEnd - aStart === 1 && bEnd - bStart === 1) {
      if (map && map.has(a[aStart]) || a[aStart].parentNode !== parentNode) {
        parentNode.insertBefore(b[bStart], bEnd < bLength ? b[bEnd] : after);
      } else parentNode.replaceChild(b[bStart], a[aStart]);
      break;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      if (map.has(a[aStart])) {
        const index = map.get(a[aStart]);
        if (bStart < index && index < bEnd) {
          let i = aStart,
              sequence = 1;
          while (++i < aEnd && i < bEnd) {
            if (!map.has(a[i]) || map.get(a[i]) !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else parentNode.removeChild(a[aStart++]);
    }
  }
}

const eventRegistry = new Set(),
      hydration = globalThis._$HYDRATION || (globalThis._$HYDRATION = {});
function render(code, element) {
  let disposer;
  Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createRoot"])(dispose => {
    disposer = dispose;
    insert(element, code(), element.firstChild ? null : undefined);
  });
  return disposer;
}
function hydrate(code, element) {
  hydration.context = {
    id: "0",
    count: 0,
    registry: {}
  };
  const templates = element.querySelectorAll(`*[_hk]`);
  Array.prototype.reduce.call(templates, (memo, node) => {
    const id = node.getAttribute("_hk"),
          list = memo[id] || (memo[id] = []);
    list.push(node);
    return memo;
  }, hydration.context.registry);
  const dispose = render(code, element);
  delete hydration.context;
  return dispose;
}
function template(html, check, isSVG) {
  const t = document.createElement("template");
  t.innerHTML = html;
  if (check && t.innerHTML.split("<").length - 1 !== check) throw `Template html does not match input:\n${t.innerHTML}\n\n${html}`;
  let node = t.content.firstChild;
  if (isSVG) node = node.firstChild;
  return node;
}
function delegateEvents(eventNames) {
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!eventRegistry.has(name)) {
      eventRegistry.add(name);
      document.addEventListener(name, eventHandler);
    }
  }
}
function clearDelegatedEvents() {
  for (let name of eventRegistry.keys()) document.removeEventListener(name, eventHandler);
  eventRegistry.clear();
}
function setAttribute(node, name, value) {
  if (value === false || value == null) node.removeAttribute(name);else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
  if (value === false || value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);
}
function classList(node, value, prev) {
  const classKeys = Object.keys(value);
  for (let i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i],
          classValue = !!value[key],
          classNames = key.split(/\s+/);
    if (!key || prev && prev[key] === classValue) continue;
    for (let j = 0, nameLen = classNames.length; j < nameLen; j++) node.classList.toggle(classNames[j], classValue);
  }
  return value;
}
function style(node, value, prev) {
  const nodeStyle = node.style;
  if (typeof value === "string") return nodeStyle.cssText = value;
  let v, s;
  if (prev != null && typeof prev !== "string") {
    for (s in value) {
      v = value[s];
      v !== prev[s] && nodeStyle.setProperty(s, v);
    }
    for (s in prev) {
      value[s] == null && nodeStyle.removeProperty(s);
    }
  } else {
    for (s in value) nodeStyle.setProperty(s, value[s]);
  }
  return value;
}
function spread(node, accessor, isSVG, skipChildren) {
  if (typeof accessor === "function") {
    Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));
  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);
}
function insert(parent, accessor, marker, initial) {
  if (marker !== undefined && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(current => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}) {
  let info;
  for (const prop in props) {
    if (prop === "children") {
      if (!skipChildren) insertExpression(node, props.children);
      continue;
    }
    const value = props[prop];
    if (value === prevProps[prop]) continue;
    if (prop === "style") {
      style(node, value, prevProps[prop]);
    } else if (prop === "classList") {
      classList(node, value, prevProps[prop]);
    } else if (prop === "ref") {
      value(node);
    } else if (prop === "on") {
      for (const eventName in value) node.addEventListener(eventName, value[eventName]);
    } else if (prop === "onCapture") {
      for (const eventName in value) node.addEventListener(eventName, value[eventName], true);
    } else if (prop.slice(0, 2) === "on") {
      const lc = prop.toLowerCase();
      if (!NonComposedEvents.has(lc.slice(2))) {
        const name = lc.slice(2);
        if (Array.isArray(value)) {
          node[`__${name}`] = value[0];
          node[`__${name}Data`] = value[1];
        } else node[`__${name}`] = value;
        delegateEvents([name]);
      } else node[lc] = value;
    } else if (!isSVG && (info = Attributes[prop])) {
      if (info.type === "attribute") {
        setAttribute(node, prop, value);
      } else node[info.alias] = value;
    } else if (isSVG || prop.indexOf("-") > -1 || prop.indexOf(":") > -1) {
      const ns = prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
      if (ns) setAttributeNS(node, ns, prop, value);else if (info = SVGAttributes[prop]) {
        if (info.alias) setAttribute(node, info.alias, value);else setAttribute(node, prop, value);
      } else setAttribute(node, prop.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`), value);
    } else node[prop] = value;
    prevProps[prop] = value;
  }
}
function dynamicProperty(props, key) {
  const src = props[key];
  Object.defineProperty(props, key, {
    get() {
      return src();
    },
    enumerable: true
  });
  return props;
}
function ssrClassList(value) {
  let classKeys = Object.keys(value),
      result = "";
  for (let i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i],
          classValue = !!value[key];
    if (!key || !classValue) continue;
    i && (result += " ");
    result += key;
  }
  return result;
}
function ssrStyle(value) {
  if (typeof value === "string") return value;
  let result = "";
  const k = Object.keys(value);
  for (let i = 0; i < k.length; i++) {
    const s = k[i];
    if (i) result += ";";
    result += `${s}:${escape(value[s], true)}`;
  }
  return result;
}
function ssrSpread(props, isSVG) {
  return () => {
    if (typeof props === "function") props = props();
    const keys = Object.keys(props);
    let result = "";
    for (let i = 0; i < keys.length; i++) {
      const prop = keys[i];
      if (prop === "children") {
        console.warn(`SSR currently does not support spread children.`);
        continue;
      }
      const value = props[prop];
      if (prop === "style") {
        result += `style="${ssrStyle(value)}"`;
      } else if (prop === "classList") {
        result += `class="${ssrClassList(value)}"`;
      } else {
        const key = toSSRAttribute(prop, isSVG);
        result += `${key}="${escape(value, true)}"`;
      }
      if (i !== keys.length - 1) result += " ";
    }
    return result;
  };
}
const ATTR_REGEX = /[&<"]/,
      CONTENT_REGEX = /[&<]/;
function escape(html, attr) {
  if (typeof html !== "string") return html;
  const match = (attr ? ATTR_REGEX : CONTENT_REGEX).exec(html);
  if (!match) return html;
  let index = 0;
  let lastIndex = 0;
  let out = "";
  let escape = "";
  for (index = match.index; index < html.length; index++) {
    switch (html.charCodeAt(index)) {
      case 34:
        if (!attr) continue;
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) out += html.substring(lastIndex, index);
    lastIndex = index + 1;
    out += escape;
  }
  return lastIndex !== index ? out + html.substring(lastIndex, index) : out;
}
function getNextElement(template, isSSR) {
  const hydrate = hydration.context;
  let node, key;
  if (!hydrate || !hydrate.registry || !((key = getHydrationKey()) && hydrate.registry[key] && (node = hydrate.registry[key].shift()))) {
    const el = template.cloneNode(true);
    if (isSSR && hydrate) el.setAttribute("_hk", getHydrationKey());
    return el;
  }
  if (hydration && hydration.completed) hydration.completed.add(node);
  return node;
}
function getNextMarker(start) {
  let end = start,
      count = 0,
      current = [];
  if (hydration.context && hydration.context.registry) {
    while (end) {
      if (end.nodeType === 8) {
        const v = end.nodeValue;
        if (v === "#") count++;else if (v === "/") {
          if (count === 0) return [end, current];
          count--;
        }
      }
      current.push(end);
      end = end.nextSibling;
    }
  }
  return [end, current];
}
function runHydrationEvents() {
  if (hydration && hydration.events) {
    const {
      completed,
      events
    } = hydration;
    while (events.length) {
      const [el, e] = events[0];
      if (!completed.has(el)) return;
      eventHandler(e);
      events.shift();
    }
  }
}
function getHydrationKey() {
  return hydration.context.id;
}
function generateHydrationScript({
  eventNames = ["click", "input", "blur"],
  streaming,
  resolved
} = {}) {
  let s = `(()=>{_$HYDRATION={events:[],completed:new WeakSet};const t=e=>e&&e.hasAttribute&&(e.hasAttribute("_hk")&&e||t(e.host&&e.host instanceof Node?e.host:e.parentNode)),e=e=>{let o=e.composedPath&&e.composedPath()[0]||e.target,s=t(o);s&&!_$HYDRATION.completed.has(s)&&_$HYDRATION.events.push([s,e])};["${eventNames.join('","')}"].forEach(t=>document.addEventListener(t,e))})();`;
  if (streaming) {
    s += `(()=>{const e=_$HYDRATION,r={};let o=0;e.resolveResource=((e,o)=>{const t=r[e];if(!t)return r[e]=o;delete r[e],t(o)}),e.loadResource=(()=>{const e=++o,t=r[e];if(!t){let o,t=new Promise(e=>o=e);return r[e]=o,t}return delete r[e],Promise.resolve(t)})})();`;
  }
  if (resolved) s += `_$HYDRATION.resources = JSON.parse('${JSON.stringify(_$HYDRATION.resources || {})}');`;
  return s;
}
function eventHandler(e) {
  const key = `__${e.type}`;
  let node = e.composedPath && e.composedPath()[0] || e.target;
  if (e.target !== node) {
    Object.defineProperty(e, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node;
    }
  });
  while (node !== null) {
    const handler = node[key];
    if (handler) {
      const data = node[`${key}Data`];
      data ? handler(data, e) : handler(e);
      if (e.cancelBubble) return;
    }
    node = node.host && node.host instanceof Node ? node.host : node.parentNode;
  }
}
function spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {
  if (!skipChildren && "children" in props) {
    Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
  }
  Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(() => assign(node, props, isSVG, true, prevProps));
  return prevProps;
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value,
        multi = marker !== undefined;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (t === "number") value = value.toString();
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data = value;
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (hydration.context && hydration.context.registry) return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(() => current = insertExpression(parent, value(), current, marker));
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    if (normalizeIncomingArray(array, value, unwrapArray)) {
      Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createEffect"])(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (hydration.context && hydration.context.registry) return array;
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else {
      if (Array.isArray(current)) {
        if (current.length === 0) {
          appendNodes(parent, array, marker);
        } else reconcileArrays(parent, current, array);
      } else if (current == null || current === "") {
        appendNodes(parent, array);
      } else {
        reconcileArrays(parent, multi && current || [parent.firstChild], array);
      }
    }
    current = array;
  } else if (value instanceof Node) {
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else console.warn(`Skipped inserting`, value);
  return current;
}
function normalizeIncomingArray(normalized, array, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i],
        t;
    if (item instanceof Node) {
      normalized.push(item);
    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item) || dynamic;
    } else if ((t = typeof item) === "string") {
      normalized.push(document.createTextNode(item));
    } else if (t === "function") {
      if (unwrap) {
        const idx = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(idx) ? idx : [idx]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else normalized.push(document.createTextNode(item.toString()));
  }
  return dynamic;
}
function appendNodes(parent, array, marker) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === undefined) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && parent.removeChild(el);
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
function toSSRAttribute(key, isSVG) {
  if (isSVG) {
    const attr = SVGAttributes[key];
    if (attr) {
      if (attr.alias) key = attr.alias;
    } else key = key.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);
  } else {
    const attr = SVGAttributes[key];
    if (attr && attr.alias) key = attr.alias;
    key = key.toLowerCase();
  }
  return key;
}

const hydration$1 = globalThis._$HYDRATION || (globalThis._$HYDRATION = {});
function renderToString(code, options = {}) {
  options = {
    timeoutMs: 30000,
    ...options
  };
  hydration$1.context = {
    id: "0",
    count: 0
  };
  hydration$1.resources = {};
  hydration$1.asyncSSR = true;
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createRoot"])(() => {
    const rendered = code();
    if (typeof rendered === "object" && "then" in rendered) {
      const timeout = new Promise((_, reject) => setTimeout(() => reject("renderToString timed out"), options.timeoutMs));
      return Promise.race([rendered, timeout]).then(resolveSSRNode);
    }
    return resolveSSRNode(rendered);
  });
}
function renderDOMToString(code, options = {}) {
  options = {
    timeoutMs: 30000,
    ...options
  };
  hydration$1.context = {
    id: "0",
    count: 0
  };
  hydration$1.resources = {};
  hydration$1.asyncSSR = true;
  const container = document.createElement("div");
  document.body.appendChild(container);
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createRoot"])(d1 => {
    const rendered = code();
    function resolve(rendered) {
      Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["createRoot"])(d2 => (insert(container, rendered), d1(), d2()));
      const html = container.innerHTML;
      document.body.removeChild(container);
      return html;
    }
    if (typeof rendered === "object" && "then" in rendered) {
      const timeout = new Promise((_, reject) => setTimeout(() => reject("renderToString timed out"), options.timeoutMs));
      return Promise.race([rendered, timeout]).then(resolve);
    }
    return resolve(rendered);
  });
}
function ssr(t, ...nodes) {
  if (!nodes.length) return {
    t
  };
  for (let i = 0; i < nodes.length; i++) {
    const n = nodes[i];
    if (typeof n === "function") nodes[i] = memo(() => resolveSSRNode(n()));
  }
  return {
    t: () => {
      let result = "";
      for (let i = 0; i < t.length; i++) {
        result += t[i];
        const node = nodes[i];
        if (node !== undefined) result += resolveSSRNode(node);
      }
      return result;
    }
  };
}
function resolveSSRNode(node) {
  if (Array.isArray(node)) return node.map(resolveSSRNode).join("");
  const t = typeof node;
  if (node && t === "object") return resolveSSRNode(node.t);
  if (t === "function") return resolveSSRNode(node());
  return t === "string" ? node : JSON.stringify(node);
}

function Portal(props) {
  const {
    useShadow
  } = props,
        marker = document.createTextNode(""),
        mount = props.mount || document.body;
  if (mount instanceof HTMLHeadElement) {
    insert(mount, () => props.children, null);
  } else {
    const container = document.createElement("div"),
          renderRoot = useShadow && container.attachShadow ? container.attachShadow({
      mode: "open"
    }) : container;
    Object.defineProperty(container, "host", {
      get() {
        return marker.parentNode;
      }
    });
    insert(renderRoot, () => props.children);
    mount.appendChild(container);
    props.ref && props.ref(container);
    Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["onCleanup"])(() => mount.removeChild(container));
  }
  return marker;
}
function Dynamic(props) {
  const [p, others] = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["splitProps"])(props, ["component"]);
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["suspend"])(() => {
    const comp = p.component,
          t = typeof comp;
    if (comp) {
      if (t === "function") return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["untrack"])(() => comp(others));else if (t === "string") {
        const el = document.createElement(comp);
        spread(el, others);
        return el;
      }
    }
  });
}




/***/ }),

/***/ "./node_modules/solid-js/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/solid-js/dist/index.js ***!
  \*********************************************/
/*! exports provided: $RAW, Dynamic, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseContext, SuspenseList, Switch, afterEffects, assignProps, awaitSuspense, batch, cancelCallback, createComponent, createContext, createDeferred, createDependentEffect, createEffect, createMemo, createResource, createResourceState, createRoot, createSignal, createState, equalFn, freeze, getContextOwner, getListener, indexArray, lazy, mapArray, onCleanup, onError, produce, reconcile, requestCallback, sample, splitProps, suspend, untrack, unwrap, useContext, useTransition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$RAW", function() { return $RAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dynamic", function() { return Dynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorBoundary", function() { return ErrorBoundary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "For", function() { return For; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Index", function() { return Index; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Match", function() { return Match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Show", function() { return Show; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return Suspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SuspenseContext", function() { return SuspenseContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return SuspenseList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return Switch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterEffects", function() { return afterEffects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignProps", function() { return assignProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "awaitSuspense", function() { return awaitSuspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batch", function() { return batch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelCallback", function() { return cancelCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createComponent", function() { return createComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return createContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDeferred", function() { return createDeferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDependentEffect", function() { return createDependentEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEffect", function() { return createEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMemo", function() { return createMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResource", function() { return createResource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResourceState", function() { return createResourceState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRoot", function() { return createRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSignal", function() { return createSignal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createState", function() { return createState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalFn", function() { return equalFn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freeze", function() { return batch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextOwner", function() { return getContextOwner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getListener", function() { return getListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexArray", function() { return indexArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lazy", function() { return lazy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapArray", function() { return mapArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onCleanup", function() { return onCleanup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onError", function() { return onError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return produce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reconcile", function() { return reconcile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestCallback", function() { return requestCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return untrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitProps", function() { return splitProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "suspend", function() { return suspend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "untrack", function() { return untrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unwrap", function() { return unwrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return useContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useTransition", function() { return useTransition; });
let taskIdCounter = 1,
    isCallbackScheduled = false,
    isPerformingWork = false,
    taskQueue = [],
    currentTask = null,
    shouldYieldToHost = null,
    yieldInterval = 5,
    deadline = 0,
    maxYieldInterval = 300,
    scheduleCallback = null,
    scheduledCallback = null;
const maxSigned31BitInt = 1073741823;
function setupScheduler() {
  if (window && window.MessageChannel) {
    const channel = new MessageChannel(),
          port = channel.port2;
    scheduleCallback = () => port.postMessage(null);
    channel.port1.onmessage = () => {
      if (scheduledCallback !== null) {
        const currentTime = performance.now();
        deadline = currentTime + yieldInterval;
        const hasTimeRemaining = true;
        try {
          const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);
          if (!hasMoreWork) {
            scheduledCallback = null;
          } else port.postMessage(null);
        } catch (error) {
          port.postMessage(null);
          throw error;
        }
      }
    };
  } else {
    let _callback;
    scheduleCallback = () => {
      if (!_callback) {
        _callback = scheduledCallback;
        setTimeout(() => {
          const currentTime = performance.now();
          deadline = currentTime + yieldInterval;
          const hasMoreWork = _callback(true, currentTime);
          _callback = null;
          if (hasMoreWork) scheduleCallback();
        }, 0);
      }
    };
  }
  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {
    const scheduling = navigator.scheduling;
    shouldYieldToHost = () => {
      const currentTime = performance.now();
      if (currentTime >= deadline) {
        if (scheduling.isInputPending()) {
          return true;
        }
        return currentTime >= maxYieldInterval;
      } else {
        return false;
      }
    };
  } else {
    shouldYieldToHost = () => performance.now() >= deadline;
  }
}
function enqueue(taskQueue, task) {
  function findIndex() {
    let m = 0;
    let n = taskQueue.length - 1;
    while (m <= n) {
      let k = n + m >> 1;
      let cmp = task.expirationTime - taskQueue[k].expirationTime;
      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;
    }
    return m;
  }
  taskQueue.splice(findIndex(), 0, task);
}
function requestCallback(fn, options) {
  if (!scheduleCallback) setupScheduler();
  let startTime = performance.now(),
      timeout = maxSigned31BitInt;
  if (options && options.timeout) timeout = options.timeout;
  const newTask = {
    id: taskIdCounter++,
    fn,
    startTime,
    expirationTime: startTime + timeout
  };
  enqueue(taskQueue, newTask);
  if (!isCallbackScheduled && !isPerformingWork) {
    isCallbackScheduled = true;
    scheduledCallback = flushWork;
    scheduleCallback();
  }
  return newTask;
}
function cancelCallback(task) {
  task.fn = null;
}
function flushWork(hasTimeRemaining, initialTime) {
  isCallbackScheduled = false;
  isPerformingWork = true;
  try {
    return workLoop(hasTimeRemaining, initialTime);
  } finally {
    currentTask = null;
    isPerformingWork = false;
  }
}
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  currentTask = taskQueue[0] || null;
  while (currentTask !== null) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
      break;
    }
    const callback = currentTask.fn;
    if (callback !== null) {
      currentTask.fn = null;
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      callback(didUserCallbackTimeout);
      currentTime = performance.now();
      if (currentTask === taskQueue[0]) {
        taskQueue.shift();
      }
    } else taskQueue.shift();
    currentTask = taskQueue[0] || null;
  }
  return currentTask !== null;
}

const equalFn = (a, b) => a === b;
const ERROR = Symbol("error");
const NOTPENDING = {};
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
let Owner = null;
let Listener = null;
let Pending = null;
let Updates = null;
let Afters = [];
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
  detachedOwner && (Owner = detachedOwner);
  const listener = Listener,
        owner = Owner,
        root = fn.length === 0 ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner
  };
  Owner = root;
  Listener = null;
  let result;
  try {
    result = fn(() => cleanNode(root));
  } catch (err) {
    handleError(err);
  } finally {
    while (Afters.length) Afters.shift()();
    Listener = listener;
    Owner = owner;
  }
  return result;
}
function createSignal(value, areEqual) {
  const s = {
    value,
    observers: null,
    observerSlots: null,
    pending: NOTPENDING,
    comparator: areEqual ? typeof areEqual === "function" ? areEqual : equalFn : undefined
  };
  return [readSignal.bind(s), writeSignal.bind(s)];
}
function createEffect(fn, value) {
  try {
    updateComputation(createComputation(fn, value));
  } catch (err) {
    handleError(err);
  }
}
function createDependentEffect(fn, deps, defer) {
  const resolved = Array.isArray(deps) ? callAll(deps) : deps;
  defer = !!defer;
  createEffect(value => {
    const listener = Listener;
    resolved();
    if (defer) defer = false;else {
      Listener = null;
      value = fn(value);
      Listener = listener;
    }
    return value;
  });
}
function createMemo(fn, value, areEqual) {
  const c = createComputation(fn, value);
  c.pending = NOTPENDING;
  c.observers = null;
  c.observerSlots = null;
  c.comparator = areEqual ? typeof areEqual === "function" ? areEqual : equalFn : undefined;
  try {
    updateComputation(c);
  } catch (err) {
    handleError(err);
  }
  return readSignal.bind(c);
}
function createDeferred(fn, options) {
  let t,
      timeout = options ? options.timeoutMs : undefined;
  const [deferred, setDeferred] = createSignal(fn());
  createEffect(() => {
    fn();
    if (!t || !t.fn) t = requestCallback(() => setDeferred(fn()), timeout !== undefined ? {
      timeout
    } : undefined);
  });
  return deferred;
}
function batch(fn) {
  let pending = Pending,
      q = Pending = [];
  const result = fn();
  Pending = pending;
  runUpdates(() => {
    for (let i = 0; i < q.length; i += 1) {
      const data = q[i];
      if (data.pending !== NOTPENDING) {
        const pending = data.pending;
        data.pending = NOTPENDING;
        writeSignal.call(data, pending);
      }
    }
  });
  return result;
}
function untrack(fn) {
  let result,
      listener = Listener;
  Listener = null;
  result = fn();
  Listener = listener;
  return result;
}
function afterEffects(fn) {
  Afters.push(fn);
}
function onCleanup(fn) {
  if (Owner === null) console.warn("cleanups created outside a `createRoot` or `render` will never be run");else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
  return fn;
}
function onError(fn) {
  if (Owner === null) console.warn("error handlers created outside a `createRoot` or `render` will never be run");else if (Owner.context === null) Owner.context = {
    [ERROR]: [fn]
  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);
}
function getListener() {
  return Listener;
}
function createContext(defaultValue) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  return lookup(Owner, context.id) || context.defaultValue;
}
function getContextOwner() {
  return Owner;
}
function readSignal() {
  if (this.state && this.sources) {
    const updates = Updates;
    Updates = null;
    this.state === STALE ? updateComputation(this) : lookDownstream(this);
    Updates = updates;
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(value) {
  if (this.comparator && this.comparator(this.value, value)) return value;
  if (Pending) {
    if (this.pending === NOTPENDING) Pending.push(this);
    this.pending = value;
    return value;
  }
  this.value = value;
  if (this.observers && (!Updates || this.observers.length)) {
    runUpdates(() => {
      for (let i = 0; i < this.observers.length; i += 1) {
        const o = this.observers[i];
        if (o.observers && o.state !== PENDING) markUpstream(o);
        o.state = STALE;
        Updates.push(o);
      }
      if (Updates.length > 10e5) throw new Error("Potential Infinite Loop Detected.");
    });
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const owner = Owner,
        listener = Listener,
        time = ExecCount;
  Listener = Owner = node;
  const nextValue = node.fn(node.value);
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.observers && node.observers.length) {
      writeSignal.call(node, nextValue);
    } else node.value = nextValue;
    node.updatedAt = time;
  }
  Listener = listener;
  Owner = owner;
}
function createComputation(fn, init) {
  const c = {
    fn,
    state: 0,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: null
  };
  if (Owner === null) console.warn("computations created outside a `createRoot` or `render` will never be disposed");else if (Owner !== UNOWNED) {
    if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
  }
  return c;
}
function runTop(node) {
  let top = node.state === STALE && node,
      pending;
  while (node.fn && (node = node.owner)) {
    if (node.state === PENDING) pending = node;else if (node.state === STALE) {
      top = node;
      pending = undefined;
    }
  }
  if (pending) {
    const updates = Updates;
    Updates = null;
    lookDownstream(pending);
    Updates = updates;
    if (!top || top.state !== STALE) return;
  }
  top && updateComputation(top);
}
function runUpdates(fn) {
  if (Updates) return fn();
  Updates = [];
  ExecCount++;
  try {
    fn();
    for (let i = 0; i < Updates.length; i += 1) {
      try {
        runTop(Updates[i]);
      } catch (err) {
        handleError(err);
      }
    }
  } finally {
    Updates = null;
    while (Afters.length) Afters.shift()();
  }
}
function lookDownstream(node) {
  node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      if (source.state === STALE) runTop(source);else if (source.state === PENDING) lookDownstream(source);
    }
  }
}
function markUpstream(node) {
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (!o.state) {
      o.state = PENDING;
      o.observers && markUpstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(),
            index = node.sourceSlots.pop(),
            obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(),
              s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
    node.state = 0;
  }
  if (node.owned) {
    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();
    node.cleanups = null;
  }
  node.context = null;
}
function handleError(err) {
  const fns = lookup(Owner, ERROR);
  if (!fns) throw err;
  fns.forEach(f => f(err));
}
function callAll(ss) {
  return () => {
    for (let i = 0; i < ss.length; i++) ss[i]();
  };
}
function lookup(owner, key) {
  return owner && (owner.context && owner.context[key] || owner.owner && lookup(owner.owner, key));
}
function resolveChildren(children) {
  if (typeof children === "function") return createMemo(() => resolveChildren(children()));
  if (Array.isArray(children)) {
    const results = [];
    for (let i = 0; i < children.length; i++) {
      let result = resolveChildren(children[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children;
}
function createProvider(id) {
  return function provider(props) {
    let rendered;
    createEffect(() => {
      Owner.context = {
        [id]: props.value
      };
      rendered = untrack(() => resolveChildren(props.children));
    });
    return rendered;
  };
}

const $RAW = Symbol("state-raw"),
      $NODE = Symbol("state-node"),
      $PROXY = Symbol("state-proxy");
function wrap(value, traps) {
  return value[$PROXY] || (value[$PROXY] = new Proxy(value, traps || proxyTraps));
}
function isWrappable(obj) {
  return obj != null && typeof obj === "object" && (obj.__proto__ === Object.prototype || Array.isArray(obj));
}
function unwrap(item, skipGetters) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, skipGetters)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);
    let keys = Object.keys(item),
        desc = skipGetters && Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (skipGetters && desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, skipGetters)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getDataNodes(target) {
  let nodes = target[$NODE];
  if (!nodes) target[$NODE] = nodes = {};
  return nodes;
}
const proxyTraps = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === $PROXY) return receiver;
    const value = target[property];
    if (property === $NODE || property === "__proto__") return value;
    const wrappable = isWrappable(value);
    if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property))) {
      let nodes, node;
      if (wrappable && (nodes = getDataNodes(value))) {
        node = nodes._ || (nodes._ = createSignal());
        node[0]();
      }
      nodes = getDataNodes(target);
      node = nodes[property] || (nodes[property] = createSignal());
      node[0]();
    }
    return wrappable ? wrap(value) : value;
  },
  set() {
    return true;
  },
  deleteProperty() {
    return true;
  }
};
function setProperty(state, property, value, force) {
  if (!force && state[property] === value) return;
  const notify = Array.isArray(state) || !(property in state);
  if (value === undefined) {
    delete state[property];
  } else state[property] = value;
  let nodes = getDataNodes(state),
      node;
  (node = nodes[property]) && node[1]();
  notify && (node = nodes._) && node[1]();
}
function mergeState(state, value, force) {
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state, key, value[key], force);
  }
}
function updatePath(current, path, traversed = []) {
  let part,
      prev = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part,
          isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (isArray && partType === "object") {
      const {
        from = 0,
        to = current.length - 1,
        by = 1
      } = part;
      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    prev = current[part];
    traversed = [part].concat(traversed);
  }
  let value = path[0];
  if (typeof value === "function") {
    value = value(prev, traversed);
    if (value === prev) return;
  }
  if (part === undefined && value == undefined) return;
  value = unwrap(value);
  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
    mergeState(prev, value);
  } else setProperty(current, part, value);
}
function createState(state) {
  const unwrappedState = unwrap(state || {}, true);
  const wrappedState = wrap(unwrappedState);
  function setState(...args) {
    batch(() => updatePath(unwrappedState, args));
  }
  return [wrappedState, setState];
}

function applyState(target, parent, property, merge, key) {
  let previous = parent[property];
  if (target === previous) return;
  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {
    target !== previous && setProperty(parent, property, target);
    return;
  }
  if (Array.isArray(target)) {
    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {
      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {
        applyState(target[start], previous, start, merge, key);
      }
      const temp = new Array(target.length),
            newIndices = new Map();
      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
        temp[newEnd] = previous[end];
      }
      if (start > newEnd || start > end) {
        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);
        for (; j < target.length; j++) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        }
        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
      }
      newIndicesNext = new Array(newEnd + 1);
      for (j = newEnd; j >= start; j--) {
        item = target[j];
        keyVal = key ? item[key] : item;
        i = newIndices.get(keyVal);
        newIndicesNext[j] = i === undefined ? -1 : i;
        newIndices.set(keyVal, j);
      }
      for (i = start; i <= end; i++) {
        item = previous[i];
        keyVal = key ? item[key] : item;
        j = newIndices.get(keyVal);
        if (j !== undefined && j !== -1) {
          temp[j] = previous[i];
          j = newIndicesNext[j];
          newIndices.set(keyVal, j);
        }
      }
      for (j = start; j < target.length; j++) {
        if (j in temp) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        } else setProperty(previous, j, target[j]);
      }
    } else {
      for (let i = 0, len = target.length; i < len; i++) {
        applyState(target[i], previous, i, merge, key);
      }
    }
    if (previous.length > target.length) setProperty(previous, "length", target.length);
    return;
  }
  const targetKeys = Object.keys(target);
  for (let i = 0, len = targetKeys.length; i < len; i++) {
    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);
  }
  const previousKeys = Object.keys(previous);
  for (let i = 0, len = previousKeys.length; i < len; i++) {
    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);
  }
}
function reconcile(value, options = {}) {
  const {
    merge,
    key = "id"
  } = options,
        v = unwrap(value);
  return state => {
    if (!isWrappable(state)) return v;
    applyState(v, {
      state
    }, "state", merge, key);
    return state;
  };
}
const setterTraps = {
  get(target, property) {
    if (property === $RAW) return target;
    const value = target[property];
    return isWrappable(value) ? new Proxy(value, setterTraps) : value;
  },
  set(target, property, value) {
    setProperty(target, property, unwrap(value));
    return true;
  },
  deleteProperty(target, property) {
    setProperty(target, property, undefined);
    return true;
  }
};
function produce(fn) {
  return state => {
    if (isWrappable(state)) fn(new Proxy(state, setterTraps));
    return state;
  };
}

const FALLBACK = Symbol("fallback");
function mapArray(list, mapFn, options = {}) {
  let items = [],
      mapped = [],
      disposers = [],
      len = 0,
      indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => {
    for (let i = 0, length = disposers.length; i < length; i++) disposers[i]();
  });
  return () => {
    let newItems = list() || [],
        i,
        j;
    return untrack(() => {
      let newLen = newItems.length,
          newIndices,
          newIndicesNext,
          temp,
          tempdisposers,
          tempIndexes,
          start,
          end,
          newEnd,
          item;
      if (newLen === 0) {
        if (len !== 0) {
          for (i = 0; i < len; i++) disposers[i]();
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot(disposer => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      }
      else if (len === 0) {
          for (j = 0; j < newLen; j++) {
            items[j] = newItems[j];
            mapped[j] = createRoot(mapper);
          }
          len = newLen;
        } else {
          temp = new Array(newLen);
          tempdisposers = new Array(newLen);
          indexes && (tempIndexes = new Array(newLen));
          for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
          for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
            temp[newEnd] = mapped[end];
            tempdisposers[newEnd] = disposers[end];
            indexes && (tempIndexes[newEnd] = indexes[end]);
          }
          if (start > newEnd) {
            for (j = end; start <= j; j--) disposers[j]();
            const rLen = end - start + 1;
            if (rLen > 0) {
              mapped.splice(start, rLen);
              disposers.splice(start, rLen);
              if (indexes) {
                indexes.splice(start, rLen);
                for (j = start; j < newLen; j++) indexes[j](j);
              }
            }
            items = newItems.slice(0);
            len = newLen;
            return mapped;
          }
          if (start > end) {
            for (j = start; j <= newEnd; j++) mapped[j] = createRoot(mapper);
            for (; j < newLen; j++) {
              mapped[j] = temp[j];
              disposers[j] = tempdisposers[j];
              if (indexes) {
                indexes[j] = tempIndexes[j];
                indexes[j](j);
              }
            }
            items = newItems.slice(0);
            len = newLen;
            return mapped;
          }
          newIndices = new Map();
          newIndicesNext = new Array(newEnd + 1);
          for (j = newEnd; j >= start; j--) {
            item = newItems[j];
            i = newIndices.get(item);
            newIndicesNext[j] = i === undefined ? -1 : i;
            newIndices.set(item, j);
          }
          for (i = start; i <= end; i++) {
            item = items[i];
            j = newIndices.get(item);
            if (j !== undefined && j !== -1) {
              temp[j] = mapped[i];
              tempdisposers[j] = disposers[i];
              indexes && (tempIndexes[j] = indexes[i]);
              j = newIndicesNext[j];
              newIndices.set(item, j);
            } else disposers[i]();
          }
          for (j = start; j < newLen; j++) {
            if (j in temp) {
              mapped[j] = temp[j];
              disposers[j] = tempdisposers[j];
              if (indexes) {
                indexes[j] = tempIndexes[j];
                indexes[j](j);
              }
            } else mapped[j] = createRoot(mapper);
          }
          len = mapped.length = newLen;
          items = newItems.slice(0);
        }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j, true);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function indexArray(list, mapFn, options = {}) {
  let items = [],
      mapped = [],
      disposers = [],
      signals = [],
      len = 0,
      i;
  onCleanup(() => {
    for (let i = 0, length = disposers.length; i < length; i++) disposers[i]();
  });
  return () => {
    const newItems = list() || [];
    return untrack(() => {
      if (newItems.length === 0) {
        if (len !== 0) {
          for (i = 0; i < len; i++) disposers[i]();
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          signals = [];
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot(disposer => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
        return mapped;
      }
      if (items[0] === FALLBACK) {
        disposers[0]();
        disposers = [];
        items = [];
        mapped = [];
        len = 0;
      }
      for (i = 0; i < newItems.length; i++) {
        if (i < items.length && items[i] !== newItems[i]) {
          signals[i](newItems[i]);
        } else if (i >= items.length) {
          mapped[i] = createRoot(mapper);
        }
      }
      for (; i < items.length; i++) {
        disposers[i]();
      }
      len = mapped.length = signals.length = disposers.length = newItems.length;
      items = newItems.slice(0);
      return mapped;
    });
    function mapper(disposer) {
      disposers[i] = disposer;
      const [s, set] = createSignal(newItems[i]);
      signals[i] = set;
      return mapFn(s, i);
    }
  };
}

function createComponent(Comp, props) {
  return untrack(() => Comp(props));
}
function assignProps(target, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    const descriptors = Object.getOwnPropertyDescriptors(sources[i]);
    Object.defineProperties(target, descriptors);
  }
  return target;
}
function splitProps(props, ...keys) {
  const descriptors = Object.getOwnPropertyDescriptors(props),
        split = k => {
    const clone = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone;
  };
  return keys.map(split).concat(split(Object.keys(descriptors)));
}

function createActivityTracker() {
  let count = 0;
  const [read, trigger] = createSignal(false);
  return [read, () => count++ === 0 && trigger(true), () => --count <= 0 && trigger(false)];
}
const SuspenseContext = createContext({});
const [active, increment, decrement] = createActivityTracker();
SuspenseContext.active = active;
SuspenseContext.increment = increment;
SuspenseContext.decrement = decrement;
function awaitSuspense(fn) {
  return () => new Promise(resolve => {
    const res = fn();
    createEffect(() => !SuspenseContext.active() && resolve(res));
  });
}
function createResource(value, options = {}) {
  const [s, set] = createSignal(value),
        [trackPromise, triggerPromise] = createSignal(),
        [trackLoading, triggerLoading] = createSignal(),
        contexts = new Set(),
        h = globalThis._$HYDRATION;
  let loading = false,
      error = null,
      pr;
  function loadEnd(v) {
    pr = undefined;
    batch(() => {
      set(v);
      if (h.asyncSSR && options.name) h.resources[options.name] = v;
      loading && (loading = false, triggerLoading());
      for (let c of contexts.keys()) c.decrement();
      contexts.clear();
    });
  }
  function read() {
    const c = useContext(SuspenseContext),
          v = s();
    if (error) throw error;
    trackPromise();
    if (pr && c.increment && !contexts.has(c)) {
      c.increment();
      contexts.add(c);
    }
    return v;
  }
  function load(fn) {
    error = null;
    if (fn == null || typeof fn !== "function") return;
    let p;
    const hydrating = h.context && !!h.context.registry;
    if (hydrating) {
      if (h.loadResource && !options.notStreamed) {
        fn = h.loadResource;
      } else if (options.name && h.resources && options.name in h.resources) {
        fn = () => {
          const data = h.resources[options.name];
          delete h.resources[options.name];
          return data;
        };
      }
    }
    p = fn();
    if (typeof p !== "object" || !("then" in p)) {
      loadEnd(p);
      return p;
    }
    pr = p;
    if (!loading) {
      loading = true;
      batch(() => {
        triggerLoading();
        triggerPromise();
      });
    }
    return p.then(v => (pr === p && loadEnd(v), s()), err => (pr === p && (error = err, loadEnd(undefined)), s()));
  }
  Object.defineProperty(read, "loading", {
    get() {
      return trackLoading(), loading;
    }
  });
  return [read, load];
}
function createResourceNode(v, name) {
  const node = createSignal(),
        [r, load] = createResource(v, {
    name
  });
  return [() => (r(), node[0]()), node[1], load, () => r.loading];
}
function createResourceState(state, options = {}) {
  const loadingTraps = {
    get(nodes, property) {
      const node = nodes[property] || (nodes[property] = createResourceNode(undefined, name && `${options.name}:${property}`));
      return node[3]();
    },
    set() {
      return true;
    },
    deleteProperty() {
      return true;
    }
  };
  const resourceTraps = {
    get(target, property, receiver) {
      if (property === $RAW) return target;
      if (property === $PROXY) return receiver;
      if (property === "loading") return new Proxy(getDataNodes(target), loadingTraps);
      const value = target[property];
      if (property === $NODE || property === "__proto__") return value;
      const wrappable = isWrappable(value);
      if (getListener() && (typeof value !== "function" || target.hasOwnProperty(property))) {
        let nodes, node;
        if (wrappable && (nodes = getDataNodes(value))) {
          node = nodes._ || (nodes._ = createSignal());
          node[0]();
        }
        nodes = getDataNodes(target);
        node = nodes[property] || (nodes[property] = createResourceNode(value, `${options.name}:${property}`));
        node[0]();
      }
      return wrappable ? wrap(value) : value;
    },
    set() {
      return true;
    },
    deleteProperty() {
      return true;
    }
  };
  const unwrappedState = unwrap(state || {}, true),
        wrappedState = wrap(unwrappedState, resourceTraps);
  function setState(...args) {
    batch(() => updatePath(unwrappedState, args));
  }
  function loadState(v, r) {
    const nodes = getDataNodes(unwrappedState),
          keys = Object.keys(v);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i],
            node = nodes[k] || (nodes[k] = createResourceNode(unwrappedState[k], `${options.name}:${k}`)),
            resolver = v => (r ? setState(k, r(v)) : setProperty(unwrappedState, k, v), v),
            p = node[2](v[k]);
      typeof p === "object" && "then" in p ? p.then(resolver) : resolver(p);
    }
  }
  return [wrappedState, loadState, setState];
}
function lazy(fn) {
  return props => {
    const h = globalThis._$HYDRATION,
          hydrating = h.context && h.context.registry,
          ctx = nextHydrateContext(),
          [s, l] = createResource(undefined, {
      notStreamed: true
    });
    if (hydrating && h.resources) {
      fn().then(mod => l(() => mod.default));
    } else l(() => fn().then(mod => mod.default));
    let Comp;
    return createMemo(() => (Comp = s()) && untrack(() => {
      if (!ctx) return Comp(props);
      const c = h.context;
      setHydrateContext(ctx);
      const r = Comp(props);
      !c && setHydrateContext();
      return r;
    }));
  };
}
function useTransition(config) {
  const [pending, increment, decrement] = createActivityTracker();
  return [pending, fn => {
    const prevTransition = SuspenseContext.transition;
    SuspenseContext.transition = {
      timeoutMs: config.timeoutMs,
      increment,
      decrement
    };
    increment();
    fn();
    decrement();
    afterEffects(() => SuspenseContext.transition = prevTransition);
  }];
}
function suspend(fn) {
  const {
    state
  } = useContext(SuspenseContext),
        wrapped = createMemo(fn);
  let cached;
  return state ? createMemo(() => state() === "suspended" ? cached : cached = wrapped()) : wrapped;
}
function setHydrateContext(context) {
  globalThis._$HYDRATION.context = context;
}
function nextHydrateContext() {
  const hydration = globalThis._$HYDRATION;
  return hydration && hydration.context ? {
    id: `${hydration.context.id}.${hydration.context.count++}`,
    count: 0,
    registry: hydration.context.registry
  } : undefined;
}

function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return suspend(mapArray(() => props.each, props.children, fallback ? fallback : undefined));
}
function Index(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return suspend(indexArray(() => props.each, props.children, fallback ? fallback : undefined));
}
function Show(props) {
  const childDesc = Object.getOwnPropertyDescriptor(props, "children").value,
        callFn = typeof childDesc === "function" && childDesc.length,
        condition = createMemo(callFn ? () => props.when : () => !!props.when, undefined, true);
  return suspend(() => {
    const c = condition();
    return c ? callFn ? untrack(() => props.children(c)) : props.children : props.fallback;
  });
}
function Switch(props) {
  let conditions = props.children;
  Array.isArray(conditions) || (conditions = [conditions]);
  const evalConditions = createMemo(() => {
    for (let i = 0; i < conditions.length; i++) {
      const c = conditions[i].when;
      if (c) return [i, conditions[i].keyed ? c : !!c];
    }
    return [-1];
  }, undefined, (a, b) => a && a[0] === b[0] && a[1] === b[1]);
  return suspend(() => {
    const [index, when] = evalConditions();
    if (index < 0) return props.fallback;
    const c = conditions[index].children;
    return typeof c === "function" && c.length ? untrack(() => c(when)) : c;
  });
}
function Match(props) {
  const childDesc = Object.getOwnPropertyDescriptor(props, "children").value;
  props.keyed = typeof childDesc === "function" && !!childDesc.length;
  return props;
}
function ErrorBoundary(props) {
  const [errored, setErrored] = createSignal(),
        fallbackDesc = Object.getOwnPropertyDescriptor(props, "fallback").value,
        callFn = typeof fallbackDesc === "function" && !!fallbackDesc.length;
  onError(setErrored);
  let e;
  return createMemo(() => (e = errored()) != null ? callFn ? untrack(() => props.fallback(e)) : props.fallback : props.children);
}
function Dynamic(props) {
  const [p, others] = splitProps(props, ["component"]);
  return suspend(() => {
    const comp = p.component;
    return comp && untrack(() => comp(others));
  });
}

const SuspenseListContext = createContext();
function SuspenseList(props) {
  let index = 0,
      suspenseSetter,
      showContent,
      showFallback;
  const listContext = useContext(SuspenseListContext);
  if (listContext) {
    const [state, stateSetter] = createSignal("running", true);
    suspenseSetter = stateSetter;
    [showContent, showFallback] = listContext.register(state);
  }
  const registry = [],
        comp = createComponent(SuspenseListContext.Provider, {
    value: {
      register: state => {
        const [showingContent, showContent] = createSignal(false, true),
              [showingFallback, showFallback] = createSignal(false, true);
        registry[index++] = {
          state,
          showContent,
          showFallback
        };
        return [showingContent, showingFallback];
      }
    },
    get children() {
      return props.children;
    }
  });
  createEffect(() => {
    const reveal = props.revealOrder,
          tail = props.tail,
          visibleContent = showContent ? showContent() : true,
          visibleFallback = showFallback ? showFallback() : true,
          reverse = reveal === "backwards";
    if (reveal === "together") {
      const all = registry.every(i => i.state() === "running");
      suspenseSetter && suspenseSetter(all ? "running" : "fallback");
      registry.forEach(i => {
        i.showContent(all && visibleContent);
        i.showFallback(visibleFallback);
      });
      return;
    }
    let stop = false;
    for (let i = 0, len = registry.length; i < len; i++) {
      const n = reverse ? len - i - 1 : i,
            s = registry[n].state();
      if (!stop && (s === "running" || s === "suspended")) {
        registry[n].showContent(visibleContent);
        registry[n].showFallback(visibleFallback);
      } else {
        const next = !stop;
        if (next && suspenseSetter) suspenseSetter("fallback");
        if (!tail || next && tail === "collapsed") {
          registry[n].showFallback(visibleFallback);
        } else registry[n].showFallback(false);
        stop = true;
        registry[n].showContent(next);
      }
    }
    if (!stop && suspenseSetter) suspenseSetter("running");
  });
  return comp;
}
function Suspense(props) {
  let counter = 0,
      t,
      showContent,
      showFallback,
      transition;
  const [state, nextState] = createSignal("running", true),
        store = {
    increment: () => {
      if (++counter === 1) {
        if (!store.initializing) {
          if (SuspenseContext.transition) {
            !transition && (transition = SuspenseContext.transition).increment();
            t = setTimeout(() => nextState("fallback"), SuspenseContext.transition.timeoutMs);
            nextState("suspended");
          } else nextState("fallback");
        } else nextState("fallback");
        SuspenseContext.increment();
      }
    },
    decrement: () => {
      if (--counter === 0) {
        t && clearTimeout(t);
        transition && transition.decrement();
        transition = undefined;
        nextState("running");
        afterEffects(() => SuspenseContext.decrement());
      }
    },
    state,
    initializing: true
  };
  const listContext = useContext(SuspenseListContext);
  if (listContext) [showContent, showFallback] = listContext.register(store.state);
  return createComponent(SuspenseContext.Provider, {
    value: store,
    get children() {
      const rendered = untrack(() => props.children);
      return () => {
        const value = store.state(),
              visibleContent = showContent ? showContent() : true,
              visibleFallback = showFallback ? showFallback() : true;
        if (store.initializing) store.initializing = false;
        if (value === "running" && visibleContent || value === "suspended") return rendered;
        if (!visibleFallback) return;
        return props.fallback;
      };
    }
  });
}

if (!globalThis.Solid$$) globalThis.Solid$$ = true;else console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior.");




/***/ }),

/***/ "./node_modules/stage0/index.js":
/*!**************************************!*\
  !*** ./node_modules/stage0/index.js ***!
  \**************************************/
/*! exports provided: compile, h, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compile", function() { return compile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });

function collector(node) {
  if (node.nodeType !== 3) {
    if (node.attributes !== undefined) {
      for(let attr of Array.from(node.attributes)) {
        let aname = attr.name
        if (aname[0] === '#') {
          node.removeAttribute(aname)
          return aname.slice(1)
        }
      }
    }
    return 0
  } else {
    let nodeData = node.nodeValue
    if (nodeData[0] === '#') {
      node.nodeValue = ""
      return nodeData.slice(1)
    }
    return 0
  }
}

const TREE_WALKER = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false)
TREE_WALKER.roll = function(n) {
  while(--n) this.nextNode()
  return this.currentNode
}

class Ref {
  constructor(idx, ref) {
    this.idx = idx
    this.ref = ref
  }
}

function genPath(node) {
  const w = TREE_WALKER
  w.currentNode = node

  let indices = [], ref, idx = 0
  do {
    if (ref = collector(node)) {
      indices.push(new Ref(idx+1, ref))
      idx = 1
    } else {
      idx++
    }
  } while(node = w.nextNode())

  return indices
}

function walker(node) {
  const refs = {}

  const w = TREE_WALKER
  w.currentNode = node

  this._refPaths.map(x => refs[x.ref] = w.roll(x.idx))

  return refs
}

function compile(node) {
    node._refPaths = genPath(node)
    node.collect = walker
}

const compilerTemplate = document.createElement('template')
function h(strings, ...args) {
  const template = String.raw(strings, ...args)
    .replace(/>\n+/g, '>')
    .replace(/\s+</g, '<')
    .replace(/>\s+/g, '>')
    .replace(/\n\s+/g, '<!-- -->')
  compilerTemplate.innerHTML = template
  const content = compilerTemplate.content.firstChild
  compile(content)
  return content
}
/* harmony default export */ __webpack_exports__["default"] = (h);


/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/*! exports provided: default, animateFill, createSingleton, delegate, followCursor, hideAll, inlinePositioning, roundArrow, sticky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateFill", function() { return animateFill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSingleton", function() { return createSingleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delegate", function() { return delegate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "followCursor", function() { return followCursor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideAll", function() { return hideAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inlinePositioning", function() { return inlinePositioning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundArrow", function() { return ROUND_ARROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sticky", function() { return sticky; });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/**!
* tippy.js v6.2.3
* (c) 2017-2020 atomiks
* MIT License
*/


var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}

function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;

if (true) {
  resetVisitedMessages();
}

function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;

    visitedMessages.add(message);

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;

    visitedMessages.add(message);

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: function appendTo() {
    return document.body;
  },
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if (true) {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;

var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // ===========================================================================
  //  Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var doc = getOwnerDocument(props.triggerTarget || reference); // ===========================================================================
  //  Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests 
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if (true) {
      errorWhen(true, 'render() function has not been supplied.');
    }

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      doc.addEventListener('mousemove', debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance; // ===========================================================================
  //  Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    doc.body.removeEventListener('mouseleave', scheduleHide);
    doc.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    } // Clicked on interactive popper


    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      isVisibleFromClick = false;
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = reference.contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = Object(_popperjs_core__WEBPACK_IMPORTED_MODULE_0__["createPopper"])(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    createPopperInstance();
    /* istanbul ignore else */

    if (true) {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  //  Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }

    doc.body.addEventListener('mouseleave', scheduleHide);
    doc.addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();

      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

var createSingleton = function createSingleton(tippyInstances, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if (true) {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }

  var mutTippyInstances = tippyInstances;
  var references = [];
  var currentTarget;
  var overrides = optionalProps.overrides;

  function setReferences() {
    references = mutTippyInstances.map(function (instance) {
      return instance.reference;
    });
  }

  function enableInstances(isEnabled) {
    mutTippyInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }

  enableInstances(false);
  setReferences();
  var singleton = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onTrigger: function onTrigger(instance, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
            acc[prop] = mutTippyInstances[index].props[prop];
            return acc;
          }, {});
          instance.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: function getReferenceClientRect() {
              return target.getBoundingClientRect();
            }
          }));
        }
      };
    }
  };
  var instance = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [singleton].concat(optionalProps.plugins || []),
    triggerTarget: references
  }));
  var originalSetProps = instance.setProps;

  instance.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };

  instance.setInstances = function (nextInstances) {
    enableInstances(true);
    mutTippyInstances = nextInstances;
    enableInstances(false);
    setReferences();
    instance.setProps({
      triggerTarget: references
    });
  };

  return instance;
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if (true) {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  var listeners = [];
  var childTippyInstances = [];
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({}, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);

  function onTrigger(event) {
    if (!event.target) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }

    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }

    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type])) {
      return;
    }

    var instance = tippy(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
      if (true) {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }

      return {};
    }

    var _getChildren = getChildren(instance.popper),
        box = _getChildren.box,
        content = _getChildren.content;

    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var initialMouseCoords = null;

    function getIsManual() {
      return instance.props.trigger.trim() === 'manual';
    }

    function getIsEnabled() {
      // #597
      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard "click"
      initialMouseCoords !== null && !(initialMouseCoords.clientX === 0 && initialMouseCoords.clientY === 0);
      return instance.props.followCursor && isValidMouseEvent;
    }

    function getIsInitialBehavior() {
      return currentInput.isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function unsetReferenceClientRect(shouldUnset) {
      if (shouldUnset) {
        instance.setProps({
          getReferenceClientRect: null
        });
      }
    }

    function handleMouseMoveListener() {
      if (getIsEnabled()) {
        addListener();
      } else {
        unsetReferenceClientRect(instance.props.followCursor);
      }
    }

    function triggerLastMouseMove() {
      if (getIsEnabled()) {
        onMouseMove(initialMouseCoords);
      }
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(event) {
      initialMouseCoords = {
        clientX: event.clientX,
        clientY: event.clientY
      }; // If the instance is interactive, avoid updating the position unless it's
      // over the reference element

      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
          clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;

      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;

            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }

            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }

      if (getIsInitialBehavior()) {
        removeListener();
      }
    }

    return {
      onAfterUpdate: function onAfterUpdate(_, _ref) {
        var followCursor = _ref.followCursor;

        if (followCursor !== undefined && !followCursor) {
          unsetReferenceClientRect(true);
        }
      },
      onMount: function onMount() {
        triggerLastMouseMove();
      },
      onShow: function onShow() {
        if (getIsManual()) {
          // Since there's no trigger event to use, we have to use these as
          // baseline coords
          initialMouseCoords = {
            clientX: 0,
            clientY: 0
          };
          handleMouseMoveListener();
        }
      },
      onTrigger: function onTrigger(_, event) {
        // Tapping on touch devices can trigger `mouseenter` then `focus`
        if (initialMouseCoords) {
          return;
        }

        if (isMouseEvent(event)) {
          initialMouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }

        handleMouseMoveListener();
      },
      onUntrigger: function onUntrigger() {
        // If untriggered before showing (`onHidden` will never be invoked)
        if (!instance.state.isVisible) {
          removeListener();
          initialMouseCoords = null;
        }
      },
      onHidden: function onHidden() {
        removeListener();
        initialMouseCoords = null;
      }
    };
  }
};

function getProps(props, modifier) {
  var _props$popperOptions;

  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }

    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (isEnabled()) {
          if (placement !== state.placement) {
            instance.setProps({
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }

          placement = state.placement;
        }
      }
    };

    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }

    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }

    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }

    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          cursorRectIndex = rects.indexOf(cursorRect);
        }
      },
      onUntrigger: function onUntrigger() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined


  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}

tippy.setDefaultProps({
  render: render
});

/* harmony default export */ __webpack_exports__["default"] = (tippy);

//# sourceMappingURL=tippy.esm.js.map


/***/ }),

/***/ "./src/app/apis/app.ts":
/*!*****************************!*\
  !*** ./src/app/apis/app.ts ***!
  \*****************************/
/*! exports provided: STORAGES, ART, VIEW, ENGINE_API, BOARD, DEFAULT_BOARD, STATE, REFERENCE_TRACKER, RESOURCES, GRID, SCHEDULER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STORAGES", function() { return STORAGES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ART", function() { return ART; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VIEW", function() { return VIEW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENGINE_API", function() { return ENGINE_API; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOARD", function() { return BOARD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_BOARD", function() { return DEFAULT_BOARD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE", function() { return STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REFERENCE_TRACKER", function() { return REFERENCE_TRACKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOURCES", function() { return RESOURCES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID", function() { return GRID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULER", function() { return SCHEDULER; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");

var STORAGES = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Storages');
var ART = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('ArtProvider');
var VIEW = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('View');
var ENGINE_API = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]("Engine Api");
var BOARD = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Borad');
var DEFAULT_BOARD = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Default Board');
var STATE = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('State');
var REFERENCE_TRACKER = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('BuildReferenceTracker');
var RESOURCES = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Build Resources');
var GRID = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('GridController');
var SCHEDULER = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Scheduler');

/***/ }),

/***/ "./src/app/apis/builder.ts":
/*!*********************************!*\
  !*** ./src/app/apis/builder.ts ***!
  \*********************************/
/*! exports provided: Builders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Builders", function() { return Builders; });
class Builders {
  constructor(builders, copy) {
    if (copy === void 0) {
      copy = [...builders];
    }

    this.copy = copy;
  }

  get() {
    return this;
  }

  reset() {
    var size = this.copy.length - 1;

    while (size >= 0) {
      this.copy[size--].reset();
    }
  }

  drawCall(consumer) {
    var size = this.copy.length - 1;

    while (size >= 0) {
      this.copy[size--].get().drawCall(consumer);
    }
  }

  needToRebuild() {
    var size = this.copy.length - 1;

    while (size >= 0) {
      this.copy[size--].needToRebuild();
    }
  }

}

/***/ }),

/***/ "./src/app/apis/handler.ts":
/*!*********************************!*\
  !*** ./src/app/apis/handler.ts ***!
  \*********************************/
/*! exports provided: BUS, DefaultMessageBus, handleReflective, handleCollection, MessageHandlerReflective, MessageHandlerList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUS", function() { return BUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMessageBus", function() { return DefaultMessageBus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleReflective", function() { return handleReflective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleCollection", function() { return handleCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageHandlerReflective", function() { return MessageHandlerReflective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageHandlerList", function() { return MessageHandlerList; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var BUS = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('Message Bus');
function DefaultMessageBus(_x) {
  return _DefaultMessageBus.apply(this, arguments);
}

function _DefaultMessageBus() {
  _DefaultMessageBus = _asyncToGenerator(function* (injector) {
    var list = new MessageHandlerList();
    return {
      connect: h => list.list().push(h),
      handle: msg => {
        try {
          list.handle(msg);
        } catch (e) {
          Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__["error"])(e, e.stack);
        }
      }
    };
  });
  return _DefaultMessageBus.apply(this, arguments);
}

var messageBox = [null];
function handleReflective(obj, message) {
  var name = message.constructor.name;
  var handler = obj[name];

  if (handler != undefined) {
    messageBox[0] = message;
    handler.apply(obj, messageBox);
    return true;
  }

  return false;
}
function handleCollection(handlers, message) {
  for (var h of handlers) {
    h.handle(message);
  }
}
class MessageHandlerReflective {
  handle(message) {
    if (!handleReflective(this, message)) this.handleDefault(message);
  }

  handleDefault(message) {}

}
class MessageHandlerList {
  constructor(handlers) {
    if (handlers === void 0) {
      handlers = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    }

    this.handlers = handlers;
  }

  handle(message) {
    handleCollection(this.handlers, message);
  }

  list() {
    return this.handlers;
  }

  clone() {
    return new MessageHandlerList(this.handlers.clone());
  }

}

/***/ }),

/***/ "./src/app/apis/referencetracker.ts":
/*!******************************************!*\
  !*** ./src/app/apis/referencetracker.ts ***!
  \******************************************/
/*! exports provided: track, ReferenceTrackerImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "track", function() { return track; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReferenceTrackerImpl", function() { return ReferenceTrackerImpl; });
/* harmony import */ var _utils_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/list */ "./src/utils/list.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");


function track(refs, f) {
  var crefs = refs.start();
  f(crefs);
  crefs.stop();
}
class ReferenceTrackerImpl {
  constructor(nil, parent, parentNode, refs, nested, stopped) {
    if (parent === void 0) {
      parent = null;
    }

    if (parentNode === void 0) {
      parentNode = null;
    }

    if (refs === void 0) {
      refs = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["IndexedDeck"]();
    }

    if (nested === void 0) {
      nested = new _utils_list__WEBPACK_IMPORTED_MODULE_0__["List"]();
    }

    if (stopped === void 0) {
      stopped = false;
    }

    this.nil = nil;
    this.parent = parent;
    this.parentNode = parentNode;
    this.refs = refs;
    this.nested = nested;
    this.stopped = stopped;
  }

  ref(value) {
    if (this.stopped) return -1;
    var ref = this.refs.indexOf(value);

    if (ref == -1) {
      this.refs.push(value);
      ref = this.refs.length() - 1;
    }

    return ref;
  }

  val(ref) {
    if (this.stopped) return this.nil;
    var val = this.refs.get(ref);
    return val == undefined ? this.nil : val;
  }

  update(updater) {
    if (this.stopped) return;

    for (var i = 0; i < this.refs.length(); i++) {
      var r = this.refs.get(i);
      if (r == this.nil) continue;
      this.refs.set(i, updater(r));
    }

    for (var n of this.nested) {
      n.update(updater);
    }
  }

  start() {
    if (this.stopped) throw new Error('Tracker already stopped');
    var tracker = new ReferenceTrackerImpl(this.nil, this);
    tracker.parentNode = this.nested.push(tracker);
    return tracker;
  }

  stop() {
    if (this.stopped) return;
    if (this.parent == null) throw new Error('Cannot stop root trackers');
    this.parent.nested.remove(this.parentNode);

    for (var n of this.nested) {
      n.stop();
    }

    this.nested = null;
    this.refs = null;
    this.stopped = true;
  }

}

/***/ }),

/***/ "./src/app/apis/renderable.ts":
/*!************************************!*\
  !*** ./src/app/apis/renderable.ts ***!
  \************************************/
/*! exports provided: NULL_RENDERABLE, SPRITE_LABEL, HELPER_GRID, SortingRenderable, Renderables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NULL_RENDERABLE", function() { return NULL_RENDERABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPRITE_LABEL", function() { return SPRITE_LABEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HELPER_GRID", function() { return HELPER_GRID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SortingRenderable", function() { return SortingRenderable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderables", function() { return Renderables; });
var NULL_RENDERABLE = {
  drawCall: consumer => {}
};
var SPRITE_LABEL = 1 << 0;
var HELPER_GRID = 1 << 1;

var sorter = (l, r) => l.hint - r.hint;

class SortingRenderable {
  constructor(renderables, filter) {
    if (filter === void 0) {
      filter = () => true;
    }

    this.drawList = [];
    this.renderables = renderables;
    this.filter = filter;
  }

  drawCall(consumer) {
    this.drawList = [];

    for (var r of this.renderables) {
      r.drawCall(dc => {
        if (this.filter(dc.kind)) this.drawList.push(dc);
      });
    }

    var sorted = this.drawList.sort(sorter);

    for (var dc of sorted) {
      consumer(dc);
    }
  }

}
class Renderables {
  constructor(renderables) {
    this.renderables = renderables;
  }

  drawCall(consumer) {
    for (var r of this.renderables) {
      r.drawCall(consumer);
    }
  }

}

/***/ }),

/***/ "./src/app/apis/scheduler.ts":
/*!***********************************!*\
  !*** ./src/app/apis/scheduler.ts ***!
  \***********************************/
/*! exports provided: DefaultScheduler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultScheduler", function() { return DefaultScheduler; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handler */ "./src/app/apis/handler.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




function DefaultScheduler(_x) {
  return _DefaultScheduler.apply(this, arguments);
}

function _DefaultScheduler() {
  _DefaultScheduler = _asyncToGenerator(function* (injector) {
    var bus = yield injector.getInstance(_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]);
    var scheduler = new SchedulerImpl();
    bus.connect(scheduler);
    return scheduler;
  });
  return _DefaultScheduler.apply(this, arguments);
}

class TaskHandleImpl {
  constructor(stopped, description, progress) {
    if (stopped === void 0) {
      stopped = false;
    }

    if (description === void 0) {
      description = "";
    }

    if (progress === void 0) {
      progress = -1;
    }

    this.stopped = stopped;
    this.description = description;
    this.progress = progress;
  }

  stop() {
    this.stopped = true;
  }

  isStopped() {
    return this.stopped;
  }

  getDescription() {
    return this.description;
  }

  getProgress() {
    return this.progress;
  }

  setDescription(s) {
    this.description = s;
  }

  setProgress(p) {
    this.progress = p;
  }

}

class SchedulerImpl extends _handler__WEBPACK_IMPORTED_MODULE_2__["MessageHandlerReflective"] {
  constructor() {
    super(...arguments);
    this.tasks = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.nextTasks = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.handlers = [];
  }

  addTask(task) {
    var handle = new TaskHandleImpl();
    this.tasks.push([handle, task]);
    this.handleAdd(handle);
    return handle;
  }

  addHandler(handler) {
    this.handlers.push(handler);
  }

  removeHandler(handler) {
    var idx = this.handlers.indexOf(handler);
    if (idx != -1) this.handlers.splice(idx, 1);
  }

  currentTasks() {
    return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(this.tasks).map(t => t[0]);
  }

  handleAdd(task) {
    for (var h of this.handlers) {
      h.onTaskAdd(task);
    }
  }

  handleStop(task) {
    for (var h of this.handlers) {
      h.onTaskStop(task);
    }
  }

  handleUpdate(task) {
    for (var h of this.handlers) {
      h.onTaskUpdate(task);
    }
  }

  PostFrame(msg) {
    this.nextTasks.clear();

    for (var ent of this.tasks) {
      var [handle, task] = ent;

      if (!handle.isStopped()) {
        var result = task.next(handle);
        this.handleUpdate(handle);
        if (result.done) handle.stop();
      }

      if (handle.isStopped()) this.handleStop(handle);else this.nextTasks.push(ent);
    }

    [this.nextTasks, this.tasks] = [this.tasks, this.nextTasks];
  }

}

/***/ }),

/***/ "./src/app/apis/ui.ts":
/*!****************************!*\
  !*** ./src/app/apis/ui.ts ***!
  \****************************/
/*! exports provided: UI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UI", function() { return UI; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");

var UI = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('UI');

/***/ }),

/***/ "./src/app/edit/context.ts":
/*!*********************************!*\
  !*** ./src/app/edit/context.ts ***!
  \*********************************/
/*! exports provided: EditContext, EditContextConstructor, EntityFactory, ENTITY_FACTORY, EntityFactoryConstructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditContext", function() { return EditContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditContextConstructor", function() { return EditContextConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityFactory", function() { return EntityFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENTITY_FACTORY", function() { return ENTITY_FACTORY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityFactoryConstructor", function() { return EntityFactoryConstructor; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sector */ "./src/app/edit/sector.ts");
/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sprite */ "./src/app/edit/sprite.ts");
/* harmony import */ var _wall__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wall */ "./src/app/edit/wall.ts");
/* harmony import */ var _wallsegment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wallsegment */ "./src/app/edit/wallsegment.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }








class EditContext {
  constructor() {
    this.board = void 0;
    this.api = void 0;
    this.view = void 0;
    this.gridController = void 0;
    this.bus = void 0;
    this.state = void 0;
    this.refs = void 0;
    this.art = void 0;
  }

}
function EditContextConstructor(_x) {
  return _EditContextConstructor.apply(this, arguments);
}

function _EditContextConstructor() {
  _EditContextConstructor = _asyncToGenerator(function* (injector) {
    var [board, api, view, gridController, bus, state, refs, art] = yield Promise.all([injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["ENGINE_API"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["VIEW"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["GRID"]), injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["STATE"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["REFERENCE_TRACKER"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["ART"])]);
    return {
      board,
      api,
      view,
      gridController,
      bus,
      state,
      refs,
      art
    };
  });
  return _EditContextConstructor.apply(this, arguments);
}

class EntityFactory {
  constructor(ctx) {
    this.ctx = ctx;
  }

  sector(ent) {
    return new _sector__WEBPACK_IMPORTED_MODULE_3__["SectorEnt"](ent, this.ctx);
  }

  sprite(id) {
    return new _sprite__WEBPACK_IMPORTED_MODULE_4__["SpriteEnt"](id, this.ctx);
  }

  wall(id) {
    return new _wall__WEBPACK_IMPORTED_MODULE_5__["WallEnt"](id, this.ctx);
  }

  wallSegment(ids, hids, bottom) {
    if (hids === void 0) {
      hids = ids;
    }

    if (bottom === void 0) {
      bottom = false;
    }

    return new _wallsegment__WEBPACK_IMPORTED_MODULE_6__["WallSegmentsEnt"](ids, hids, bottom, this.ctx);
  }

}
var ENTITY_FACTORY = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('Entity Factory');
function EntityFactoryConstructor(_x2) {
  return _EntityFactoryConstructor.apply(this, arguments);
}

function _EntityFactoryConstructor() {
  _EntityFactoryConstructor = _asyncToGenerator(function* (injector) {
    var ctx = yield EditContextConstructor(injector);
    return new EntityFactory(ctx);
  });
  return _EntityFactoryConstructor.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/edit/editutils.ts":
/*!***********************************!*\
  !*** ./src/app/edit/editutils.ts ***!
  \***********************************/
/*! exports provided: invalidateSectorAndWalls, getClosestSectorZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invalidateSectorAndWalls", function() { return invalidateSectorAndWalls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClosestSectorZ", function() { return getClosestSectorZ; });
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./messages */ "./src/app/edit/messages.ts");




function invalidateSectorAndWalls(sectorId, board, bus) {
  bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_3__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["Entity"](sectorId, _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["EntityType"].CEILING)));
  var sec = board.sectors[sectorId];
  var end = sec.wallnum + sec.wallptr;

  for (var w = sec.wallptr; w < end; w++) {
    bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_3__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["Entity"](w, _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["EntityType"].WALL_POINT)));
    bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_3__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["Entity"](board.walls[w].nextwall, _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["EntityType"].WALL_POINT)));
  }
}
var sectorZesult = [null, 0];
function getClosestSectorZ(board, sectorId, x, y, z) {
  var sector = board.sectors[sectorId];
  var fz = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["slope"])(board, sectorId, x, y, sector.floorheinum) + sector.floorz;
  var cz = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["slope"])(board, sectorId, x, y, sector.ceilingheinum) + sector.ceilingz;
  return Math.abs(z - fz) < Math.abs(z - cz) ? Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["tuple2"])(sectorZesult, _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["EntityType"].FLOOR, fz) : Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["tuple2"])(sectorZesult, _build_hitscan__WEBPACK_IMPORTED_MODULE_0__["EntityType"].CEILING, cz);
}

/***/ }),

/***/ "./src/app/edit/handle.ts":
/*!********************************!*\
  !*** ./src/app/edit/handle.ts ***!
  \********************************/
/*! exports provided: MovingHandle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MovingHandle", function() { return MovingHandle; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");


class MovingHandle {
  constructor() {
    this.startPoint = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    this.currentPoint = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    this.dzoff = 0;
    this.active = false;
    this.vertical = false;
    this.parallel = false;
  }

  start(pos) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(this.startPoint, pos);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(this.currentPoint, this.startPoint);
    this.dzoff = 0;
    this.active = true;
  }

  update(vertical, parallel, start, dir) {
    this.parallel = parallel;
    this.vertical = vertical;

    if (vertical) {
      var dx = this.currentPoint[0] - start[0];
      var dy = this.currentPoint[2] - start[2];
      var t = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["len2d"])(dx, dy) / Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["len2d"])(dir[0], dir[2]);
      this.dzoff = dir[1] * t + start[1] - this.currentPoint[1];
    } else {
      this.dzoff = 0;
      var dz = this.startPoint[1] - start[1];

      var _t = dz / dir[1];

      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(this.currentPoint, dir);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(this.currentPoint, this.currentPoint, _t);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].add(this.currentPoint, this.currentPoint, start);
    }
  }

  isActive() {
    return this.active;
  }

  stop() {
    this.active = false;
  }

  get dx() {
    return this.parallel && Math.abs(this.dx_()) < Math.abs(this.dy_()) ? 0 : this.dx_();
  }

  get dy() {
    return this.parallel && Math.abs(this.dy_()) < Math.abs(this.dx_()) ? 0 : this.dy_();
  }

  get dz() {
    return this.vertical ? this.currentPoint[1] - this.startPoint[1] + this.dzoff : 0;
  }

  dx_() {
    return this.currentPoint[0] - this.startPoint[0];
  }

  dy_() {
    return this.currentPoint[2] - this.startPoint[2];
  }

}

/***/ }),

/***/ "./src/app/edit/messages.ts":
/*!**********************************!*\
  !*** ./src/app/edit/messages.ts ***!
  \**********************************/
/*! exports provided: NamedMessage, LoadBoard, StartMove, Move, EndMove, Rotate, Highlight, Render, SetPicnum, Shade, PanRepeat, ResetPanRepeat, Palette, Flip, SpriteMode, Frame, BoardInvalidate, PostFrame, Mouse, SetWallCstat, SetSectorCstat, SetSpriteCstat, COMMIT, INVALIDATE_ALL, namedMessageHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NamedMessage", function() { return NamedMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadBoard", function() { return LoadBoard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StartMove", function() { return StartMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Move", function() { return Move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EndMove", function() { return EndMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rotate", function() { return Rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Highlight", function() { return Highlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Render", function() { return Render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetPicnum", function() { return SetPicnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shade", function() { return Shade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanRepeat", function() { return PanRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResetPanRepeat", function() { return ResetPanRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Palette", function() { return Palette; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Flip", function() { return Flip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMode", function() { return SpriteMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frame", function() { return Frame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoardInvalidate", function() { return BoardInvalidate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PostFrame", function() { return PostFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mouse", function() { return Mouse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetWallCstat", function() { return SetWallCstat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSectorCstat", function() { return SetSectorCstat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSpriteCstat", function() { return SetSpriteCstat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMMIT", function() { return COMMIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INVALIDATE_ALL", function() { return INVALIDATE_ALL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "namedMessageHandler", function() { return namedMessageHandler; });
class NamedMessage {
  constructor(name) {
    this.name = name;
  }

}
class LoadBoard {
  constructor(board) {
    this.board = board;
  }

}
class StartMove {}
class Move {
  constructor(dx, dy, dz) {
    this.dx = dx;
    this.dy = dy;
    this.dz = dz;
  }

}
class EndMove {}
class Rotate {
  constructor(da) {
    this.da = da;
  }

}
;
class Highlight {
  constructor(set) {
    if (set === void 0) {
      set = new Set();
    }

    this.set = set;
  }

}
class Render {
  constructor(consumer) {
    this.consumer = consumer;
  }

}
class SetPicnum {
  constructor(picnum) {
    this.picnum = picnum;
  }

}
class Shade {
  constructor(value, absolute) {
    if (absolute === void 0) {
      absolute = false;
    }

    this.value = value;
    this.absolute = absolute;
  }

}
class PanRepeat {
  constructor(xpan, ypan, xrepeat, yrepeat, absolute) {
    if (absolute === void 0) {
      absolute = false;
    }

    this.xpan = xpan;
    this.ypan = ypan;
    this.xrepeat = xrepeat;
    this.yrepeat = yrepeat;
    this.absolute = absolute;
  }

}
class ResetPanRepeat {}
class Palette {
  constructor(value, max, absolute) {
    if (absolute === void 0) {
      absolute = false;
    }

    this.value = value;
    this.max = max;
    this.absolute = absolute;
  }

}
class Flip {
  constructor() {}

}
class SpriteMode {}
class Frame {
  constructor(dt) {
    this.dt = dt;
  }

}
class BoardInvalidate {
  constructor(ent) {
    this.ent = ent;
  }

}
class PostFrame {}
class Mouse {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

}
class SetWallCstat {
  constructor(name, value, toggle) {
    if (value === void 0) {
      value = false;
    }

    if (toggle === void 0) {
      toggle = true;
    }

    this.name = name;
    this.value = value;
    this.toggle = toggle;
  }

}
class SetSectorCstat {
  constructor(name, value, toggle) {
    if (value === void 0) {
      value = false;
    }

    if (toggle === void 0) {
      toggle = true;
    }

    this.name = name;
    this.value = value;
    this.toggle = toggle;
  }

}
class SetSpriteCstat {
  constructor(name, value, toggle) {
    if (value === void 0) {
      value = false;
    }

    if (toggle === void 0) {
      toggle = true;
    }

    this.name = name;
    this.value = value;
    this.toggle = toggle;
  }

}
var COMMIT = new NamedMessage('commit');
var INVALIDATE_ALL = new BoardInvalidate(null);
function namedMessageHandler(name, handler) {
  return {
    handle: msg => {
      if (msg instanceof NamedMessage && msg.name == name) handler();
    }
  };
}

/***/ }),

/***/ "./src/app/edit/sector.ts":
/*!********************************!*\
  !*** ./src/app/edit/sector.ts ***!
  \********************************/
/*! exports provided: SectorEnt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorEnt", function() { return SectorEnt; });
/* harmony import */ var _build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/board/mutations/internal */ "./src/build/board/mutations/internal.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _editutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editutils */ "./src/app/edit/editutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _tools_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools/selection */ "./src/app/edit/tools/selection.ts");









var resetPanrepeat = new _messages__WEBPACK_IMPORTED_MODULE_7__["PanRepeat"](0, 0, 0, 0, true);
class SectorEnt extends _apis_handler__WEBPACK_IMPORTED_MODULE_5__["MessageHandlerReflective"] {
  constructor(sectorEnt, ctx, originz, origin, valid) {
    if (originz === void 0) {
      originz = 0;
    }

    if (origin === void 0) {
      origin = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].create();
    }

    if (valid === void 0) {
      valid = true;
    }

    super();
    this.sectorEnt = sectorEnt;
    this.ctx = ctx;
    this.originz = originz;
    this.origin = origin;
    this.valid = valid;
  }

  StartMove(msg) {
    var [x, y] = this.ctx.view.target().coords; // let sec = ctx.board.sectors[this.sectorId];
    // let slope = createSlopeCalculator(sec, ctx.board.walls);
    // this.originz = slope(x, y, this.type == HitType.CEILING ? sec.ceilingheinum : sec.floorheinum) + sectorZ(ctx.board, this.sectorId, this.type)) / ZSCALE;

    this.originz = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["sectorZ"])(this.ctx.board(), this.sectorEnt) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].set(this.origin, x, y);
  }

  Move(msg) {
    if (this.ctx.state.get(_tools_selection__WEBPACK_IMPORTED_MODULE_8__["MOVE_VERTICAL"])) {
      var _ent = this.ctx.view.target().entity;
      var z = _ent != null && _ent.isSector() && _ent.id != this.sectorEnt.id ? Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["sectorZ"])(this.ctx.board(), _ent) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"] : this.ctx.gridController.snap(this.originz + msg.dz);
      if (Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["setSectorZ"])(this.ctx.board(), this.sectorEnt, z * _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"])) Object(_editutils__WEBPACK_IMPORTED_MODULE_6__["invalidateSectorAndWalls"])(this.sectorEnt.id, this.ctx.board(), this.ctx.bus);
    }
  }

  Rotate(msg) {
    var board = this.ctx.board();
    var h = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["sectorHeinum"])(board, this.sectorEnt);
    Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["setSectorHeinum"])(board, this.sectorEnt, h + msg.da);
    Object(_editutils__WEBPACK_IMPORTED_MODULE_6__["invalidateSectorAndWalls"])(this.sectorEnt.id, board, this.ctx.bus);
  }

  Highlight(msg) {
    msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["tuple"])(this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING ? 0 : 1, this.sectorEnt.id));
  }

  SetPicnum(msg) {
    if (Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["setSectorPicnum"])(this.ctx.board(), this.sectorEnt, msg.picnum)) this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](this.sectorEnt));
  }

  Shade(msg) {
    var sector = this.ctx.board().sectors[this.sectorEnt.id];
    var shade = this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING ? sector.ceilingshade : sector.floorshade;
    if (msg.absolute && msg.value == shade) return;

    if (msg.absolute) {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) sector.ceilingshade = msg.value;else sector.floorshade = msg.value;
    } else {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) sector.ceilingshade += msg.value;else sector.floorshade += msg.value;
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](this.sectorEnt));
  }

  ResetPanRepeat(msg) {
    this.PanRepeat(resetPanrepeat);
  }

  PanRepeat(msg) {
    var sector = this.ctx.board().sectors[this.sectorEnt.id];

    if (msg.absolute) {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) {
        if (sector.ceilingxpanning == msg.xpan && sector.ceilingypanning == msg.ypan) return;
        sector.ceilingxpanning = msg.xpan;
        sector.ceilingypanning = msg.ypan;
      } else {
        if (sector.floorxpanning == msg.xpan && sector.floorypanning == msg.ypan) return;
        sector.floorxpanning = msg.xpan;
        sector.floorypanning = msg.ypan;
      }
    } else {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) {
        sector.ceilingxpanning += msg.xpan;
        sector.ceilingypanning += msg.ypan;
      } else {
        sector.floorxpanning += msg.xpan;
        sector.floorypanning += msg.ypan;
      }
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](this.sectorEnt));
  }

  Palette(msg) {
    var sector = this.ctx.board().sectors[this.sectorEnt.id];

    if (msg.absolute) {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) {
        if (msg.value == sector.ceilingpal) return;
        sector.ceilingpal = msg.value;
      } else {
        if (msg.value == sector.floorpal) return;
        sector.floorpal = msg.value;
      }
    } else {
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) {
        sector.ceilingpal = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["cyclic"])(sector.ceilingpal + msg.value, msg.max);
      } else {
        sector.floorpal = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["cyclic"])(sector.floorpal + msg.value, msg.max);
      }
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](this.sectorEnt));
  }

  SetSectorCstat(msg) {
    var sector = this.ctx.board().sectors[this.sectorEnt.id];
    var stat = this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING ? sector.ceilingstat[msg.name] : sector.floorstat[msg.name];

    if (msg.toggle) {
      var nstat = stat ? 0 : 1;
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) sector.ceilingstat[msg.name] = nstat;else sector.floorstat[msg.name] = nstat;
    } else {
      if (stat == msg.value) return;
      if (this.sectorEnt.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].CEILING) sector.ceilingstat[msg.name] = msg.value;else sector.floorstat[msg.name] = msg.value;
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](this.sectorEnt));
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'delete':
        Object(_build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__["deleteSector"])(this.ctx.board(), this.sectorEnt.id, this.ctx.refs);
        this.ctx.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_7__["COMMIT"]);
        this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](null));
        return;
    }
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.valid = false;
  }

  handle(msg) {
    if (this.valid) super.handle(msg);
  }

}

/***/ }),

/***/ "./src/app/edit/sprite.ts":
/*!********************************!*\
  !*** ./src/app/edit/sprite.ts ***!
  \********************************/
/*! exports provided: SpriteEnt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteEnt", function() { return SpriteEnt; });
/* harmony import */ var _build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/board/mutations/internal */ "./src/build/board/mutations/internal.ts");
/* harmony import */ var _build_board_mutations_sprites__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/board/mutations/sprites */ "./src/build/board/mutations/sprites.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _tools_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools/selection */ "./src/app/edit/tools/selection.ts");









class SpriteEnt extends _apis_handler__WEBPACK_IMPORTED_MODULE_6__["MessageHandlerReflective"] {
  constructor(spriteId, ctx, origin, origAng, valid) {
    if (origin === void 0) {
      origin = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
    }

    if (origAng === void 0) {
      origAng = 0;
    }

    if (valid === void 0) {
      valid = true;
    }

    super();
    this.spriteId = spriteId;
    this.ctx = ctx;
    this.origin = origin;
    this.origAng = origAng;
    this.valid = valid;
  }

  StartMove(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];

    if (this.ctx.state.get(_tools_selection__WEBPACK_IMPORTED_MODULE_8__["MOVE_COPY"])) {
      var newSprite = this.ctx.api.cloneSprite(spr);
      this.spriteId = Object(_build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__["addSprite"])(board, newSprite);
    }

    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(this.origin, spr.x, spr.z / _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"], spr.y);
    this.origAng = spr.ang;
  }

  Move(msg) {
    var board = this.ctx.board();
    var x = this.ctx.gridController.snap(this.origin[0] + msg.dx);
    var y = this.ctx.gridController.snap(this.origin[2] + msg.dy);
    var z = this.ctx.gridController.snap(this.origin[1] + msg.dz) * _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"];

    if (Object(_build_board_mutations_sprites__WEBPACK_IMPORTED_MODULE_1__["moveSpriteX"])(board, this.spriteId, x, y, z, this.ctx.gridController)) {
      this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
    }
  }

  Rotate(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];
    spr.ang = this.ctx.gridController.snap(spr.ang + msg.da + Math.sign(msg.da));
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  Highlight(msg) {
    msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["tuple"])(4, this.spriteId));
  }

  SetPicnum(msg) {
    var board = this.ctx.board();
    var sprite = board.sprites[this.spriteId];
    sprite.picnum = msg.picnum;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  Shade(msg) {
    var board = this.ctx.board();
    var sprite = board.sprites[this.spriteId];
    var shade = sprite.shade;
    if (msg.absolute && shade == msg.value) return;
    if (msg.absolute) sprite.shade = msg.value;else sprite.shade += msg.value;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  PanRepeat(msg) {
    var board = this.ctx.board();
    var sprite = board.sprites[this.spriteId];

    if (msg.absolute) {
      if (sprite.xoffset == msg.xpan && sprite.yoffset == msg.ypan && sprite.xrepeat == msg.xrepeat && sprite.yrepeat == msg.yrepeat) return;
      sprite.xoffset = msg.xpan;
      sprite.yoffset = msg.ypan;
      sprite.xrepeat = msg.xrepeat;
      sprite.yrepeat = msg.yrepeat;
    } else {
      sprite.xoffset += msg.xpan;
      sprite.yoffset += msg.ypan;
      sprite.xrepeat += msg.xrepeat;
      sprite.yrepeat += msg.yrepeat;
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  Palette(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];

    if (msg.absolute) {
      if (msg.value == spr.pal) return;
      spr.pal = msg.value;
    } else {
      spr.pal = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["cyclic"])(spr.pal + msg.value, msg.max);
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  SpriteMode(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];
    spr.cstat.type = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["cyclic"])(spr.cstat.type + 1, 3);
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  Flip(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];
    var flip = spr.cstat.xflip + spr.cstat.yflip * 2;
    var nflip = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["cyclic"])(flip + 1, 4);
    spr.cstat.xflip = nflip & 1;
    spr.cstat.yflip = (nflip & 2) >> 1;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  NamedMessage(msg) {
    var board = this.ctx.board();

    switch (msg.name) {
      case 'delete':
        Object(_build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__["deleteSprite"])(board, this.spriteId);
        this.ctx.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_7__["COMMIT"]);
        this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](null));
        return;
    }
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.valid = false;
  }

  SetSpriteCstat(msg) {
    var board = this.ctx.board();
    var spr = board.sprites[this.spriteId];
    var stat = spr.cstat[msg.name];
    spr.cstat[msg.name] = stat ? 0 : 1;
    this.ctx.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_7__["COMMIT"]);
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_7__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](this.spriteId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE)));
  }

  handle(msg) {
    if (this.valid) super.handle(msg);
  }

}

/***/ }),

/***/ "./src/app/edit/tools/drawsector.ts":
/*!******************************************!*\
  !*** ./src/app/edit/tools/drawsector.ts ***!
  \******************************************/
/*! exports provided: DrawSectorModule, DrawSector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawSectorModule", function() { return DrawSectorModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawSector", function() { return DrawSector; });
/* harmony import */ var _build_board_distances__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/distances */ "./src/build/board/distances.ts");
/* harmony import */ var _build_board_mutations_ceatesector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/mutations/ceatesector */ "./src/build/board/mutations/ceatesector.ts");
/* harmony import */ var _build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/board/mutations/sectors */ "./src/build/board/mutations/sectors.ts");
/* harmony import */ var _build_board_mutations_splitsector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../build/board/mutations/splitsector */ "./src/build/board/mutations/splitsector.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _modules_geometry_builders_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../modules/geometry/builders/common */ "./src/app/modules/geometry/builders/common.ts");
/* harmony import */ var _modules_geometry_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../modules/geometry/common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../modules/gl/buffers */ "./src/app/modules/gl/buffers.ts");
/* harmony import */ var _editutils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../editutils */ "./src/app/edit/editutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _toolsbus__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./toolsbus */ "./src/app/edit/tools/toolsbus.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





















class Contour {
  constructor(factory, art, firstPoint, contour, contourPoints, length, renderable) {
    if (firstPoint === void 0) {
      firstPoint = true;
    }

    if (contour === void 0) {
      contour = factory.wireframe('utils');
    }

    if (contourPoints === void 0) {
      contourPoints = factory.pointSprite('utils');
    }

    if (length === void 0) {
      length = factory.pointSprite('utils');
    }

    if (renderable === void 0) {
      renderable = new _apis_renderable__WEBPACK_IMPORTED_MODULE_12__["Renderables"]([contour, contourPoints, length]);
    }

    this.points = [];
    this.size = 0;
    this.z = 0;
    this.art = art;
    this.contour = contour;
    this.contourPoints = contourPoints;
    this.length = length;
    this.renderable = renderable;
    if (firstPoint) this.pushPoint(0, 0);
  }

  setZ(z) {
    this.z = z;
  }

  getZ() {
    return this.z;
  }

  pushPoint(x, y) {
    this.points[this.size++] = [x, y];
  }

  updateLastPoint(x, y) {
    this.updatePoint(this.size - 1, x, y);
  }

  popPoint() {
    this.size--;
  }

  clear() {
    this.size = 0;
  }

  updatePoint(idx, x, y) {
    if (idx >= this.size) throw new Error('Invalid point id: ' + idx);
    var p = this.points[idx];
    p[0] = x;
    p[1] = y;
  }

  getRenderable() {
    this.updateRenderable();
    return this.renderable;
  }

  updateRenderable() {
    if (this.size == 0) return;
    this.updateContourPoints();
    this.updateContour();
    this.updateLength();
  }

  updateContourPoints() {
    this.contourPoints.needToRebuild();
    this.contourPoints.tex = this.art.get(-1);
    var builder = new _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_15__["PointSpritesBuilder"]();

    for (var i = 0; i < this.size; i++) {
      var p = this.points[i];
      builder.add(p[0], this.z, p[1]);
    }

    builder.build(this.contourPoints.buff, 2.5);
  }

  updateContour() {
    this.contour.needToRebuild();
    var buff = this.contour.buff;
    buff.deallocate();
    var size = this.size - 1;
    var builder = new _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_15__["LineBuilder"]();

    for (var i = 0; i < size; i++) {
      var p1 = this.points[i];
      var p2 = this.points[i + 1];
      builder.segment(p1[0], this.z, p1[1], p2[0], this.z, p2[1]);
    }

    builder.build(buff);
  }

  prepareLengthLabels() {
    var total = 0;
    var labels = [];

    for (var i = 0; i < this.size - 1; i++) {
      var p = this.points[i];
      var p1 = this.points[i + 1];
      var label = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["len2d"])(p[0] - p1[0], p[1] - p1[1])) + "";
      labels.push(label);
      total += label.length * 2 + 3;
    }

    return [total, labels];
  }

  updateLength() {
    this.length.needToRebuild();
    var buff = this.length.buff;
    buff.deallocate();
    if (this.size < 2) return;
    this.length.tex = this.art.get(-2);
    var size = this.size - 1;
    var [total, labels] = this.prepareLengthLabels();
    buff.allocate(total * 4, total * 6);
    var off = 0;

    for (var i = 0; i < size; i++) {
      var p = this.points[i];
      var p1 = this.points[i + 1];
      var label = labels[i];
      Object(_modules_geometry_builders_common__WEBPACK_IMPORTED_MODULE_13__["writeText"])(buff, off, label, 8, 8, p[0] + (p1[0] - p[0]) / 2, p[1] + (p1[1] - p[1]) / 2, this.z);
      off += label.length * 2 + 3;
    }
  }

}

function DrawSectorModule(_x) {
  return _DrawSectorModule.apply(this, arguments);
}

function _DrawSectorModule() {
  _DrawSectorModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_toolsbus__WEBPACK_IMPORTED_MODULE_18__["TOOLS_BUS"]);
        bus.connect(yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_8__["create"])(injector, DrawSector, _modules_geometry_common__WEBPACK_IMPORTED_MODULE_14__["BUILDERS_FACTORY"], _apis_app__WEBPACK_IMPORTED_MODULE_10__["ART"], _apis_app__WEBPACK_IMPORTED_MODULE_10__["ENGINE_API"], _apis_app__WEBPACK_IMPORTED_MODULE_10__["VIEW"], _apis_app__WEBPACK_IMPORTED_MODULE_10__["BOARD"], _apis_app__WEBPACK_IMPORTED_MODULE_10__["REFERENCE_TRACKER"], _apis_handler__WEBPACK_IMPORTED_MODULE_11__["BUS"]));
      });

      return function (_x3) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _DrawSectorModule.apply(this, arguments);
}

class DrawSector extends _toolsbus__WEBPACK_IMPORTED_MODULE_18__["DefaultTool"] {
  constructor(factory, art, api, view, board, refs, bus, contour) {
    if (contour === void 0) {
      contour = new Contour(factory, art);
    }

    super();
    this.points = new _utils_collections__WEBPACK_IMPORTED_MODULE_7__["Deck"]();
    this.pointer = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
    this.isRect = true;
    this.api = api;
    this.view = view;
    this.board = board;
    this.refs = refs;
    this.bus = bus;
    this.contour = contour;
  }

  update() {
    if (this.predrawUpdate()) return;
    var z = this.contour.getZ();
    var [x, y] = this.view.snapTarget().coords;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(this.pointer, x, y, z);

    if (this.isRect) {
      var fp = this.points.get(0);
      var dx = x - fp[0];
      var dy = y - fp[1];
      var p1 = this.points.get(1);
      var p2 = this.points.get(2);
      var p3 = this.points.get(3);
      p1[0] = fp[0] + dx;
      p2[0] = fp[0] + dx;
      p2[1] = fp[1] + dy;
      p3[1] = fp[1] + dy;
      this.contour.updatePoint(1, fp[0] + dx, fp[1]);
      this.contour.updatePoint(2, fp[0] + dx, fp[1] + dy);
      this.contour.updatePoint(3, fp[0], fp[1] + dy);
    } else {
      this.contour.updateLastPoint(x, y);
    }
  }

  predrawUpdate() {
    if (this.points.length() > 0) return false;
    var target = this.view.snapTarget();
    var board = this.board();

    if (target.entity == null) {
      var [x, y] = target.coords;
      var [w] = Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallPointDist"])(board, x, y);
      var z = w == -1 ? 0 : board.sectors[Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["sectorOfWall"])(board, w)].ceilingz;
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(this.pointer, x, y, z);
      this.contour.setZ(z / _build_utils__WEBPACK_IMPORTED_MODULE_5__["ZSCALE"]);
      this.contour.updateLastPoint(x, y);
    } else if (target.entity.isSector() || target.entity.isSprite()) {
      var [_x2, _y] = target.coords;

      var _z = this.getPointerZ(board, target);

      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(this.pointer, _x2, _y, _z);
      this.contour.setZ(_z / _build_utils__WEBPACK_IMPORTED_MODULE_5__["ZSCALE"]);
      this.contour.updateLastPoint(_x2, _y);
    }

    return true;
  }

  isSplitSector(x, y) {
    var sectorId = this.findContainingSector();
    if (sectorId == -1) return -1;
    var fp = this.points.get(0);
    var board = this.board();
    return Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["wallInSector"])(board, sectorId, fp[0], fp[1]) != -1 && Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["wallInSector"])(board, sectorId, x, y) != -1 ? sectorId : -1;
  }

  insertPoint(rect) {
    this.activate();
    if (this.points.length() == 0) this.isRect = rect;

    if (this.checkFinish()) {
      this.deactivate();
      return;
    }

    if (this.isRect) {
      for (var i = 0; i < 4; i++) {
        this.points.push([this.pointer[0], this.pointer[1]]);
        this.contour.pushPoint(this.pointer[0], this.pointer[1]);
      }
    } else {
      this.points.push([this.pointer[0], this.pointer[1]]);
      this.contour.pushPoint(this.pointer[0], this.pointer[1]);
    }
  }

  checkFinish() {
    if (this.points.length() == 0) return false;
    var splitSector = this.isSplitSector(this.pointer[0], this.pointer[1]);

    if (splitSector != -1) {
      this.splitSector(splitSector);
      return true;
    }

    var latsPoint = this.points.get(this.points.length() - 1);
    if (latsPoint[0] == this.pointer[0] && latsPoint[1] == this.pointer[1]) return false;
    var firstPoint = this.points.get(0);

    if (firstPoint[0] == this.pointer[0] && firstPoint[1] == this.pointer[1] || this.isRect) {
      this.createSector();
      return true;
    }

    return false;
  }

  popPoint() {
    if (this.points.length() == 0) return;

    if (this.isRect) {
      for (var i = 0; i < 4; i++) {
        this.points.pop();
        this.contour.popPoint();
      }
    } else {
      this.points.pop();
      this.contour.popPoint();
    }

    if (this, this.points.length() == 0) this.deactivate();
    this.contour.updateLastPoint(this.pointer[0], this.pointer[1]);
  }

  getPointerZ(board, target) {
    if (target.entity.isSector()) return target.coords[2];
    var sectorId = target.entity.isWall() ? Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["sectorOfWall"])(board, target.entity.id) : board.sprites[target.entity.id].sectnum;
    return Object(_editutils__WEBPACK_IMPORTED_MODULE_16__["getClosestSectorZ"])(board, sectorId, target.coords[0], target.coords[1], target.coords[2])[1];
  }

  findContainingSector() {
    var sectors = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["findContainingSectorMidPoints"])(this.board(), [...this.points, this.pointer]);
    return sectors.size == 1 ? sectors.values().next().value : -1;
  }

  createSector() {
    var sectorId = this.findContainingSector();
    var board = this.board();
    if (sectorId != -1) Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_2__["createInnerLoop"])(board, sectorId, this.points, this.refs, this.api);
    Object(_build_board_mutations_ceatesector__WEBPACK_IMPORTED_MODULE_1__["createNewSector"])(board, this.points, this.refs, this.api);
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_17__["COMMIT"]);
    this.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_17__["BoardInvalidate"](null));
    this.points.clear();
    this.contour.clear();
    this.contour.pushPoint(0, 0);
  }

  splitSector(sectorId) {
    Object(_build_board_mutations_splitsector__WEBPACK_IMPORTED_MODULE_3__["splitSector"])(this.board(), sectorId, Object(_utils_collections__WEBPACK_IMPORTED_MODULE_7__["wrap"])([...this.points, this.pointer]), this.refs, this.api);
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_17__["COMMIT"]);
    this.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_17__["BoardInvalidate"](null));
    this.points.clear();
    this.contour.clear();
    this.contour.pushPoint(0, 0);
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'draw_rect':
        this.insertPoint(true);
        return;

      case 'draw':
        this.insertPoint(false);
        return;

      case 'undo_draw':
        this.popPoint();
        return;
    }
  }

  Frame(msg) {
    this.update();
  }

  Render(msg) {
    msg.consumer(this.contour.getRenderable());
  }

}

/***/ }),

/***/ "./src/app/edit/tools/drawwall.ts":
/*!****************************************!*\
  !*** ./src/app/edit/tools/drawwall.ts ***!
  \****************************************/
/*! exports provided: DrawWallModule, DrawWall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawWallModule", function() { return DrawWallModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawWall", function() { return DrawWall; });
/* harmony import */ var _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/mutations/drawwall */ "./src/build/board/mutations/drawwall.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _modules_geometry_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../modules/geometry/common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../modules/gl/buffers */ "./src/app/modules/gl/buffers.ts");
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../handle */ "./src/app/edit/handle.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _toolsbus__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./toolsbus */ "./src/app/edit/tools/toolsbus.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }















class PortalModel {
  constructor(factory, contour, contourPoints, length, renderable) {
    if (contour === void 0) {
      contour = factory.wireframe('utils');
    }

    if (contourPoints === void 0) {
      contourPoints = factory.pointSprite('utils');
    }

    if (length === void 0) {
      length = factory.pointSprite('utils');
    }

    if (renderable === void 0) {
      renderable = new _apis_renderable__WEBPACK_IMPORTED_MODULE_7__["Renderables"]([contour, contourPoints, length]);
    }

    this.wallId = void 0;
    this.wallVec = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].create();
    this.wallNormal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].create();
    this.startPoint = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].create();
    this.type = void 0;
    this.points = [];
    this.pointer = void 0;
    this.slope = void 0;
    this.needToUpdate = true;
    this.lastMove = [0, 0, 0];
    this.lastDistance = 0;
    this.contour = contour;
    this.contourPoints = contourPoints;
    this.length = length;
    this.renderable = renderable;
  }

  getRenderable(distance) {
    if (this.lastDistance != distance) {
      this.lastDistance = distance;
      this.needToUpdate = true;
    }

    this.update();
    return this.renderable;
  }

  start(board, wallId, x, y, z) {
    this.pointer = [x, y, z];
    this.points = [];
    this.wallId = wallId;
    var wall = board.walls[wallId];
    var wall2 = board.walls[wall.point2];
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].set(this.wallVec, wall2.x - wall.x, wall2.y - wall.y);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].normalize(this.wallVec, this.wallVec);
    var [nx,, ny] = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["wallNormal"])(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), board, wallId);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].set(this.wallNormal, nx, ny);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].set(this.startPoint, wall.x, wall.y);
    var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["sectorOfWall"])(board, wallId);
    var sector = board.sectors[sectorId];

    if (wall.nextsector == -1) {
      this.type = _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].MID;
    } else {
      var nextsectorId = wall.nextsector;
      var nextsector = board.sectors[nextsectorId];
      var curslope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["createSlopeCalculator"])(board, sectorId);
      var nextslope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["createSlopeCalculator"])(board, nextsectorId);
      var cz = curslope(x, y, sector.ceilingheinum) + sector.ceilingz;
      var cnz = nextslope(x, y, nextsector.ceilingheinum) + nextsector.ceilingz;
      var fz = curslope(x, y, sector.floorheinum) + sector.floorz;
      var fnz = nextslope(x, y, nextsector.floorheinum) + nextsector.floorz;

      if (z >= fnz && z <= fz) {
        this.type = _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].DOWN;

        this.slope = (x, y) => (curslope(x, y, sector.floorheinum) + sector.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
      } else if (z <= cnz && z >= cz) {
        this.type = _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].UP;

        this.slope = (x, y) => (curslope(x, y, sector.ceilingheinum) + sector.ceilingz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
      } else throw new Error("Invalid point");
    }

    this.move(x, y, z);
    this.addPoint();
  }

  buildHull() {
    return Object(_build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["buildHull"])([...this.points, this.pointer], (x, y) => this.project(x, y));
  }

  stop(board, art, refs, api, dist) {
    Object(_build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["drawWall"])(board, this.wallId, this.type, this.buildHull(), art, refs, api, dist);
  }

  project(x, y) {
    var t = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].fromValues(x, y);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].sub(t, t, this.startPoint);
    var off = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].dot(this.wallVec, t);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].copy(t, this.wallVec);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].scale(t, t, off);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].add(t, t, this.startPoint);
    return [t[0], t[1], off];
  }

  move(x, y, z) {
    var [xp, yp, _] = this.project(x, y);
    if (this.needToMove(xp, yp, z)) return;
    this.pointer[0] = xp;
    this.pointer[1] = yp;
    this.pointer[2] = z / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    this.needToUpdate = true;
    this.updateLastMove(xp, yp, z);
  }

  needToMove(x, y, z) {
    return this.lastMove[0] == x && this.lastMove[1] == y && this.lastMove[2] == z;
  }

  updateLastMove(x, y, z) {
    this.lastMove[0] = x;
    this.lastMove[1] = y;
    this.lastMove[2] = z;
  }

  addPoint() {
    this.points.push(this.pointer);
    this.pointer = [...this.pointer];
    this.needToUpdate = true;
  }

  popPoint() {
    this.points.pop();
    this.needToUpdate = true;
  }

  hasPoints() {
    return this.points.length != 0;
  }

  onLastPoint() {
    if (this.points.length == 0) return false;
    var lastPoint = this.points[this.points.length - 1];
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].exactEquals(lastPoint, this.pointer);
  }

  update() {
    if (!this.needToUpdate) return;
    this.updateContour();
    this.updateContourPoints();
    this.needToUpdate = false;
  }

  updateContourPoints() {}

  updateContour() {
    this.contour.needToRebuild();
    var hull = this.buildHull();
    var line = new _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_9__["LineBuilder"]();
    if (this.type == _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].DOWN) this.buildNonMid(line, hull, true);else if (this.type == _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].UP) this.buildNonMid(line, hull, false);else if (this.type == _build_board_mutations_drawwall__WEBPACK_IMPORTED_MODULE_0__["PortalType"].MID) this.buildMid(line, hull); // for (const [p1, p2] of loopPairs([...this.points, this.pointer])) line.segment(p1[0], p1[2], p1[1], p2[0], p2[2], p2[1])

    line.build(this.contour.buff);
  }

  buildMid(line, hull) {
    var last = hull[hull.length - 1];
    var first = hull[0];
    this.addSegment(line, last.x, last.zdown, last.y, last.x, last.zup, last.y);
    this.addSegment(line, first.x, first.zdown, first.y, first.x, first.zup, first.y);

    for (var i = 0; i < hull.length - 1; i++) {
      var p1 = hull[i];
      var p2 = hull[i + 1];
      this.addSegment(line, p1.x, p1.zup, p1.y, p1.x, p1.zup + p1.zupoff, p1.y);
      this.addSegment(line, p1.x, p1.zdown, p1.y, p1.x, p1.zdown + p1.zdownoff, p1.y);
      this.addSegment(line, p1.x, p1.zup + p1.zupoff, p1.y, p2.x, p2.zup, p2.y);
      this.addSegment(line, p1.x, p1.zdown + p1.zdownoff, p1.y, p2.x, p2.zdown, p2.y);
    }
  }

  buildNonMid(line, hull, down) {
    var last = hull[hull.length - 1];
    var first = hull[0];
    var lastz = this.slope(last.x, last.y);
    var firstz = this.slope(first.x, first.y);
    this.addSegment(line, last.x, lastz, last.y, last.x, down ? last.zup : last.zdown, last.y);
    this.addSegment(line, first.x, firstz, first.y, first.x, down ? first.zup : first.zdown, first.y);
    this.addSegment(line, last.x, lastz, last.y, first.x, firstz, first.y);

    for (var i = 0; i < hull.length - 1; i++) {
      var p1 = hull[i];
      var p2 = hull[i + 1];
      this.addSegment(line, p1.x, down ? p1.zup : p1.zdown, p1.y, p1.x, down ? p1.zup + p1.zupoff : p1.zdown + p1.zdownoff, p1.y);
      this.addSegment(line, p1.x, down ? p1.zup + p1.zupoff : p1.zdown + p1.zdownoff, p1.y, p2.x, down ? p2.zup : p2.zdown, p2.y);
    }
  }

  addSegment(line, x1, z1, y1, x2, z2, y2) {
    var dx = this.lastDistance * this.wallNormal[0];
    var dy = this.lastDistance * this.wallNormal[1];
    line.segment(x1, z1, y1, x2, z2, y2);
    line.segment(x1 + dx, z1, y1 + dy, x2 + dx, z2, y2 + dy);
    line.segment(x1 + dx, z1, y1 + dy, x1, z1, y1);
    line.segment(x2 + dx, z2, y2 + dy, x2, z2, y2);
  }

}

function DrawWallModule(_x) {
  return _DrawWallModule.apply(this, arguments);
}

function _DrawWallModule() {
  _DrawWallModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var [bus, toolsBus, api, builders, view, board, refs, art, grid] = yield Promise.all([injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]), injector.getInstance(_toolsbus__WEBPACK_IMPORTED_MODULE_12__["TOOLS_BUS"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["ENGINE_API"]), injector.getInstance(_modules_geometry_common__WEBPACK_IMPORTED_MODULE_8__["BUILDERS_FACTORY"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["VIEW"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["REFERENCE_TRACKER"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["ART"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["GRID"])]);
        toolsBus.connect(new DrawWall(builders, api, view, board, refs, bus, art, grid));
      });

      return function (_x3) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _DrawWallModule.apply(this, arguments);
}

class DrawWall extends _toolsbus__WEBPACK_IMPORTED_MODULE_12__["DefaultTool"] {
  constructor(factory, api, view, board, refs, bus, art, grid, portal) {
    if (portal === void 0) {
      portal = new PortalModel(factory);
    }

    super();
    this.wallId = -1;
    this.movingHandle = new _handle__WEBPACK_IMPORTED_MODULE_10__["MovingHandle"]();
    this._wallNormal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
    this._start = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
    this._dir = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
    this.api = api;
    this.view = view;
    this.board = board;
    this.refs = refs;
    this.bus = bus;
    this.art = art;
    this.grid = grid;
    this.portal = portal;
  }

  start() {
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    this.activate();
    var [x, y, z] = target.coords;
    this.portal.start(this.board(), target.entity.id, x, y, z);
    this.wallId = target.entity.id;
  }

  stop() {
    this.portal.stop(this.board(), this.art, this.refs, this.api, this.getDistance());
    this.wallId = -1;
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_11__["COMMIT"]);
    this.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_11__["BoardInvalidate"](null));
    this.movingHandle.stop();
    this.deactivate();
  }

  abort() {
    this.wallId = -1;
    this.movingHandle.stop();
    this.deactivate();
  }

  insertPoint() {
    if (this.wallId == -1) this.start();else if (this.movingHandle.isActive()) this.stop();else if (this.portal.onLastPoint()) this.pushPortal();else this.portal.addPoint();
  }

  popPoint() {
    if (this.wallId == -1) return;else {
      this.portal.popPoint();
      if (!this.portal.hasPoints()) this.abort();
    }
  }

  pushPortal() {
    var target = this.view.snapTarget();
    this.movingHandle.start(Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), target.coords));
  }

  getDistance() {
    if (!this.movingHandle.isActive()) return 0;
    var dx = this.movingHandle.dx;
    var dy = this.movingHandle.dy;
    var [nx,, ny] = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["wallNormal"])(this._wallNormal, this.board(), this.wallId);
    return this.grid.snap(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["dot2d"])(nx, ny, dx, dy));
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'draw':
        this.insertPoint();
        return;

      case 'undo_draw':
        this.popPoint();
        return;
    }
  }

  Frame(msg) {
    if (this.wallId == -1) return;

    if (this.movingHandle.isActive()) {
      var {
        start,
        dir
      } = this.view.dir();
      this.movingHandle.update(false, false, Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(this._start, start), Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(this._dir, dir));
    } else {
      var target = this.view.snapTarget();
      var [_x2, _y, z] = target.coords;
      this.portal.move(_x2, _y, z);
    }
  }

  Render(msg) {
    if (this.wallId == -1) return;
    msg.consumer(this.portal.getRenderable(this.getDistance()));
  }

}

/***/ }),

/***/ "./src/app/edit/tools/joinsectors.ts":
/*!*******************************************!*\
  !*** ./src/app/edit/tools/joinsectors.ts ***!
  \*******************************************/
/*! exports provided: JoinSectorsModule, JoinSectors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JoinSectorsModule", function() { return JoinSectorsModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JoinSectors", function() { return JoinSectors; });
/* harmony import */ var _build_board_mutations_joinsectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/mutations/joinsectors */ "./src/build/board/mutations/joinsectors.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _toolsbus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toolsbus */ "./src/app/edit/tools/toolsbus.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }







function JoinSectorsModule(module) {
  module.execute( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      var bus = yield injector.getInstance(_toolsbus__WEBPACK_IMPORTED_MODULE_5__["TOOLS_BUS"]);
      bus.connect(yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_1__["create"])(injector, JoinSectors, _apis_handler__WEBPACK_IMPORTED_MODULE_3__["BUS"], _apis_app__WEBPACK_IMPORTED_MODULE_2__["VIEW"], _apis_app__WEBPACK_IMPORTED_MODULE_2__["BOARD"], _apis_app__WEBPACK_IMPORTED_MODULE_2__["REFERENCE_TRACKER"]));
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
}
class JoinSectors extends _toolsbus__WEBPACK_IMPORTED_MODULE_5__["DefaultTool"] {
  constructor(bus, view, board, refs) {
    super();
    this.sectorId1 = -1;
    this.sectorId2 = -1;
    this.bus = bus;
    this.view = view;
    this.board = board;
    this.refs = refs;
  }

  join() {
    var target = this.view.target();
    if (target.entity == null || !target.entity.isSector()) return;
    var sectorId = target.entity.id;

    if (this.sectorId1 == -1) {
      this.activate();
      this.sectorId1 = sectorId;
    } else if (this.sectorId2 == -1) {
      this.sectorId2 = sectorId;
    }

    if (this.sectorId1 != -1 && this.sectorId2 != -1) {
      var result = Object(_build_board_mutations_joinsectors__WEBPACK_IMPORTED_MODULE_0__["joinSectors"])(this.board(), this.sectorId1, this.sectorId2, this.refs);

      if (result == 0) {
        this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_4__["COMMIT"]);
        this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_4__["INVALIDATE_ALL"]);
      }

      this.sectorId1 = -1;
      this.sectorId2 = -1;
      this.deactivate();
    }
  }

  NamedMessage(msg) {
    if (msg.name == 'join_sectors') this.join();
  }

}

/***/ }),

/***/ "./src/app/edit/tools/pushwall.ts":
/*!****************************************!*\
  !*** ./src/app/edit/tools/pushwall.ts ***!
  \****************************************/
/*! exports provided: PushWallModule, PushWall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PushWallModule", function() { return PushWallModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PushWall", function() { return PushWall; });
/* harmony import */ var _build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/mutations/walls */ "./src/build/board/mutations/walls.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _modules_geometry_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../modules/geometry/common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../modules/gl/buffers */ "./src/app/modules/gl/buffers.ts");
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../handle */ "./src/app/edit/handle.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _toolsbus__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./toolsbus */ "./src/app/edit/tools/toolsbus.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }













var wallNormal_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
var wallNormal1_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
var target_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
var start_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
var dir_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
function PushWallModule(_x) {
  return _PushWallModule.apply(this, arguments);
}

function _PushWallModule() {
  _PushWallModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var [bus, toolsBus, api, builders, view, art, board, refs, grid] = yield Promise.all([injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]), injector.getInstance(_toolsbus__WEBPACK_IMPORTED_MODULE_11__["TOOLS_BUS"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["ENGINE_API"]), injector.getInstance(_modules_geometry_common__WEBPACK_IMPORTED_MODULE_7__["BUILDERS_FACTORY"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["VIEW"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["ART"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["REFERENCE_TRACKER"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["GRID"])]);
        toolsBus.connect(new PushWall(builders, api, view, art, board, refs, bus, grid));
      });

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _PushWallModule.apply(this, arguments);
}

class PushWall extends _toolsbus__WEBPACK_IMPORTED_MODULE_11__["DefaultTool"] {
  constructor(builders, api, view, art, board, refs, bus, grid, wireframe) {
    if (wireframe === void 0) {
      wireframe = builders.wireframe('utils');
    }

    super();
    this.wallId = -1;
    this.copy = false;
    this.movingHandle = new _handle__WEBPACK_IMPORTED_MODULE_9__["MovingHandle"]();
    this.api = api;
    this.view = view;
    this.art = art;
    this.board = board;
    this.refs = refs;
    this.bus = bus;
    this.grid = grid;
    this.wireframe = wireframe;
  }

  start(copy) {
    this.activate();
    this.copy = copy;
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    this.wallId = target.entity.id;
    this.movingHandle.start(Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(target_, target.coords));
  }

  abort() {
    this.deactivate();
    this.wallId = -1;
    this.movingHandle.stop();
  }

  stop() {
    Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_0__["pushWall"])(this.board(), this.wallId, this.getDistance(), this.art, this.copy, this.refs, this.api);
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_10__["COMMIT"]);
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_10__["INVALIDATE_ALL"]);
    this.abort();
  }

  getDistance() {
    var dx = this.movingHandle.dx;
    var dy = this.movingHandle.dy;
    var [nx,, ny] = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["wallNormal"])(wallNormal1_, this.board(), this.wallId);
    return this.grid.snap(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["dot2d"])(nx, ny, dx, dy));
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'push_wall':
        this.movingHandle.isActive() ? this.stop() : this.start(false);
        return;

      case 'push_wall_copy':
        this.movingHandle.isActive() ? this.stop() : this.start(true);
        return;

      case 'push_wall_stop':
        this.abort();
        return;
    }
  }

  Frame(msg) {
    if (this.movingHandle.isActive()) {
      var {
        start,
        dir
      } = this.view.dir();
      this.movingHandle.update(false, false, Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(start_, start), Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["build2gl"])(dir_, dir));
    }
  }

  Render(msg) {
    if (!this.movingHandle.isActive()) return;
    this.updateWireframe();
    msg.consumer(this.wireframe);
  }

  updateWireframe() {
    var board = this.board();
    var normal = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["wallNormal"])(wallNormal_, board, this.wallId);
    var [nx,, ny] = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].scale(normal, normal, this.getDistance());
    var wall = board.walls[this.wallId];
    var wall2 = board.walls[wall.point2];
    var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["sectorOfWall"])(board, this.wallId);
    var sector = board.sectors[sectorId];
    var x1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["int"])(wall.x + nx),
        y1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["int"])(wall.y + ny);
    var x2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["int"])(wall2.x + nx),
        y2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_4__["int"])(wall2.y + ny);
    var slopeCalc = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["createSlopeCalculator"])(board, sectorId);
    var z1 = (slopeCalc(x1, y1, sector.floorheinum) + sector.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z2 = (slopeCalc(x1, y1, sector.ceilingheinum) + sector.ceilingz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z3 = (slopeCalc(x2, y2, sector.ceilingheinum) + sector.ceilingz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z4 = (slopeCalc(x2, y2, sector.floorheinum) + sector.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z5 = (slopeCalc(wall.x, wall.y, sector.floorheinum) + sector.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z6 = (slopeCalc(wall.x, wall.y, sector.ceilingheinum) + sector.ceilingz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z7 = (slopeCalc(wall2.x, wall2.y, sector.ceilingheinum) + sector.ceilingz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var z8 = (slopeCalc(wall2.x, wall2.y, sector.floorheinum) + sector.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
    var line = new _modules_gl_buffers__WEBPACK_IMPORTED_MODULE_8__["LineBuilder"]();
    this.wireframe.needToRebuild();
    line.rect(x1, z1, y1, x1, z2, y1, x2, z3, y2, x2, z4, y2);
    line.segment(x1, z1, y1, wall.x, z5, wall.y);
    line.segment(x1, z2, y1, wall.x, z6, wall.y);
    line.segment(x2, z3, y2, wall2.x, z7, wall2.y);
    line.segment(x2, z4, y2, wall2.x, z8, wall2.y);
    line.build(this.wireframe.buff);
  }

}

/***/ }),

/***/ "./src/app/edit/tools/selection.ts":
/*!*****************************************!*\
  !*** ./src/app/edit/tools/selection.ts ***!
  \*****************************************/
/*! exports provided: PICNUM_SELECTOR, MOVE_COPY, MOVE_VERTICAL, MOVE_PARALLEL, getFromHitscan, SelectionModule, Selection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PICNUM_SELECTOR", function() { return PICNUM_SELECTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOVE_COPY", function() { return MOVE_COPY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOVE_VERTICAL", function() { return MOVE_VERTICAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOVE_PARALLEL", function() { return MOVE_PARALLEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFromHitscan", function() { return getFromHitscan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionModule", function() { return SelectionModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _build_board_loops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/loops */ "./src/build/board/loops.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _modules_geometry_cache__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../modules/geometry/cache */ "./src/app/modules/geometry/cache.ts");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../context */ "./src/app/edit/context.ts");
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../handle */ "./src/app/edit/handle.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sector */ "./src/app/edit/sector.ts");
/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../sprite */ "./src/app/edit/sprite.ts");
/* harmony import */ var _wall__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../wall */ "./src/app/edit/wall.ts");
/* harmony import */ var _wallsegment__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../wallsegment */ "./src/app/edit/wallsegment.ts");
/* harmony import */ var _toolsbus__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./toolsbus */ "./src/app/edit/tools/toolsbus.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




















var PICNUM_SELECTOR = new _utils_injector__WEBPACK_IMPORTED_MODULE_6__["Dependency"]('PicNumSelector');
var handle = new _handle__WEBPACK_IMPORTED_MODULE_12__["MovingHandle"]();
var MOVE = new _messages__WEBPACK_IMPORTED_MODULE_13__["Move"](0, 0, 0);
var START_MOVE = new _messages__WEBPACK_IMPORTED_MODULE_13__["StartMove"]();
var END_MOVE = new _messages__WEBPACK_IMPORTED_MODULE_13__["EndMove"]();
var SET_PICNUM = new _messages__WEBPACK_IMPORTED_MODULE_13__["SetPicnum"](-1);
var HIGHLIGHT = new _messages__WEBPACK_IMPORTED_MODULE_13__["Highlight"]();
var MOVE_STATE = 'move';
var LOOP_STATE = 'select_loop_mod';
var FULL_LOOP_STATE = 'select_full_loop_mod';
var MOVE_COPY = 'move.copy';
var MOVE_VERTICAL = 'move.vertical';
var MOVE_PARALLEL = 'move.parallel';
var clipboardPicnum = new _messages__WEBPACK_IMPORTED_MODULE_13__["SetPicnum"](0);
var clipboardShade = new _messages__WEBPACK_IMPORTED_MODULE_13__["Shade"](0, true);
var list = new _utils_collections__WEBPACK_IMPORTED_MODULE_5__["Deck"]();
function getFromHitscan(factory) {
  var target = factory.ctx.view.snapTarget();
  list.clear();
  if (target.entity == null) return list;
  var fullLoop = factory.ctx.state.get(FULL_LOOP_STATE) ? _build_board_loops__WEBPACK_IMPORTED_MODULE_0__["innerWalls"] : factory.ctx.state.get(LOOP_STATE) ? _build_board_loops__WEBPACK_IMPORTED_MODULE_0__["loopWalls"] : null;
  var board = factory.ctx.board();

  if (target.entity.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].WALL_POINT) {
    var w = target.entity.id;
    list.push(fullLoop ? factory.wallSegment(fullLoop(board, w)) : factory.wall(w));
  } else if (target.entity.isWall()) {
    wallSegment(fullLoop, factory, target.entity.id, target.entity.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].LOWER_WALL);
  } else if (target.entity.isSector()) {
    sector(fullLoop, target, factory);
  } else if (target.entity.isSprite()) {
    list.push(factory.sprite(target.entity.id));
  }

  return list;
}

function sector(fullLoop, target, factory) {
  var board = factory.ctx.board();

  if (fullLoop) {
    var firstWall = board.sectors[target.entity.id].wallptr;
    list.push(factory.wallSegment(fullLoop(board, firstWall)));
    var type = target.entity.type == _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].CEILING ? _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].FLOOR : _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].CEILING;
    list.push(factory.sector(new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](target.entity.id, type)));
  }

  list.push(factory.sector(target.entity.clone()));
}

function wallSegment(fullLoop, factory, w, bottom) {
  var board = factory.ctx.board();

  if (fullLoop) {
    var loop = fullLoop(board, w);
    list.push(factory.wallSegment(loop, loop, bottom));
  } else {
    var w1 = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["nextwall"])(board, w);
    list.push(factory.wallSegment([w, w1], [w], bottom));
  }
}

var target_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
var start_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
var dir_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
function SelectionModule(_x) {
  return _SelectionModule.apply(this, arguments);
}

function _SelectionModule() {
  _SelectionModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_toolsbus__WEBPACK_IMPORTED_MODULE_18__["TOOLS_BUS"]);
        bus.connect(yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_6__["create"])(injector, Selection, PICNUM_SELECTOR, _modules_geometry_cache__WEBPACK_IMPORTED_MODULE_10__["RENDRABLES_CACHE"], _context__WEBPACK_IMPORTED_MODULE_11__["ENTITY_FACTORY"]));
      });

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _SelectionModule.apply(this, arguments);
}

class Selection extends _toolsbus__WEBPACK_IMPORTED_MODULE_18__["DefaultTool"] {
  constructor(picnumSelector, renderables, factory, ctx) {
    if (ctx === void 0) {
      ctx = factory.ctx;
    }

    super();
    this.selection = new _apis_handler__WEBPACK_IMPORTED_MODULE_9__["MessageHandlerList"]();
    this.highlighted = new _apis_handler__WEBPACK_IMPORTED_MODULE_9__["MessageHandlerList"]();
    this.valid = true;
    this.picnumSelector = picnumSelector;
    this.renderables = renderables;
    this.factory = factory;
    this.ctx = ctx;
    ctx.state.register(MOVE_STATE, false);
    ctx.state.register(MOVE_COPY, false);
    ctx.state.register(MOVE_VERTICAL, false);
    ctx.state.register(MOVE_PARALLEL, false);
    ctx.state.register(LOOP_STATE, false);
    ctx.state.register(FULL_LOOP_STATE, false);
  }

  Frame(msg) {
    if (!handle.isActive()) this.updateSelection();
    if (Object(_utils_collections__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(this.selection.list()) && Object(_utils_collections__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(this.highlighted.list())) return;

    if (this.activeMove()) {
      this.activate();
      this.updateHandle();

      try {
        this.updateMove();
      } catch (e) {
        this.valid = false;
        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_7__["error"])(e);
      }
    }
  }

  updateSelection() {
    var underCursor = getFromHitscan(this.factory);
    this.highlighted.list().clear().pushAll(underCursor.clone());
  }

  checkSelected(ent, s) {
    if (ent.isSector() && s instanceof _sector__WEBPACK_IMPORTED_MODULE_14__["SectorEnt"] && ent.id == s.sectorEnt.id && ent.type == s.sectorEnt.type) return true;
    if (ent.isSprite() && s instanceof _sprite__WEBPACK_IMPORTED_MODULE_15__["SpriteEnt"] && ent.id == s.spriteId) return true;

    if (ent.isWall()) {
      if (s instanceof _wall__WEBPACK_IMPORTED_MODULE_16__["WallEnt"] && ent.id == s.wallId) return true;
      if (s instanceof _wallsegment__WEBPACK_IMPORTED_MODULE_17__["WallSegmentsEnt"]) for (var w of s.highlighted) {
        if (w == ent.id) return true;
      }
    }

    return false;
  }

  selectedUnderCursor() {
    var snapTarget = this.ctx.view.snapTarget();
    if (snapTarget.entity == null) return false;
    var ent = snapTarget.entity;

    for (var s of this.selection.list()) {
      if (this.checkSelected(ent, s)) return true;
    }

    for (var _s of this.highlighted.list()) {
      if (this.checkSelected(ent, _s)) return true;
    }

    return false;
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'set_picnum':
        this.setTexture();
        return;

      case 'copy':
        this.copy();
        return;

      case 'paste_shade':
        this.handleSelected(clipboardShade);
        this.commit();
        return;

      case 'paste_picnum':
        this.handleSelected(clipboardPicnum);
        this.commit();
        return;

      case 'replace_selection':
        if (!handle.isActive()) this.selection.list().clear().pushAll(this.highlighted.list().clone());
        return;

      case 'add_selection':
        this.selection.list().pushAll(this.highlighted.list().clone());
        return;

      case 'clear_selection':
        this.selection.list().clear();
        return;

      default:
        this.handleSelected(msg);
    }
  }

  handleDefault(msg) {
    this.handleSelected(msg);
  }

  handleSelected(msg) {
    this.highlighted.handle(msg);
    this.selection.handle(msg);
  }

  commit() {
    this.ctx.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_13__["COMMIT"]);
  }

  cloneSelected() {
    var selected = this.highlighted.clone();
    selected.list().pushAll(this.selection.list());
    return selected;
  }

  isStartMove() {
    return !handle.isActive() && this.ctx.state.get(MOVE_STATE) && this.selectedUnderCursor();
  }

  activeMove() {
    var start = this.isStartMove();
    if (this.valid == false && start) this.valid = true;
    var move = handle.isActive() && this.ctx.state.get(MOVE_STATE);
    var end = handle.isActive() && !this.ctx.state.get(MOVE_STATE);
    return this.valid && (start || move || end);
  }

  updateHandle() {
    var vertical = this.ctx.state.get(MOVE_VERTICAL);
    var parallel = this.ctx.state.get(MOVE_PARALLEL);
    var {
      start,
      dir
    } = this.ctx.view.dir();
    handle.update(vertical, parallel, Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["build2gl"])(start_, start), Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["build2gl"])(dir_, dir));
  }

  updateMove() {
    if (this.isStartMove()) {
      handle.start(Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["build2gl"])(target_, this.ctx.view.target().coords));
      this.handleSelected(START_MOVE);
    } else if (!this.ctx.state.get(MOVE_STATE)) {
      handle.stop();
      this.handleSelected(END_MOVE);
      this.commit();
      this.deactivate();
      return;
    }

    if (Math.abs(MOVE.dx - handle.dx) >= this.ctx.gridController.getGridSize() / 2 || Math.abs(MOVE.dy - handle.dy) >= this.ctx.gridController.getGridSize() / 2 || Math.abs(MOVE.dz - handle.dz) >= this.ctx.gridController.getGridSize() / 2) {
      MOVE.dx = handle.dx;
      MOVE.dy = handle.dy;
      MOVE.dz = handle.dz;
      this.handleSelected(MOVE);
    }
  }

  setTexture() {
    var sel = this.cloneSelected();
    this.picnumSelector(picnum => {
      if (picnum == -1) return;
      SET_PICNUM.picnum = picnum;
      sel.handle(SET_PICNUM);
      this.commit();
    });
  }

  copy() {
    var target = this.ctx.view.target();
    var board = this.ctx.board();
    if (target.entity == null) return;

    switch (target.entity.type) {
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].CEILING:
        clipboardShade.value = board.sectors[target.entity.id].ceilingshade;
        clipboardPicnum.picnum = board.sectors[target.entity.id].ceilingpicnum;
        break;

      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].FLOOR:
        clipboardShade.value = board.sectors[target.entity.id].floorshade;
        clipboardPicnum.picnum = board.sectors[target.entity.id].floorpicnum;
        break;

      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].LOWER_WALL:
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].MID_WALL:
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].UPPER_WALL:
        clipboardShade.value = board.walls[target.entity.id].shade;
        clipboardPicnum.picnum = board.walls[target.entity.id].picnum;
        break;

      case _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].SPRITE:
        clipboardShade.value = board.sprites[target.entity.id].shade;
        clipboardPicnum.picnum = board.sprites[target.entity.id].picnum;
        break;
    }
  }

  Render(msg) {
    HIGHLIGHT.set.clear();
    this.handleSelected(HIGHLIGHT);

    for (var v of HIGHLIGHT.set.keys()) {
      var type = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["detuple0"])(v);
      var id = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["detuple1"])(v);
      var rs = this.renderables.helpers;

      switch (type) {
        case 0:
          msg.consumer(rs.sector(id).ceiling);
          break;

        case 1:
          msg.consumer(rs.sector(id).floor);
          break;

        case 2:
          msg.consumer(rs.wall(id));
          break;

        case 3:
          msg.consumer(rs.wallPoint(id));
          break;

        case 4:
          msg.consumer(rs.sprite(id));
          break;
      }
    }
  }

}

/***/ }),

/***/ "./src/app/edit/tools/toolsbus.ts":
/*!****************************************!*\
  !*** ./src/app/edit/tools/toolsbus.ts ***!
  \****************************************/
/*! exports provided: TOOLS_BUS, ToolsBusConstructor, DefaultTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLS_BUS", function() { return TOOLS_BUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolsBusConstructor", function() { return ToolsBusConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTool", function() { return DefaultTool; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var TOOLS_BUS = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]("ToolsBus");
function ToolsBusConstructor(_x) {
  return _ToolsBusConstructor.apply(this, arguments);
}

function _ToolsBusConstructor() {
  _ToolsBusConstructor = _asyncToGenerator(function* (injector) {
    var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]);
    var toolsBus = new ToolsMessageBus();
    bus.connect(toolsBus);
    return toolsBus;
  });
  return _ToolsBusConstructor.apply(this, arguments);
}

;
class DefaultTool extends _apis_handler__WEBPACK_IMPORTED_MODULE_2__["MessageHandlerReflective"] {
  constructor() {
    super(...arguments);
    this.activateH = void 0;
    this.deactivateH = void 0;
  }

  activateHandler(handler) {
    this.activateH = handler;
  }

  deactivateHandler(handler) {
    this.deactivateH = handler;
  }

  activate() {
    this.activateH(this);
  }

  deactivate() {
    this.deactivateH(this);
  }

}

class ToolsMessageBus {
  constructor() {
    this.tools = [];
    this.activeTool = null;
  }

  connect(tool) {
    if (this.tools.indexOf(tool) != -1) throw new Error("Tool " + tool + " already bound");
    this.tools.push(tool);
    tool.activateHandler(tool => this.activateTool(tool));
    tool.deactivateHandler(tool => this.deactivateTool(tool));
  }

  activateTool(tool) {
    if (this.activeTool != null && this.activeTool != tool) throw new Error('');
    this.activeTool = tool;
  }

  deactivateTool(tool) {
    if (this.activeTool != tool) throw new Error();
    this.activeTool = null;
  }

  handle(message) {
    if (this.activeTool != null) this.activeTool.handle(message);else Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["forEach"])(this.tools, t => t.handle(message));
  }

}

/***/ }),

/***/ "./src/app/edit/tools/utils.ts":
/*!*************************************!*\
  !*** ./src/app/edit/tools/utils.ts ***!
  \*************************************/
/*! exports provided: UtilsModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UtilsModule", function() { return UtilsModule; });
/* harmony import */ var _build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/mutations/internal */ "./src/build/board/mutations/internal.ts");
/* harmony import */ var _build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/mutations/sectors */ "./src/build/board/mutations/sectors.ts");
/* harmony import */ var _build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/board/mutations/walls */ "./src/build/board/mutations/walls.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_board_structs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../build/board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _editutils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../editutils */ "./src/app/edit/editutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./selection */ "./src/app/edit/tools/selection.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
















function UtilsModule(_x) {
  return _UtilsModule.apply(this, arguments);
}

function _UtilsModule() {
  _UtilsModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var [board, api, art, view, bus, refs, grid, pics] = yield Promise.all([injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["ENGINE_API"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["ART"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["VIEW"]), injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_11__["BUS"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["REFERENCE_TRACKER"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["GRID"]), injector.getInstance(_selection__WEBPACK_IMPORTED_MODULE_14__["PICNUM_SELECTOR"])]);
        bus.connect(new Utils(board, api, art, view, bus, refs, grid, pics));
      });

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _UtilsModule.apply(this, arguments);
}

class Utils extends _apis_handler__WEBPACK_IMPORTED_MODULE_11__["MessageHandlerReflective"] {
  constructor(board, api, art, view, bus, refs, gridController, picnumSelector) {
    super();
    this.board = board;
    this.api = api;
    this.art = art;
    this.view = view;
    this.bus = bus;
    this.refs = refs;
    this.gridController = gridController;
    this.picnumSelector = picnumSelector;
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'insert_sprite':
        this.insertSprite();
        return;
      // case 'print_selected': this.print(); return;

      case 'set_first_wall':
        this.setFirstWall();
        return;

      case 'fill_inner_sector':
        this.fillInnerLoop();
        return;

      case 'delete_loop':
        this.deleteLoop();
        return;

      case 'delete_full':
        this.deleteFull();
        return;

      case 'print_usage':
        this.printPicUsage();
        return;

      case 'split_wall':
        this.splitWall();
        return;
    }
  }

  insertSprite() {
    var target = this.view.snapTarget();
    if (target.entity == null) return;
    var [x, y, z] = target.coords;
    var ent = target.entity;
    this.picnumSelector(picnum => {
      if (picnum == -1) return;
      var board = this.board();

      if (ent.isWall()) {
        var normal = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["wallNormal"])(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_7__["vec3"].create(), board, ent.id);
        var offx = normal[0] * 4;
        var offy = normal[2] * 4;
        var sprite = this.api.newSprite();
        sprite.x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(x + offx);
        sprite.y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(y + offy);
        sprite.z = this.gridController.snap(z);
        sprite.sectnum = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_3__["sectorOfWall"])(board, ent.id);
        sprite.picnum = picnum;
        sprite.cstat.type = _build_board_structs__WEBPACK_IMPORTED_MODULE_4__["WALL_SPRITE"];
        sprite.ang = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["vec2ang"])(normal[0], normal[2]);
        Object(_build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__["addSprite"])(board, sprite);
      } else {
        var sectorId = ent.isSector() ? ent.id : ent.isSprite() ? board.sprites[ent.id].sectnum : -1;

        var _sprite = this.api.newSprite();

        _sprite.x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(x);
        _sprite.y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(y);
        _sprite.z = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_9__["int"])(z);
        _sprite.sectnum = sectorId;
        _sprite.picnum = picnum;
        Object(_build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_0__["addSprite"])(board, _sprite);
      }

      this.commit();
    });
  }

  setFirstWall() {
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__["setFirstWall"])(this.board(), Object(_build_board_query__WEBPACK_IMPORTED_MODULE_3__["sectorOfWall"])(this.board(), target.entity.id), target.entity.id, this.refs);
    this.commit();
    this.invalidateAll();
  }

  fillInnerLoop() {
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__["fillInnerLoop"])(this.board(), target.entity.id, this.refs, this.api);
    this.commit();
    this.invalidateAll();
  }

  deleteLoop() {
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__["deleteLoop"])(this.board(), target.entity.id, this.refs);
    this.commit();
    this.invalidateAll();
  }

  deleteFull() {
    var target = this.view.snapTarget();
    if (target.entity == null) return;
    if (target.entity.isWall()) Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__["deleteLoopFull"])(this.board(), target.entity.id, this.refs);else if (target.entity.isSector()) Object(_build_board_mutations_sectors__WEBPACK_IMPORTED_MODULE_1__["deleteSectorFull"])(this.board(), target.entity.id, this.refs);else return;
    this.commit();
    this.invalidateAll();
  }

  splitWall() {
    var target = this.view.snapTarget();
    if (target.entity == null || !target.entity.isWall()) return;
    var [x, y] = target.coords;
    var id = target.entity.id;
    var board = this.board();
    Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_2__["splitWall"])(board, id, x, y, this.art, this.refs, this.api.cloneWall);
    this.commit();
    var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_3__["sectorOfWall"])(board, id);
    Object(_editutils__WEBPACK_IMPORTED_MODULE_12__["invalidateSectorAndWalls"])(s, board, this.bus);
    var nextsector = board.walls[id].nextsector;

    if (nextsector != -1) {
      Object(_editutils__WEBPACK_IMPORTED_MODULE_12__["invalidateSectorAndWalls"])(nextsector, board, this.bus);
    }
  }

  print() {
    var target = this.view.target();
    var board = this.board();
    if (target.entity == null) return;

    switch (target.entity.type) {
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING:
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].FLOOR:
        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_8__["info"])(target.entity.id, board.sectors[target.entity.id]);
        break;

      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].UPPER_WALL:
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].MID_WALL:
      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].LOWER_WALL:
        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_8__["info"])(target.entity.id, board.walls[target.entity.id]);
        break;

      case _build_hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].SPRITE:
        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_8__["info"])(target.entity.id, board.sprites[target.entity.id]);
        break;
    }
  }

  getSectorPics(board, sectorId) {
    var sector = board.sectors[sectorId];
    var pics = new Set();
    pics.add(sector.ceilingpicnum);
    pics.add(sector.floorpicnum);
    var wallend = sector.wallptr + sector.wallnum;

    for (var w = sector.wallptr; w < wallend; w++) {
      var wall = board.walls[w];

      if (wall.nextwall == -1) {
        pics.add(wall.picnum);
      } else {
        var wall2 = board.walls[wall.point2];
        var nextwall = board.walls[wall.nextwall];
        var nextwall2 = board.walls[nextwall.nextwall];
        var nextsectorId = wall.nextsector;
        var nextsector = board.sectors[nextsectorId];
        var cz1 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, sectorId, wall.x, wall.y, sector.ceilingheinum) + sector.ceilingz;
        var cz2 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, sectorId, wall2.x, wall2.y, sector.ceilingheinum) + sector.ceilingz;
        var czn1 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, nextsectorId, nextwall.x, nextwall.y, nextsector.ceilingheinum) + sector.ceilingz;
        var czn2 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, nextsectorId, nextwall2.x, nextwall2.y, nextsector.ceilingheinum) + sector.ceilingz;
        if (cz1 < czn1 || cz2 < czn2) pics.add(wall.picnum);
        var fz1 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, sectorId, wall.x, wall.y, sector.floorheinum) + sector.floorz;
        var fz2 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, sectorId, wall2.x, wall2.y, sector.floorheinum) + sector.floorz;
        var fzn1 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, nextsectorId, nextwall.x, nextwall.y, nextsector.floorheinum) + sector.floorz;
        var fzn2 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_6__["slope"])(board, nextsectorId, nextwall2.x, nextwall2.y, nextsector.floorheinum) + sector.floorz;

        if (fz1 > fzn1 || fz2 > fzn2) {
          if (wall.cstat.swapBottoms) pics.add(wall2.picnum);else pics.add(wall.picnum);
        }

        if (wall.cstat.masking) pics.add(wall.overpicnum);
      }
    }

    return pics;
  }

  printPicUsage() {
    // const board = this.board();
    // const results: [string, number][] = [];
    // const picsStat = new Map<number, Set<number>>();
    // for (let s = 0; s < board.numsectors; s++) {
    //   const pics = [...this.getSectorPics(board, s)];
    //   results.push([pics.sort().join(','), s]);
    //   pics.forEach(p => {
    //     let sectors = picsStat.get(p);
    //     if (sectors == undefined) {
    //       sectors = new Set();
    //       picsStat.set(p, sectors);
    //     }
    //     sectors.add(s);
    //   })
    // }
    // info([...picsStat.values()].sort((l, r) => l.size - r.size));
    // const imgStats = new Map<string, Set<number>>();
    // const art = this.art;
    // for (let i = 0; i < 4096; i++) {
    //   const info = art.getInfo(i);
    //   if (info == null) continue;
    //   const key = `${info.w}x${info.h}`;
    //   let ids = imgStats.get(key);
    //   if (ids == undefined) {
    //     ids = new Set();
    //     imgStats.set(key, ids);
    //   }
    //   ids.add(i);
    // }
    // info([...imgStats.entries()].sort((l, r) => l[1].size - r[1].size));
    var target = this.view.target();
    if (!target.entity.isSector()) return;
    var board = this.board();
    var art = this.art;
    var sectorId = target.entity.id;
    var pics = new Set();
    var sectors = new Set();
    var sizes = new Set();
    var sector = board.sectors[sectorId];

    var pf = p => {
      pics.add(p);
      var i = art.getInfo(p);
      sizes.add(i.w + "x" + i.h);
    };

    this.getSectorPics(board, sectorId).forEach(pf);
    var wallend = sector.wallptr + sector.wallnum;

    for (var w = sector.wallptr; w < wallend; w++) {
      var wall = board.walls[w];
      if (wall.nextsector == -1) continue;
      var nextsector = wall.nextsector;
      if (sectors.has(nextsector)) continue;
      this.getSectorPics(board, nextsector).forEach(pf);
      sectors.add(nextsector);
    }

    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_8__["info"])(pics, sectors, sizes);
  }

  commit() {
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_13__["COMMIT"]);
  }

  invalidateAll() {
    this.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_13__["INVALIDATE_ALL"]);
  }

}

/***/ }),

/***/ "./src/app/edit/wall.ts":
/*!******************************!*\
  !*** ./src/app/edit/wall.ts ***!
  \******************************/
/*! exports provided: WallEnt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallEnt", function() { return WallEnt; });
/* harmony import */ var _build_board_loops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/board/loops */ "./src/build/board/loops.ts");
/* harmony import */ var _build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/board/mutations/walls */ "./src/build/board/mutations/walls.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _editutils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editutils */ "./src/app/edit/editutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _tools_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/selection */ "./src/app/edit/tools/selection.ts");











class WallEnt extends _apis_handler__WEBPACK_IMPORTED_MODULE_7__["MessageHandlerReflective"] {
  constructor(wallId, ctx, origin, active, connectedWalls, valid) {
    if (origin === void 0) {
      origin = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec2"].create();
    }

    if (active === void 0) {
      active = false;
    }

    if (connectedWalls === void 0) {
      connectedWalls = Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["connectedWalls"])(ctx.board(), wallId);
    }

    if (valid === void 0) {
      valid = true;
    }

    super();
    this.wallId = wallId;
    this.ctx = ctx;
    this.origin = origin;
    this.active = active;
    this.connectedWalls = connectedWalls;
    this.valid = valid;
  }

  StartMove(msg) {
    var board = this.ctx.board();
    var wall = board.walls[this.wallId];

    if (this.ctx.state.get(_tools_selection__WEBPACK_IMPORTED_MODULE_10__["MOVE_COPY"])) {
      this.wallId = Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_1__["splitWall"])(board, this.wallId, wall.x, wall.y, this.ctx.art, this.ctx.refs, this.ctx.api.cloneWall);
      this.connectedWalls = Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["connectedWalls"])(board, this.wallId);
    }

    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec2"].set(this.origin, wall.x, wall.y);
    this.active = true;
  }

  invalidate() {
    WallEnt.invalidatedSectors.clear();
    var cwalls = this.connectedWalls;
    var board = this.ctx.board();

    for (var w of cwalls) {
      var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_2__["sectorOfWall"])(board, w);

      if (WallEnt.invalidatedSectors.indexOf(s) == -1) {
        Object(_editutils__WEBPACK_IMPORTED_MODULE_8__["invalidateSectorAndWalls"])(s, board, this.ctx.bus);
        WallEnt.invalidatedSectors.push(s);
      }
    }
  }

  Move(msg) {
    var x = this.ctx.gridController.snap(this.origin[0] + msg.dx);
    var y = this.ctx.gridController.snap(this.origin[1] + msg.dy);

    if (Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_1__["moveWall"])(this.ctx.board(), this.wallId, x, y)) {
      this.invalidate();
    }
  }

  EndMove(msg) {
    this.active = false;
    Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_1__["mergePoints"])(this.ctx.board(), this.wallId, this.ctx.refs);
  }

  Highlight(msg) {
    if (this.active) {
      var board = this.ctx.board();

      for (var w of this.connectedWalls) {
        var p = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_2__["lastwall"])(board, w);
        msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["tuple"])(2, w));
        msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["tuple"])(3, w));
        msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["tuple"])(2, p));
      }
    } else {
      msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["tuple"])(3, this.wallId));
    }
  }

  SetPicnum(msg) {
    var wall = this.ctx.board().walls[this.wallId];
    wall.picnum = msg.picnum;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["Entity"](this.wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["EntityType"].WALL_POINT)));
  }

  Shade(msg) {
    var wall = this.ctx.board().walls[this.wallId];
    var shade = wall.shade;
    if (msg.absolute && shade == msg.value) return;
    if (msg.absolute) wall.shade = msg.value;else wall.shade += msg.value;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["Entity"](this.wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["EntityType"].WALL_POINT)));
  }

  PanRepeat(msg) {
    var wall = this.ctx.board().walls[this.wallId];

    if (msg.absolute) {
      if (wall.xpanning == msg.xpan && wall.ypanning == msg.ypan && wall.xrepeat == msg.xrepeat && wall.yrepeat == msg.yrepeat) return;
      wall.xpanning = msg.xpan;
      wall.ypanning = msg.ypan;
      wall.xrepeat = msg.xrepeat;
      wall.yrepeat = msg.yrepeat;
    } else {
      wall.xpanning += msg.xpan;
      wall.ypanning += msg.ypan;
      wall.xrepeat += msg.xrepeat;
      wall.yrepeat += msg.yrepeat;
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["Entity"](this.wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["EntityType"].WALL_POINT)));
  }

  Palette(msg) {
    var wall = this.ctx.board().walls[this.wallId];

    if (msg.absolute) {
      if (msg.value == wall.pal) return;
      wall.pal = msg.value;
    } else {
      wall.pal = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["cyclic"])(wall.pal + msg.value, msg.max);
    }

    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["Entity"](this.wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["EntityType"].WALL_POINT)));
  }

  Flip(msg) {
    var wall = this.ctx.board().walls[this.wallId];
    var flip = wall.cstat.xflip + wall.cstat.yflip * 2;
    var nflip = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["cyclic"])(flip + 1, 4);
    wall.cstat.xflip = nflip & 1;
    wall.cstat.yflip = (nflip & 2) >> 1;
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["Entity"](this.wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_3__["EntityType"].WALL_POINT)));
  }

  NamedMessage(msg) {
    if (msg.name == 'delete') {
      Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_1__["deleteWall"])(this.ctx.board(), this.wallId, this.ctx.refs);
      this.ctx.bus.handle(_messages__WEBPACK_IMPORTED_MODULE_9__["COMMIT"]);
      this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](null));
    }
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.valid = false;
  }

  handle(msg) {
    if (this.valid) super.handle(msg);
  }

}
WallEnt.invalidatedSectors = new _utils_collections__WEBPACK_IMPORTED_MODULE_5__["IndexedDeck"]();

/***/ }),

/***/ "./src/app/edit/wallsegment.ts":
/*!*************************************!*\
  !*** ./src/app/edit/wallsegment.ts ***!
  \*************************************/
/*! exports provided: WallSegmentsEnt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallSegmentsEnt", function() { return WallSegmentsEnt; });
/* harmony import */ var _build_board_loops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/board/loops */ "./src/build/board/loops.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _editutils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editutils */ "./src/app/edit/editutils.ts");
/* harmony import */ var _messages__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../build/board/mutations/walls */ "./src/build/board/mutations/walls.ts");












function getClosestWallByIds(board, target, ids) {
  var id = -1;
  var mindist = Number.MAX_VALUE;
  var [x, y] = target.coords;

  for (var w of ids) {
    var wall = board.walls[w];
    var dist = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["len2d"])(wall.x - x, wall.y - y);

    if (dist < mindist) {
      id = w;
      mindist = dist;
    }
  }

  return id == -1 ? ids[Symbol.iterator]().next().value : id;
}

function collectConnectedWalls(board, walls) {
  var result = new Set();

  for (var w of walls) {
    Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["connectedWalls"])(board, w, result);
  }

  return result;
}

class WallSegmentsEnt extends _apis_handler__WEBPACK_IMPORTED_MODULE_7__["MessageHandlerReflective"] {
  constructor(wallIds, highlighted, bottom, ctx, origin, refwall, active, connectedWalls, canonicalWalls, valid) {
    if (origin === void 0) {
      origin = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].create();
    }

    if (refwall === void 0) {
      refwall = -1;
    }

    if (active === void 0) {
      active = false;
    }

    if (connectedWalls === void 0) {
      connectedWalls = collectConnectedWalls(ctx.board(), wallIds);
    }

    if (canonicalWalls === void 0) {
      canonicalWalls = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(wallIds).map(w => Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["canonicalWall"])(ctx.board(), w)).set();
    }

    if (valid === void 0) {
      valid = true;
    }

    super();
    this.wallIds = wallIds;
    this.highlighted = highlighted;
    this.bottom = bottom;
    this.ctx = ctx;
    this.origin = origin;
    this.refwall = refwall;
    this.active = active;
    this.connectedWalls = connectedWalls;
    this.canonicalWalls = canonicalWalls;
    this.valid = valid;
  }

  invalidate() {
    var invalidatedSectors = WallSegmentsEnt.invalidatedSectors.clear();
    var board = this.ctx.board();

    for (var w of this.connectedWalls) {
      var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["sectorOfWall"])(board, w);

      if (invalidatedSectors.indexOf(s) == -1) {
        Object(_editutils__WEBPACK_IMPORTED_MODULE_8__["invalidateSectorAndWalls"])(s, board, this.ctx.bus);
        invalidatedSectors.push(s);
      }
    }
  }

  getWall(w) {
    var board = this.ctx.board();
    var wall = board.walls[w];
    return wall.cstat.swapBottoms && this.bottom && wall.nextwall != -1 ? board.walls[wall.nextwall] : wall;
  }

  invalidateWall(w) {
    var board = this.ctx.board();
    this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](w, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].WALL_POINT)));
    var wall = board.walls[w];
    if (wall.cstat.swapBottoms && wall.nextwall != -1 || wall.nextwall != -1 && board.walls[wall.nextwall].cstat.swapBottoms) this.ctx.bus.handle(new _messages__WEBPACK_IMPORTED_MODULE_9__["BoardInvalidate"](new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](wall.nextwall, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].WALL_POINT)));
  }

  StartMove(msg) {
    var board = this.ctx.board();
    this.refwall = getClosestWallByIds(board, this.ctx.view.target(), this.canonicalWalls);
    var wall = board.walls[this.refwall];
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].set(this.origin, wall.x, wall.y);
    this.active = true;
  }

  Move(msg) {
    var board = this.ctx.board();
    var x = this.ctx.gridController.snap(this.origin[0] + msg.dx);
    var y = this.ctx.gridController.snap(this.origin[1] + msg.dy);
    var refwall = board.walls[this.refwall];
    var dx = x - refwall.x;
    var dy = y - refwall.y;

    if (Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__["moveWall"])(board, this.refwall, x, y)) {
      for (var w of this.canonicalWalls) {
        if (w == this.refwall) continue;
        var wall = board.walls[w];
        Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__["moveWall"])(board, w, wall.x + dx, wall.y + dy);
      }

      this.invalidate();
    }
  }

  EndMove(msg) {
    this.active = false;

    for (var w of this.wallIds) {
      Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__["mergePoints"])(this.ctx.board(), w, this.ctx.refs);
    }
  }

  Rotate(msg) {
    var board = this.ctx.board();
    var target = this.ctx.view.snapTarget();
    var [cx, cy] = target.coords;
    var ang = msg.da / 128 * (Math.PI / 8);
    var matrix = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["mat2d"].create();
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["mat2d"].translate(matrix, matrix, [cx, cy]);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["mat2d"].rotate(matrix, matrix, ang);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["mat2d"].translate(matrix, matrix, [-cx, -cy]);

    for (var w of this.canonicalWalls) {
      var wall = board.walls[w];
      var [x, y] = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec2"].transformMat2d([], [wall.x, wall.y], matrix);
      Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__["moveWall"])(board, w, Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(x), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(y));
    }

    this.invalidate();
  }

  Highlight(msg) {
    // const board = this.ctx.board();
    // if (this.active) {
    //   let cwalls = this.connectedWalls;
    //   for (let w of cwalls) {
    //     let s = sectorOfWall(board, w);
    //     let p = lastwall(board, w);
    //     msg.set.add(tuple(2, w));
    //     msg.set.add(tuple(3, w));
    //     msg.set.add(tuple(2, p));
    //     msg.set.add(tuple(0, s));
    //     msg.set.add(tuple(1, s));
    //   }
    // } else {
    var hwalls = this.highlighted;

    for (var w of hwalls) {
      msg.set.add(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["tuple"])(2, w));
    } // }

  }

  SetPicnum(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);
      wall.picnum = msg.picnum;
      this.invalidateWall(w);
    }
  }

  Shade(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);
      var shade = wall.shade;
      if (msg.absolute && shade == msg.value) return;
      if (msg.absolute) wall.shade = msg.value;else wall.shade += msg.value;
      this.invalidateWall(w);
    }
  }

  ResetPanRepeat(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);
      wall.xpanning = 0;
      wall.ypanning = 0;
      wall.yrepeat = 8;
      Object(_build_board_mutations_walls__WEBPACK_IMPORTED_MODULE_10__["fixxrepeat"])(this.ctx.board(), w);
      this.invalidateWall(w);
    }
  }

  PanRepeat(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);

      if (msg.absolute) {
        if (wall.xpanning == msg.xpan && wall.ypanning == msg.ypan && wall.xrepeat == msg.xrepeat && wall.yrepeat == msg.yrepeat) return;
        wall.xpanning = msg.xpan;
        wall.ypanning = msg.ypan;
        wall.xrepeat = msg.xrepeat;
        wall.yrepeat = msg.yrepeat;
      } else {
        wall.xpanning += msg.xpan;
        wall.ypanning += msg.ypan;
        wall.xrepeat += msg.xrepeat;
        wall.yrepeat += msg.yrepeat;
      }

      this.invalidateWall(w);
    }
  }

  Palette(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);

      if (msg.absolute) {
        if (msg.value == wall.pal) return;
        wall.pal = msg.value;
      } else {
        wall.pal = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["cyclic"])(wall.pal + msg.value, msg.max);
      }

      this.invalidateWall(w);
    }
  }

  Flip(msg) {
    for (var w of this.highlighted) {
      var wall = this.getWall(w);
      var flip = wall.cstat.xflip + wall.cstat.yflip * 2;
      var nflip = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["cyclic"])(flip + 1, 4);
      wall.cstat.xflip = nflip & 1;
      wall.cstat.yflip = (nflip & 2) >> 1;
      this.invalidateWall(w);
    }
  }

  SetWallCstat(msg) {
    var board = this.ctx.board();

    for (var w of this.highlighted) {
      var wall = msg.name == 'swapBottoms' ? board.walls[w] : this.getWall(w);
      var stat = wall.cstat[msg.name];
      wall.cstat[msg.name] = stat ? 0 : 1;
      this.invalidateWall(w);
    }
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.valid = false;
  }

  handle(msg) {
    if (this.valid) super.handle(msg);
  }

}
WallSegmentsEnt.invalidatedSectors = new _utils_collections__WEBPACK_IMPORTED_MODULE_4__["IndexedDeck"]();

/***/ }),

/***/ "./src/app/input/keymap.ts":
/*!*********************************!*\
  !*** ./src/app/input/keymap.ts ***!
  \*********************************/
/*! exports provided: keyPress, key, mouseClick, mouseButton, combination, wheelUp, wheelDown, Binder, loadBinds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyPress", function() { return keyPress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "key", function() { return key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseClick", function() { return mouseClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseButton", function() { return mouseButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combination", function() { return combination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wheelUp", function() { return wheelUp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wheelDown", function() { return wheelDown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Binder", function() { return Binder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadBinds", function() { return loadBinds; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");


function keyPress(key) {
  return state => state.keysPress[key];
}
function key(key) {
  return state => state.keys[key];
}
function mouseClick(button) {
  return state => state.mouseClicks[button];
}
function mouseButton(button) {
  return state => state.mouseButtons[button];
}
function combination(lh, rh) {
  return state => lh(state) && rh(state);
}
var wheelUp = state => state.wheel > 0;
var wheelDown = state => state.wheel < 0;

function parseMod(str) {
  if (str == 'mouse0') return mouseButton(0);
  if (str == 'mouse1') return mouseButton(1);
  if (str == 'mouse2') return mouseButton(2);
  return key(str.toUpperCase());
}

function parseKey(str) {
  if (str == 'wheelup') return wheelUp;
  if (str == 'wheeldown') return wheelDown;
  if (str == 'mouse0') return mouseClick(0);
  if (str == 'mouse1') return mouseClick(1);
  if (str == 'mouse2') return mouseClick(2);
  return keyPress(str.toUpperCase());
}

function canonizeBind(key, mods) {
  key = key.toLowerCase();
  mods = mods.map(s => s.toLowerCase());
  mods.sort();
  return [...mods, key].join('+');
}

function createHandler(key, mods) {
  var handler = parseKey(key);

  for (var i = 0; i < mods.length; i++) {
    handler = combination(handler, parseMod(mods[i]));
  }

  return handler;
}

class Binder {
  constructor() {
    this.binds = [];
    this.handlers = [];
    this.messages = [];
    this.sorttable = [];
    this.stateBinds = [];
    this.stateHandlers = [];
    this.stateValues = [];
  }

  poolEvents(state) {
    for (var i = this.handlers.length - 1; i >= 0; i--) {
      if (this.handlers[i](state)) return this.messages[i];
    }

    return _utils_collections__WEBPACK_IMPORTED_MODULE_0__["EMPTY_COLLECTION"];
  }

  updateState(input, state) {
    for (var i = 0; i < this.stateHandlers.length; i++) {
      var handler = this.stateHandlers[i];
      var values = this.stateValues[i];

      for (var [name, on, off] of values) {
        if (state.has(name)) state.set(name, handler(input) ? on : off);
      }
    }
  }

  addStateBind(name, enabled, disabled) {
    for (var _len = arguments.length, keys = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      keys[_key - 3] = arguments[_key];
    }

    var last = keys.pop();
    var bindName = canonizeBind(last, keys);
    var idx = this.stateBinds.indexOf(bindName);

    if (idx == -1) {
      this.stateBinds.push(bindName);
      var handler = parseMod(last);

      for (var _key2 of keys) {
        handler = combination(handler, parseMod(_key2));
      }

      this.stateHandlers.push(handler);
      this.stateValues.push([[name, enabled, disabled]]);
    } else {
      this.stateValues[idx].push([name, enabled, disabled]);
    }
  }

  addBind(messages, key) {
    for (var _len2 = arguments.length, mods = new Array(_len2 > 2 ? _len2 - 2 : 0), _key3 = 2; _key3 < _len2; _key3++) {
      mods[_key3 - 2] = arguments[_key3];
    }

    var bindName = canonizeBind(key, mods);
    var bindIdx = this.findBind(bindName, mods.length);

    if (bindIdx == -1) {
      var handler = createHandler(key, mods);
      this.insertBind(bindName, handler, messages, mods.length);
    } else {
      this.messages[bindIdx].pushAll(messages);
    }
  }

  insertBind(bindName, handler, messages, mods) {
    this.ensureSortTable(mods);
    var pos = this.sorttable[mods];
    this.binds.splice(pos, 0, bindName);
    this.handlers.splice(pos, 0, handler);
    this.messages.splice(pos, 0, new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]().pushAll(messages));

    for (var i = this.sorttable.length - 1; i >= mods; i--) {
      this.sorttable[i]++;
    }
  }

  findBind(bindName, mods) {
    this.ensureSortTable(mods);
    var start = mods == 0 ? 0 : this.sorttable[mods - 1];

    for (var i = start; i < this.sorttable[mods]; i++) {
      if (this.binds[i] == bindName) return i;
    }

    return -1;
  }

  ensureSortTable(mods) {
    for (var i = mods; i >= 0; i--) {
      if (this.sorttable[i] == undefined) this.sorttable[i] = this.binds.length;else break;
    }
  }

}
function loadBinds(binds, binder, messageParser) {
  var lines = binds.split(/\r?\n/);

  for (var line of lines) {
    line = line.trim();
    if (line.length == 0) continue;
    var idx = line.indexOf(' ');

    if (idx == -1) {
      Object(_utils_logger__WEBPACK_IMPORTED_MODULE_1__["warning"])("Skipping bind line: " + line);
      continue;
    }

    var keys = line.substr(0, idx).toLowerCase();

    if (keys.startsWith('+')) {
      keys = keys.substr(1);
      var keyParts = keys.split('+');
      binder.addStateBind(line.substr(idx + 1).trim(), true, false, ...keyParts);
    } else {
      var _str = line.substr(idx + 1).trim();

      var messages = messageParser(_str);

      if (messages == null) {
        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_1__["warning"])("'" + _str + "' failed to parse");
        continue;
      }

      var _keyParts = keys.split('+');

      binder.addBind(messages, _keyParts.pop(), ..._keyParts);
    }
  }
}

/***/ }),

/***/ "./src/app/input/messageparser.ts":
/*!****************************************!*\
  !*** ./src/app/input/messageparser.ts ***!
  \****************************************/
/*! exports provided: messageParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageParser", function() { return messageParser; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/lexer */ "./src/utils/lexer.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../edit/messages */ "./src/app/edit/messages.ts");





class MessageParser {
  constructor() {
    this.lexer = new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["Lexer"]();
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^[ \t\r\v\n]+/, 'WS'));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^[a-zA-Z_][a-zA-Z0-9_]+/, 'ID'));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^,/, 'COMA'));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^(false|true)/, 'BOOLEAN', 0, s => s == 'true'));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^\-?[0-9]*(\.[0-9]+)?([eE][\+\-][0-9]+)?/, 'FLOAT', 0, s => parseFloat(s)));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^\-?[0-9]+/, 'INT', 0, s => parseInt(s)));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^"([^"]*)"/, 'STRING', 1));
    this.lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_1__["LexerRule"](/^\{([^\}]*)\}/, 'MACRO', 1));
  }

  setSource(src) {
    this.lexer.setSource(src);
  }

  get(expected, value) {
    if (value === void 0) {
      value = null;
    }

    for (; this.lexer.next() == 'WS';) {
      ;
    }

    if (this.lexer.isEoi()) throw new Error();
    var tokenId = this.lexer.rule().name;
    var actual = this.lexer.value();
    if (tokenId != expected || value != null && value != actual) throw new Error();
    return this.lexer.value();
  }

  tryGet(expected, value) {
    if (value === void 0) {
      value = null;
    }

    var mark = this.lexer.mark();

    try {
      return this.get(expected, value);
    } catch (e) {
      this.lexer.reset(mark);
      return null;
    }
  }

}

var parser = new MessageParser();

function parseArgs() {
  var args = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();

  for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {
    types[_key] = arguments[_key];
  }

  for (var type of types) {
    args.push(parser.get(type));
  }

  return args;
}

var NOOP_MESSAGE = {};
var factArgs = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();

function createMessage(constr) {
  for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    types[_key2 - 1] = arguments[_key2];
  }

  var args = parseArgs(...types);
  factArgs.clear();

  for (var v of args) {
    factArgs.push(v);
  }

  try {
    return Reflect.construct(constr, [...factArgs]);
  } catch (e) {
    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__["error"])("Invalid message constructor " + constr.name + " (" + types + ")", factArgs);
    return NOOP_MESSAGE;
  }
}

var parsdMessages = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();

function tryParseMessage() {
  parsdMessages.clear();

  switch (parser.get('ID')) {
    case 'picnum':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["SetPicnum"], 'INT'));

    case 'shade':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["Shade"], 'INT', 'BOOLEAN'));

    case 'panrepeat':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["PanRepeat"], 'INT', 'INT', 'INT', 'INT', 'BOOLEAN'));

    case 'pal':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["Palette"], 'INT', 'INT', 'BOOLEAN'));

    case 'wallcstat':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["SetWallCstat"], 'ID', 'BOOLEAN', 'BOOLEAN'));

    case 'sectorcstat':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["SetSectorCstat"], 'ID', 'BOOLEAN', 'BOOLEAN'));

    case 'spritecstat':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["SetSpriteCstat"], 'ID', 'BOOLEAN', 'BOOLEAN'));

    case 'rotate':
      return parsdMessages.push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["Rotate"], 'INT'));

    case 'flip':
      return parsdMessages.push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["Flip"]());

    case 'sprite_mode':
      return parsdMessages.push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["SpriteMode"]());

    case 'reset_panrepeat':
      return parsdMessages.push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["ResetPanRepeat"]());

    case 'move':
      return parsdMessages.push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["StartMove"]()).push(createMessage(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["Move"], 'INT', 'INT', 'INT')).push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["EndMove"]());

    default:
      return parsdMessages;
  }
}

function tryParse(src, messages) {
  try {
    parser.setSource(src);
    parser.get('ID', 'msg');
    var parsedMessages = tryParseMessage();

    while (!Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(parsedMessages)) {
      messages.pushAll(parsedMessages);

      try {
        parser.get('COMA');
      } catch (e) {
        break;
      }

      parsedMessages = tryParseMessage();
    }

    return messages;
  } catch (e) {
    return messages.clear();
  }
}

var messages = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
function messageParser(str) {
  var result = tryParse(str, messages.clear());
  if (result.length() == 0) return messages.push(new _edit_messages__WEBPACK_IMPORTED_MODULE_3__["NamedMessage"](str));
  return result;
}

/***/ }),

/***/ "./src/app/modules/arteditor.ts":
/*!**************************************!*\
  !*** ./src/app/modules/arteditor.ts ***!
  \**************************************/
/*! exports provided: ArtEditorModule, ArtEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtEditorModule", function() { return ArtEditorModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtEditor", function() { return ArtEditor; });
/* harmony import */ var _build_artpixelprovider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/artpixelprovider */ "./src/build/artpixelprovider.ts");
/* harmony import */ var _build_formats_art__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../build/formats/art */ "./src/build/formats/art.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_imgutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/imgutils */ "./src/utils/imgutils.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_pixelprovider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/pixelprovider */ "./src/utils/pixelprovider.ts");
/* harmony import */ var _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils/ui/drawpanel */ "./src/utils/ui/drawpanel.ts");
/* harmony import */ var _utils_ui_renderers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils/ui/renderers */ "./src/utils/ui/renderers.ts");
/* harmony import */ var _utils_ui_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utils/ui/ui */ "./src/utils/ui/ui.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../apis/ui */ "./src/app/apis/ui.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../edit/messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _artselector__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./artselector */ "./src/app/modules/artselector.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


















function createDrawPanel(arts, pal, plu, canvas, cb, iter) {
  var provider = new _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_8__["PixelDataProvider"](1024 * 10, i => {
    var info = arts.getInfo(i);
    if (info == null) return null;
    return new _build_artpixelprovider__WEBPACK_IMPORTED_MODULE_0__["ArtPixelProvider"](info, pal, plu);
  });
  return new _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_8__["DrawPanel"](canvas, iter, provider, cb);
}

function ArtEditorModule(_x) {
  return _ArtEditorModule.apply(this, arguments);
}

function _ArtEditorModule() {
  _ArtEditorModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_12__["BUS"]);
        var editor = yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_4__["create"])(injector, ArtEditor, _apis_ui__WEBPACK_IMPORTED_MODULE_13__["UI"], _apis_app__WEBPACK_IMPORTED_MODULE_11__["ART"], _artselector__WEBPACK_IMPORTED_MODULE_15__["RAW_PAL"], _artselector__WEBPACK_IMPORTED_MODULE_15__["RAW_PLUs"], _artselector__WEBPACK_IMPORTED_MODULE_15__["PIC_TAGS"]);
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_14__["namedMessageHandler"])('show_artedit', () => editor.show()));
      });

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _ArtEditorModule.apply(this, arguments);
}

class ArtEditor {
  constructor(ui, arts, pal, plus, tags) {
    this.window = void 0;
    this.drawPanel = void 0;
    this.filter = "";
    this.view = void 0;
    this.searchWidget = void 0;
    this.currentId = -1;
    this.centerX = 320;
    this.centerY = 320;
    this.frame = 0;
    this.animation = -1;
    this.scale = 2.0;
    this.currentPlu = 0;

    this.pluProvider = x => this.plus[this.currentPlu][x];

    this.ui = ui;
    this.arts = arts;
    this.pal = pal;
    this.plus = plus;
    this.tags = tags;
    this.searchWidget = Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_9__["search"])('Search', s => {
      this.updateFilter(s);
      this.updateSuggestions(s);
    });
    var browserCanvas = document.createElement('canvas');
    browserCanvas.width = 640;
    browserCanvas.height = 192;
    browserCanvas.style.display = 'block';
    this.view = this.createView();
    this.window = ui.builder.window().title('ART Edit').draggable(true).closeable(true).centered(true).size(640, 640).content(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_10__["div"])('').appendHtml(this.view).appendHtml(browserCanvas).elem()).toolbar(ui.builder.toolbar().widget(this.createPalSelectingMenu()).widget(this.searchWidget.widget)).build();
    this.drawPanel = createDrawPanel(arts, pal, this.pluProvider, browserCanvas, id => this.select(id), () => this.pics());
    this.window.hide();
  }

  createPalSelectingMenu() {
    var menu = this.ui.builder.menu();
    Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_2__["range"])(0, this.plus.length)).forEach(i => menu.item(i + '', () => {
      this.currentPlu = i;
      this.redraw();
    }));
    return Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_9__["menuButton"])('icon-adjust', menu);
  }

  updateSuggestions(s) {
    var menu = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(this.tags.allTags()).filter(t => t.toLowerCase().startsWith(s.toLowerCase())).map(t => [t, () => {
      this.searchWidget.setValue(t);
      this.updateFilter(t);
    }]);
    this.searchWidget.updateSuggestions(Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_9__["sugggestionsMenu"])(menu));
  }

  updateFilter(s) {
    this.filter = s;
    this.drawPanel.scrollToId(this.currentId);
    this.drawPanel.draw();
  }

  applyFilter(id) {
    var tags = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(this.tags.tags(id));
    if (this.filter.startsWith('*')) return (id + '').includes(this.filter.substr(1));
    return (id + '').startsWith(this.filter) || tags.any(t => t.toLowerCase() == this.filter.toLowerCase());
  }

  pics() {
    return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_2__["range"])(0, 10 * 1024)).filter(i => this.applyFilter(i));
  }

  createView() {
    var canvas = document.createElement('canvas');
    canvas.width = 640;
    canvas.height = 640 - 192;
    canvas.style.display = 'block';
    canvas.addEventListener('wheel', e => {
      if (e.deltaY > 0) this.scale *= 0.9;
      if (e.deltaY < 0) this.scale *= 1.1;
      this.updateView(false);
    });
    var isDrag = false;
    var oldx = 0;
    var oldy = 0;
    canvas.addEventListener('mousemove', e => {
      if (isDrag) {
        var dx = e.x - oldx;
        var dy = e.y - oldy;

        if (dx != 0 || dy != 0) {
          this.centerX += dx;
          this.centerY += dy;
          this.updateView(false);
        }
      }

      oldx = e.x;
      oldy = e.y;
    });
    canvas.addEventListener('mousedown', e => isDrag = true);
    canvas.addEventListener('mouseup', e => isDrag = false);
    return canvas;
  }

  select(id) {
    this.drawPanel.deselectAll();
    this.drawPanel.select(id);
    var info = this.arts.getInfo(id);
    if (info != null && info.attrs.frames) Object(_utils_iter__WEBPACK_IMPORTED_MODULE_5__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_2__["range"])(0, info.attrs.frames + 1)).forEach(i => this.drawPanel.select(id + i));
    this.drawPanel.draw();
    this.currentId = id;
    this.resetAnimation();
    this.updateView();
  }

  resetAnimation() {
    window.clearTimeout(this.animation);
    this.animation = -1;
    this.frame = 0;
  }

  updateView(anim) {
    if (anim === void 0) {
      anim = true;
    }

    var ctx = this.view.getContext('2d');
    ctx.fillStyle = 'black';
    ctx.strokeStyle = 'white';
    ctx.fillRect(0, 0, this.view.clientWidth, this.view.clientHeight);
    var mainInfo = this.arts.getInfo(this.currentId);
    var frameInfo = this.arts.getInfo(this.currentId + Object(_build_formats_art__WEBPACK_IMPORTED_MODULE_1__["animate"])(this.frame, mainInfo));
    if (mainInfo == null || frameInfo == null) return;
    var scaledW = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(frameInfo.w * this.scale);
    var scaledH = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(frameInfo.h * this.scale);
    var img = Object(_utils_pixelprovider__WEBPACK_IMPORTED_MODULE_7__["resize"])(new _build_artpixelprovider__WEBPACK_IMPORTED_MODULE_0__["ArtPixelProvider"](frameInfo, this.pal, this.pluProvider), scaledW, scaledH);
    var x = this.centerX - Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(((frameInfo.attrs.xoff | 0) + frameInfo.w / 2) * this.scale);
    var y = this.centerY - Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(((frameInfo.attrs.yoff | 0) + frameInfo.h / 2) * this.scale);
    Object(_utils_imgutils__WEBPACK_IMPORTED_MODULE_3__["drawToCanvas"])(img, ctx, x, y);

    if (anim && (mainInfo.attrs.frames | 0) != 0) {
      this.frame++;
      this.animation = window.setTimeout(() => this.updateView(), mainInfo.attrs.speed * 50);
    }
  }

  redraw() {
    this.drawPanel.draw();
    this.updateView(false);
  }

  show() {
    this.window.show();
    this.redraw();
  }

}

/***/ }),

/***/ "./src/app/modules/artselector.ts":
/*!****************************************!*\
  !*** ./src/app/modules/artselector.ts ***!
  \****************************************/
/*! exports provided: RAW_PAL, RAW_PLUs, PIC_TAGS, SelectorConstructor, Selector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAW_PAL", function() { return RAW_PAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAW_PLUs", function() { return RAW_PLUs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PIC_TAGS", function() { return PIC_TAGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectorConstructor", function() { return SelectorConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selector", function() { return Selector; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_pixelprovider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/pixelprovider */ "./src/utils/pixelprovider.ts");
/* harmony import */ var _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/ui/drawpanel */ "./src/utils/ui/drawpanel.ts");
/* harmony import */ var _utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/ui/renderers */ "./src/utils/ui/renderers.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../apis/ui */ "./src/app/apis/ui.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }










function createDrawPanel(arts, pal, canvas, cb, iter) {
  var provider = new _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_4__["PixelDataProvider"](1024 * 10, i => {
    var info = arts.getInfo(i);
    if (info == null) return null;
    return Object(_utils_pixelprovider__WEBPACK_IMPORTED_MODULE_3__["axisSwap"])(new _utils_pixelprovider__WEBPACK_IMPORTED_MODULE_3__["RGBPalPixelProvider"](info.img, pal, info.h, info.w, 255, 255));
  });
  return new _utils_ui_drawpanel__WEBPACK_IMPORTED_MODULE_4__["DrawPanel"](canvas, iter, provider, cb);
}

var RAW_PAL = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('RawPal');
var RAW_PLUs = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('Raw PLUs');
var PIC_TAGS = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('Tags');
function SelectorConstructor(_x) {
  return _SelectorConstructor.apply(this, arguments);
}

function _SelectorConstructor() {
  _SelectorConstructor = _asyncToGenerator(function* (injector) {
    var selector = yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_1__["create"])(injector, Selector, _apis_ui__WEBPACK_IMPORTED_MODULE_7__["UI"], _apis_app__WEBPACK_IMPORTED_MODULE_6__["ART"], RAW_PAL, PIC_TAGS);
    return cb => selector.modal(cb);
  });
  return _SelectorConstructor.apply(this, arguments);
}

function createTagsGridModel(tags) {
  var selected = new Set();
  var columns = [_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__["IconTextRenderer"]];
  var callback;
  var grid = {
    rows() {
      return _asyncToGenerator(function* () {
        return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(tags.allTags()).map(s => [[s, selected.has(s)]]);
      })();
    },

    columns() {
      return columns;
    },

    onClick(row, rowElement) {
      var value = row[0][0];
      if (selected.has(value)) selected.delete(value);else selected.add(value);
      rowElement.elem().classList.toggle('selected');
      if (callback) callback(selected.values());
    }

  };
  return {
    renderGrid() {
      return Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__["renderGrid"])(grid);
    },

    selected() {
      return selected;
    },

    connect(cb) {
      callback = cb;
    }

  };
}

class Selector {
  // private selectedTags: string[] = [];
  constructor(ui, arts, pal, tags) {
    this.window = void 0;
    this.drawPanel = void 0;
    this.cb = void 0;
    this.filter = "";
    this.searchWidget = void 0;
    this.ui = ui;
    this.tags = tags;
    var canvas = document.createElement('canvas');
    canvas.width = canvas.height = 640; // const grid = createTagsGridModel(tags);
    // const gridPanel = div('pane-sm sidebar').css('width', '170px');
    // grid.renderGrid().then(g => gridPanel.append(g));
    // grid.connect(tags => { this.selectedTags = [...tags], this.drawPanel.draw() });
    // const paneGroup = div('pane-group')
    //   .append(gridPanel)
    //   .append(div('pane').css('overflow', 'hidden').appendHtml(canvas));

    this.searchWidget = Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__["search"])('Search', s => {
      this.updateFilter(s);
      this.updateSuggestions(s);
    });
    this.window = ui.builder.window().id('select_tile').title('Tiles').draggable(true).closeable(true).centered(true).size(640, 640).toolbar(ui.builder.toolbar().widget(Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__["menuButton"])('icon-popup', ui.builder.menu().item('32', () => {
      this.drawPanel.setCellSize(32, 32);
    }).item('64', () => {
      this.drawPanel.setCellSize(64, 64);
    }).item('128', () => {
      this.drawPanel.setCellSize(128, 128);
    }))).widget(this.searchWidget.widget)).onclose(() => this.select(-1)).content(canvas).build();
    this.drawPanel = createDrawPanel(arts, pal, canvas, id => this.select(id), () => this.pics());
    this.drawPanel.select(110);
    this.drawPanel.select(111);
    this.hide();
  }

  updateFilter(s) {
    this.filter = s;
    this.drawPanel.seOffset(0);
    this.drawPanel.draw();
  }

  updateSuggestions(s) {
    var menu = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(this.tags.allTags()).filter(t => t.toLowerCase().startsWith(s.toLowerCase())).map(t => [t, () => {
      this.searchWidget.setValue(t);
      this.updateFilter(t);
    }]);
    this.searchWidget.updateSuggestions(Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_5__["sugggestionsMenu"])(menu));
  }

  applyFilter(id) {
    var tags = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(this.tags.tags(id)); // if (!tags.isEmpty() && !tags.any(t => this.selectedTags.includes(t))) return false;

    if (this.filter.startsWith('*')) return (id + '').includes(this.filter.substr(1));
    return (id + '').startsWith(this.filter) || tags.any(t => t.toLowerCase() == this.filter.toLowerCase());
  }

  pics() {
    return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, 10 * 1024)).filter(i => this.applyFilter(i));
  }

  show() {
    this.window.setPosition('50%', '50%');
    this.window.show();
    this.drawPanel.draw();
  }

  hide() {
    this.window.hide();
  }

  modal(cb) {
    this.cb = cb;
    this.show();
  }

  select(id) {
    this.hide();
    if (this.cb == null) return;
    var cb = this.cb;
    this.cb = null;
    cb(id);
  }

}

/***/ }),

/***/ "./src/app/modules/buildartprovider.ts":
/*!*********************************************!*\
  !*** ./src/app/modules/buildartprovider.ts ***!
  \*********************************************/
/*! exports provided: GL, ART_FILES, TEXTURES_OVERRIDE, PARALLAX_TEXTURES, createIndexedTexture, BuildArtProviderConstructor, BuildArtProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL", function() { return GL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ART_FILES", function() { return ART_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURES_OVERRIDE", function() { return TEXTURES_OVERRIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARALLAX_TEXTURES", function() { return PARALLAX_TEXTURES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIndexedTexture", function() { return createIndexedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildArtProviderConstructor", function() { return BuildArtProviderConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildArtProvider", function() { return BuildArtProvider; });
/* harmony import */ var _build_formats_art__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../build/formats/art */ "./src/build/formats/art.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_gl_textures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/gl/textures */ "./src/utils/gl/textures.ts");
/* harmony import */ var _utils_imglib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/imglib */ "./src/utils/imglib.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }








var GL = new _utils_injector__WEBPACK_IMPORTED_MODULE_4__["Dependency"]('GL');
var ART_FILES = new _utils_injector__WEBPACK_IMPORTED_MODULE_4__["Dependency"]('ArtFiles');
var TEXTURES_OVERRIDE = new _utils_injector__WEBPACK_IMPORTED_MODULE_4__["Dependency"]('Textures Override');
var PARALLAX_TEXTURES = new _utils_injector__WEBPACK_IMPORTED_MODULE_4__["Dependency"]('Number of parallax textures');
function createIndexedTexture(gl, w, h, arr, mipmaps, lib) {
  if (mipmaps === void 0) {
    mipmaps = true;
  }

  var repeat = WebGLRenderingContext.CLAMP_TO_EDGE;
  var filter = mipmaps ? WebGLRenderingContext.NEAREST_MIPMAP_NEAREST : WebGLRenderingContext.NEAREST;
  var tex = Object(_utils_gl_textures__WEBPACK_IMPORTED_MODULE_2__["createTexture"])(w, h, gl, {
    filter: filter,
    repeat: repeat
  }, arr, gl.LUMINANCE);
  if (mipmaps) addMipMaps(gl, w, h, arr, tex, lib);
  return tex;
} // function addMipMaps(gl: WebGLRenderingContext, w: number, h: number, arr: Uint8Array, tex: TextureImpl, lib: IndexedImgLib) {
//   let div = 2;
//   let level = 1;
//   while (int(w / div) >= 1 || int(h / div) >= 1) {
//     const dw = Math.max(1, int(w / div));
//     const dh = Math.max(1, int(h / div));
//     const mip = lib.resize(dw, dh, w, h, arr);
//     tex.mip(gl, level, dw, dh, mip);
//     div *= 2;
//     level++;
//   }
// }

function addMipMaps(gl, w, h, arr, tex, lib) {
  var level = 1;

  while (w >= 1 || h >= 1) {
    var nw = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(w / 2);
    var dw = Math.max(1, nw);
    var nh = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_6__["int"])(h / 2);
    var dh = Math.max(1, nh);
    var mip = lib.resize(dw, dh, w, h, arr);
    tex.mip(gl, level, dw, dh, mip);
    arr = mip;
    w = nw;
    h = nh;
    level++;
  }
}

function BuildArtProviderConstructor(_x) {
  return _BuildArtProviderConstructor.apply(this, arguments);
}

function _BuildArtProviderConstructor() {
  _BuildArtProviderConstructor = _asyncToGenerator(function* (injector) {
    var [art, util, gl, parallax, lib] = yield Promise.all([injector.getInstance(ART_FILES), injector.getInstance(TEXTURES_OVERRIDE), injector.getInstance(GL), injector.getInstance(PARALLAX_TEXTURES), injector.getInstance(_utils_imglib__WEBPACK_IMPORTED_MODULE_3__["INDEXED_IMG_LIB"])]);
    return new BuildArtProvider(art, util, gl, parallax, lib);
  });
  return _BuildArtProviderConstructor.apply(this, arguments);
}

class BuildArtProvider {
  constructor(arts, addTextures, gl, parallaxPics, lib) {
    this.textures = [];
    this.parallaxTextures = [];
    this.infos = [];
    this.arts = arts;
    this.addTextures = addTextures;
    this.gl = gl;
    this.parallaxPics = parallaxPics;
    this.lib = lib;
  }

  get(picnum) {
    var add = this.addTextures(picnum);
    if (add != undefined) return add;
    var tex = this.textures[picnum];
    if (tex != undefined) return tex;
    var info = this.arts.getInfo(picnum);
    if (info.h <= 0 || info.w <= 0) return this.get(0);
    var arr = this.axisSwap(info.img, info.h, info.w);
    tex = createIndexedTexture(this.gl, info.w, info.h, arr, true, this.lib);
    this.textures[picnum] = tex;
    return tex;
  }

  getParallaxTexture(picnum) {
    var tex = this.parallaxTextures[picnum];
    if (tex != undefined) return tex;
    var infos = [];
    var axisSwapped = [];

    for (var i = 0; i < this.parallaxPics; i++) {
      infos[i] = this.arts.getInfo(picnum + i);

      if (i != 0) {
        if (infos[i].w != infos[i - 1].w || infos[i].h != infos[i - 1].h) {
          Object(_utils_logger__WEBPACK_IMPORTED_MODULE_5__["warning"])("Invalid parallax texture #" + picnum);
          return this.get(0);
        }
      }

      axisSwapped[i] = this.axisSwap(infos[i].img, infos[i].h, infos[i].w);
    }

    var w = infos[0].w;
    var h = infos[0].h;
    var merged = this.mergeParallax(w, h, axisSwapped);
    tex = createIndexedTexture(this.gl, w * this.parallaxPics, h, merged, true, this.lib);
    this.parallaxTextures[picnum] = tex;
    return tex;
  }

  mergeParallax(w, h, arrs) {
    var result = new Uint8Array(w * h * this.parallaxPics);

    for (var y = 0; y < h; y++) {
      for (var i = 0; i < this.parallaxPics; i++) {
        for (var x = 0; x < w; x++) {
          result[y * w * this.parallaxPics + i * w + x] = arrs[i][y * w + x];
        }
      }
    }

    return result;
  }

  axisSwap(data, w, h) {
    var result = new Uint8Array(w * h);

    for (var [x, y] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["rect"])(w, h)) {
      result[x * h + y] = data[y * w + x];
    }

    return result;
  }

  getInfo(picnum) {
    var info = this.infos[picnum];
    if (info != undefined) return info;
    var add = this.addTextures(picnum);
    info = add != undefined ? new _build_formats_art__WEBPACK_IMPORTED_MODULE_0__["ArtInfo"](add.getWidth(), add.getHeight(), new _build_formats_art__WEBPACK_IMPORTED_MODULE_0__["Attributes"](), add.data) : this.arts.getInfo(picnum);
    this.infos[picnum] = info;
    return info;
  }

}

/***/ }),

/***/ "./src/app/modules/context.ts":
/*!************************************!*\
  !*** ./src/app/modules/context.ts ***!
  \************************************/
/*! exports provided: DefaultSetupModule, MainLoopConstructor, MainLoop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultSetupModule", function() { return DefaultSetupModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainLoopConstructor", function() { return MainLoopConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainLoop", function() { return MainLoop; });
/* harmony import */ var _app_modules_artselector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../app/modules/artselector */ "./src/app/modules/artselector.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_imglib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/imglib */ "./src/utils/imglib.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_scheduler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../apis/scheduler */ "./src/app/apis/scheduler.ts");
/* harmony import */ var _edit_context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../edit/context */ "./src/app/edit/context.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../edit/messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _edit_tools_drawsector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../edit/tools/drawsector */ "./src/app/edit/tools/drawsector.ts");
/* harmony import */ var _edit_tools_drawwall__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../edit/tools/drawwall */ "./src/app/edit/tools/drawwall.ts");
/* harmony import */ var _edit_tools_joinsectors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../edit/tools/joinsectors */ "./src/app/edit/tools/joinsectors.ts");
/* harmony import */ var _edit_tools_pushwall__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../edit/tools/pushwall */ "./src/app/edit/tools/pushwall.ts");
/* harmony import */ var _edit_tools_selection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../edit/tools/selection */ "./src/app/edit/tools/selection.ts");
/* harmony import */ var _edit_tools_toolsbus__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../edit/tools/toolsbus */ "./src/app/edit/tools/toolsbus.ts");
/* harmony import */ var _edit_tools_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../edit/tools/utils */ "./src/app/edit/tools/utils.ts");
/* harmony import */ var _modules_statusbar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../modules/statusbar */ "./src/app/modules/statusbar.ts");
/* harmony import */ var _modules_taskmanager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../modules/taskmanager */ "./src/app/modules/taskmanager.ts");
/* harmony import */ var _buildartprovider__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./buildartprovider */ "./src/app/modules/buildartprovider.ts");
/* harmony import */ var _default_grid__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./default/grid */ "./src/app/modules/default/grid.ts");
/* harmony import */ var _default_history__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./default/history */ "./src/app/modules/default/history.ts");
/* harmony import */ var _default_reftracker__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./default/reftracker */ "./src/app/modules/default/reftracker.ts");
/* harmony import */ var _default_state__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./default/state */ "./src/app/modules/default/state.ts");
/* harmony import */ var _default_utiltex__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./default/utiltex */ "./src/app/modules/default/utiltex.ts");
/* harmony import */ var _geometry_cache__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./geometry/cache */ "./src/app/modules/geometry/cache.ts");
/* harmony import */ var _geometry_common__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./geometry/common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _gl_buffers__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./gl/buffers */ "./src/app/modules/gl/buffers.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
/* harmony import */ var _info__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./info */ "./src/app/modules/info.tsx");
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./view/view */ "./src/app/modules/view/view.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

































function mapBackupService(_x) {
  return _mapBackupService.apply(this, arguments);
}

function _mapBackupService() {
  _mapBackupService = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (injector) {
        var storages = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["STORAGES"]);
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
        var board = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["BOARD"]);
        var defaultBoard = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_BOARD"]);
        var store = yield storages('session');
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_9__["namedMessageHandler"])('commit', () => store.set('map_bak', board())));
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_9__["namedMessageHandler"])('new_board', () => {
          bus.handle(new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["LoadBoard"](defaultBoard));
          store.set('map_bak', defaultBoard);
        }));
        var map = yield store.get('map_bak');

        if (map) {
          var _bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);

          _bus.handle(new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["LoadBoard"](map));
        }
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }());
  });
  return _mapBackupService.apply(this, arguments);
}

function newMap(module) {
  module.execute( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
      var defaultBoard = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_BOARD"]);
      bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_9__["namedMessageHandler"])('new_board', () => {
        bus.handle(new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["LoadBoard"](defaultBoard));
      }));
    });

    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }());
}

function DefaultSetupModule(module) {
  module.bindInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["REFERENCE_TRACKER"], new _default_reftracker__WEBPACK_IMPORTED_MODULE_22__["BuildReferenceTrackerImpl"]());
  module.bindInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["STATE"], new _default_state__WEBPACK_IMPORTED_MODULE_23__["StateImpl"]());
  module.bind(_buildartprovider__WEBPACK_IMPORTED_MODULE_19__["TEXTURES_OVERRIDE"], _default_utiltex__WEBPACK_IMPORTED_MODULE_24__["DefaultAdditionalTextures"]);
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_5__["GRID"], _default_grid__WEBPACK_IMPORTED_MODULE_20__["DefaultGridController"]);
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_5__["ART"], _buildartprovider__WEBPACK_IMPORTED_MODULE_19__["BuildArtProviderConstructor"]);
  module.bind(_edit_tools_selection__WEBPACK_IMPORTED_MODULE_14__["PICNUM_SELECTOR"], _app_modules_artselector__WEBPACK_IMPORTED_MODULE_0__["SelectorConstructor"]);
  module.bind(_gl_buildgl__WEBPACK_IMPORTED_MODULE_28__["BUILD_GL"], _gl_buildgl__WEBPACK_IMPORTED_MODULE_28__["BuildGlConstructor"]);
  module.bind(_gl_buffers__WEBPACK_IMPORTED_MODULE_27__["BUFFER_FACTORY"], _gl_buffers__WEBPACK_IMPORTED_MODULE_27__["DefaultBufferFactory"]);
  module.bind(_geometry_common__WEBPACK_IMPORTED_MODULE_26__["BUILDERS_FACTORY"], _geometry_common__WEBPACK_IMPORTED_MODULE_26__["DefaultBuildersFactory"]);
  module.bind(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"], _apis_handler__WEBPACK_IMPORTED_MODULE_6__["DefaultMessageBus"]);
  module.bind(_edit_tools_toolsbus__WEBPACK_IMPORTED_MODULE_15__["TOOLS_BUS"], _edit_tools_toolsbus__WEBPACK_IMPORTED_MODULE_15__["ToolsBusConstructor"]);
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_5__["BOARD"], _default_history__WEBPACK_IMPORTED_MODULE_21__["DefaultBoardProviderConstructor"]);
  module.bind(_edit_context__WEBPACK_IMPORTED_MODULE_8__["ENTITY_FACTORY"], _edit_context__WEBPACK_IMPORTED_MODULE_8__["EntityFactoryConstructor"]);
  module.bind(_utils_imglib__WEBPACK_IMPORTED_MODULE_2__["INDEXED_IMG_LIB"], _utils_imglib__WEBPACK_IMPORTED_MODULE_2__["IndexedImgLibJsConstructor"]);
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_5__["SCHEDULER"], _apis_scheduler__WEBPACK_IMPORTED_MODULE_7__["DefaultScheduler"]);
  module.install(_view_view__WEBPACK_IMPORTED_MODULE_30__["SwappableViewModule"]);
  module.install(_edit_tools_joinsectors__WEBPACK_IMPORTED_MODULE_12__["JoinSectorsModule"]);
  module.install(_edit_tools_drawsector__WEBPACK_IMPORTED_MODULE_10__["DrawSectorModule"]);
  module.install(_edit_tools_drawwall__WEBPACK_IMPORTED_MODULE_11__["DrawWallModule"]);
  module.install(_edit_tools_pushwall__WEBPACK_IMPORTED_MODULE_13__["PushWallModule"]);
  module.install(_geometry_cache__WEBPACK_IMPORTED_MODULE_25__["RenderablesCacheModule"]);
  module.install(_edit_tools_selection__WEBPACK_IMPORTED_MODULE_14__["SelectionModule"]);
  module.install(_info__WEBPACK_IMPORTED_MODULE_29__["InfoModule"]);
  module.install(_modules_statusbar__WEBPACK_IMPORTED_MODULE_17__["StatusBarModule"]);
  module.install(_edit_tools_utils__WEBPACK_IMPORTED_MODULE_16__["UtilsModule"]);
  module.install(_modules_taskmanager__WEBPACK_IMPORTED_MODULE_18__["TaskManagerModule"]);
  module.install(newMap); // module.install(mapBackupService);
}
function MainLoopConstructor(injector) {
  return Object(_utils_injector__WEBPACK_IMPORTED_MODULE_3__["create"])(injector, MainLoop, _apis_app__WEBPACK_IMPORTED_MODULE_5__["VIEW"], _apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
}

function createTools() {
  var list = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
  return {
    consumer: r => list.push(r),
    clear: () => list.clear(),
    provider: list
  };
}

var FRAME = new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["Frame"](0);
var POSTFRAME = new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["PostFrame"]();
var tools = createTools();
var RENDER = new _edit_messages__WEBPACK_IMPORTED_MODULE_9__["Render"](tools.consumer);
class MainLoop extends _apis_handler__WEBPACK_IMPORTED_MODULE_6__["MessageHandlerReflective"] {
  constructor(view, bus) {
    super();
    this.view = view;
    this.bus = bus;
    this.view = view;
    this.bus = bus;
    this.bus.connect(this);
  }

  drawTools() {
    tools.clear();
    this.bus.handle(RENDER);
    this.view.drawTools(tools.provider);
  }

  frame(dt) {
    _utils_profiler__WEBPACK_IMPORTED_MODULE_4__["start"]();
    FRAME.dt = dt;
    this.bus.handle(FRAME);
    this.drawTools();
    _utils_profiler__WEBPACK_IMPORTED_MODULE_4__["endProfile"]();
    this.bus.handle(POSTFRAME);
  }

}

/***/ }),

/***/ "./src/app/modules/db.ts":
/*!*******************************!*\
  !*** ./src/app/modules/db.ts ***!
  \*******************************/
/*! exports provided: StorageDbConstructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageDbConstructor", function() { return StorageDbConstructor; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class Db {
  constructor(name, version) {
    if (version === void 0) {
      version = 1;
    }

    this.db = void 0;
    this.name = name;
    this.db = this.connect(name, version);
  }

  connect(name, version) {
    if (version === void 0) {
      version = 1;
    }

    return new Promise((ok, error) => {
      var openRequest = indexedDB.open('BuildEd-' + name, version);

      openRequest.onerror = e => error(e);

      openRequest.onsuccess = db => ok(openRequest.result);

      openRequest.onupgradeneeded = () => {
        var db = openRequest.result;

        db.onerror = e => error(e);

        db.createObjectStore(name, {
          keyPath: 'key'
        });
      };
    });
  }

  request(mode) {
    var _this = this;

    return _asyncToGenerator(function* () {
      var db = yield _this.db;
      var transaction = db.transaction(_this.name, mode);
      return transaction.objectStore(_this.name);
    })();
  }

  get(key) {
    var _this2 = this;

    return new Promise( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (ok, error) {
        var request = (yield _this2.request('readonly')).get(key.toUpperCase());

        request.onsuccess = () => ok(request.result ? request.result.data : null);

        request.onerror = e => error(e);
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  set(key, value) {
    var _this3 = this;

    return new Promise( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (ok, error) {
        var request = (yield _this3.request('readwrite')).put({
          key: key.toUpperCase(),
          name: key,
          data: value
        });

        request.onsuccess = () => ok();

        request.onerror = e => error(e);
      });

      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
  }

  delete(key) {
    var _this4 = this;

    return new Promise( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (ok, error) {
        var request = (yield _this4.request('readwrite')).delete(key.toUpperCase());

        request.onsuccess = () => ok();

        request.onerror = e => error(e);
      });

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }());
  }

  clear() {
    var _this5 = this;

    return new Promise( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (ok, error) {
        var request = (yield _this5.request('readwrite')).clear();

        request.onsuccess = () => ok();

        request.onerror = e => error(e);
      });

      return function (_x7, _x8) {
        return _ref4.apply(this, arguments);
      };
    }());
  }

  keys() {
    var _this6 = this;

    return new Promise( /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (ok, error) {
        var request = (yield _this6.request('readonly')).openCursor();
        var keys = [];

        request.onsuccess = () => {
          var cursor = request.result;
          if (!cursor) return ok(keys);
          keys.push(cursor.value.name);
          cursor.continue();
        };

        request.onerror = e => error(e);
      });

      return function (_x9, _x10) {
        return _ref5.apply(this, arguments);
      };
    }());
  }

}

function StorageDbConstructor(_x11) {
  return _StorageDbConstructor.apply(this, arguments);
}

function _StorageDbConstructor() {
  _StorageDbConstructor = _asyncToGenerator(function* (injector) {
    var storages = {};
    return /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* (name) {
        var storage = storages[name];

        if (storage == undefined) {
          storage = new Db(name);
          storages[name] = storage;
        }

        return storage;
      });

      return function (_x12) {
        return _ref6.apply(this, arguments);
      };
    }();
  });
  return _StorageDbConstructor.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/default/grid.ts":
/*!*****************************************!*\
  !*** ./src/app/modules/default/grid.ts ***!
  \*****************************************/
/*! exports provided: GridControllerImpl, DefaultGridController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridControllerImpl", function() { return GridControllerImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultGridController", function() { return DefaultGridController; });
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }



class GridControllerImpl extends _apis_handler__WEBPACK_IMPORTED_MODULE_0__["MessageHandlerReflective"] {
  constructor() {
    super(...arguments);
    this.gridSizes = [16, 32, 64, 128, 256, 512, 1024];
    this.gridSizeIdx = 4;
  }

  setGridSize(size) {
    if (size < this.gridSizes[0]) this.gridSizeIdx = 0;else if (size > this.gridSizes[this.gridSizes.length - 1]) this.gridSizeIdx = this.gridSizes.length - 1;else {
      for (var i = 0; i < this.gridSizes.length - 2; i++) {
        var i1 = i + 1;
        if (size > this.gridSizes[i1]) continue;
        this.gridSizeIdx = size - this.gridSizes[i] < this.gridSizes[i1] - size ? i : i1;
        break;
      }
    }
  }

  snapGrid(coord) {
    var gridSize = this.getGridSize();
    return Math.round(coord / gridSize) * gridSize;
  }

  getGridSize() {
    return this.gridSizes[this.gridSizeIdx];
  }

  incGridSize() {
    this.gridSizeIdx = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["cyclic"])(this.gridSizeIdx + 1, this.gridSizes.length);
  }

  decGridSize() {
    this.gridSizeIdx = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["cyclic"])(this.gridSizeIdx - 1, this.gridSizes.length);
  }

  snap(x) {
    return this.snapGrid(x);
  }

  NamedMessage(msg) {
    switch (msg.name) {
      case 'grid+':
        this.incGridSize();
        return;

      case 'grid-':
        this.decGridSize();
        return;
    }
  }

}
function DefaultGridController(_x) {
  return _DefaultGridController.apply(this, arguments);
}

function _DefaultGridController() {
  _DefaultGridController = _asyncToGenerator(function* (injector) {
    var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_0__["BUS"]);
    var grid = new GridControllerImpl();
    bus.connect(grid);
    return grid;
  });
  return _DefaultGridController.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/default/history.ts":
/*!********************************************!*\
  !*** ./src/app/modules/default/history.ts ***!
  \********************************************/
/*! exports provided: DefaultBoardProviderConstructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultBoardProviderConstructor", function() { return DefaultBoardProviderConstructor; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../edit/messages */ "./src/app/edit/messages.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }






class History {
  constructor() {
    this.history = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
  }

  push(board) {
    this.history.push(board);
  }

  pop() {
    if (this.history.length() > 1) this.history.pop();
  }

  top() {
    return this.history.top();
  }

}

function DefaultBoardProviderConstructor(_x) {
  return _DefaultBoardProviderConstructor.apply(this, arguments);
}

function _DefaultBoardProviderConstructor() {
  _DefaultBoardProviderConstructor = _asyncToGenerator(function* (injector) {
    var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]);
    var api = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["ENGINE_API"]);
    var defaultBoard = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_BOARD"]);
    var history = new History();
    var activeBoard = api.cloneBoard(defaultBoard);
    history.push(api.cloneBoard(defaultBoard));
    bus.connect(new class extends _apis_handler__WEBPACK_IMPORTED_MODULE_2__["MessageHandlerReflective"] {
      NamedMessage(msg) {
        switch (msg.name) {
          case 'undo':
            history.pop();
            activeBoard = api.cloneBoard(history.top());
            bus.handle(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["INVALIDATE_ALL"]);
            return;

          case 'commit':
            history.push(api.cloneBoard(activeBoard));
            return;
        }
      }

      LoadBoard(msg) {
        activeBoard = api.cloneBoard(msg.board);
        history.push(api.cloneBoard(msg.board));
        bus.handle(_edit_messages__WEBPACK_IMPORTED_MODULE_3__["INVALIDATE_ALL"]);
      }

    }());
    return () => activeBoard;
  });
  return _DefaultBoardProviderConstructor.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/default/reftracker.ts":
/*!***********************************************!*\
  !*** ./src/app/modules/default/reftracker.ts ***!
  \***********************************************/
/*! exports provided: BuildReferenceTrackerImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildReferenceTrackerImpl", function() { return BuildReferenceTrackerImpl; });
/* harmony import */ var _apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../apis/referencetracker */ "./src/app/apis/referencetracker.ts");

class BuildReferenceTrackerImpl {
  constructor() {
    this.walls = new _apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__["ReferenceTrackerImpl"](-1);
    this.sectors = new _apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__["ReferenceTrackerImpl"](-1);
    this.sprites = new _apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__["ReferenceTrackerImpl"](-1);
  }

}

/***/ }),

/***/ "./src/app/modules/default/state.ts":
/*!******************************************!*\
  !*** ./src/app/modules/default/state.ts ***!
  \******************************************/
/*! exports provided: StateImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateImpl", function() { return StateImpl; });
class StateImpl {
  constructor() {
    this.state = {};
  }

  register(name, defaultValue) {
    var prevState = this.state[name];
    if (prevState != undefined) throw new Error("Redefining state " + name);
    this.state[name] = defaultValue;
  }

  set(name, value) {
    this.get(name);
    this.state[name] = value;
  }

  get(name) {
    var stateValue = this.state[name];
    if (stateValue == undefined) throw new Error("State " + name + " is unregistered");
    return stateValue;
  }

  has(name) {
    return this.state[name] != undefined;
  }

}

/***/ }),

/***/ "./src/app/modules/default/utiltex.ts":
/*!********************************************!*\
  !*** ./src/app/modules/default/utiltex.ts ***!
  \********************************************/
/*! exports provided: DefaultAdditionalTextures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultAdditionalTextures", function() { return DefaultAdditionalTextures; });
/* harmony import */ var _utils_lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/lexer */ "./src/utils/lexer.ts");
/* harmony import */ var _buildartprovider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../buildartprovider */ "./src/app/modules/buildartprovider.ts");
/* harmony import */ var _fs_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fs/fs */ "./src/app/modules/fs/fs.ts");
/* harmony import */ var _utils_imglib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/imglib */ "./src/utils/imglib.ts");
/* harmony import */ var _utils_imgutils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/imgutils */ "./src/utils/imgutils.ts");
/* harmony import */ var _utils_gl_textures__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/gl/textures */ "./src/utils/gl/textures.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }








function createLexer(str) {
  var lexer = new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["Lexer"]();
  lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["LexerRule"](/^[ \t\r\v\n]+/, 'WS'));
  lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["LexerRule"](/^[a-zA-Z_][a-zA-Z0-9_]+/, 'ID'));
  lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["LexerRule"](/^\-?[0-9]+/, 'INT', 0, parseInt));
  lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["LexerRule"](/^"([^"]*)"/, 'STRING', 1));
  lexer.addRule(new _utils_lexer__WEBPACK_IMPORTED_MODULE_0__["LexerRule"](/^;/, 'SEMICOLON'));
  lexer.setSource(str);
  return {
    get: function get(expected, value) {
      if (value === void 0) {
        value = null;
      }

      for (; lexer.next() == 'WS';) {
        ;
      }

      if (lexer.isEoi()) throw new Error();
      var tokenId = lexer.rule().name;
      var actual = lexer.value();
      if (tokenId != expected || value != null && value != actual) throw new Error();
      return lexer.value();
    }
  };
}

function loadTexture(_x, _x2, _x3, _x4, _x5) {
  return _loadTexture.apply(this, arguments);
}

function _loadTexture() {
  _loadTexture = _asyncToGenerator(function* (gl, name, options, format, bpp) {
    if (options === void 0) {
      options = {};
    }

    if (format === void 0) {
      format = gl.RGBA;
    }

    if (bpp === void 0) {
      bpp = 4;
    }

    return Object(_utils_imgutils__WEBPACK_IMPORTED_MODULE_4__["loadImage"])(name).then(img => Object(_utils_gl_textures__WEBPACK_IMPORTED_MODULE_5__["createTexture"])(img[0], img[1], gl, options, img[2], format, bpp));
  });
  return _loadTexture.apply(this, arguments);
}

function DefaultAdditionalTextures(_x6) {
  return _DefaultAdditionalTextures.apply(this, arguments);
}

function _DefaultAdditionalTextures() {
  _DefaultAdditionalTextures = _asyncToGenerator(function* (injector) {
    var textures = {};
    var [gl, fs, lib] = yield Promise.all([injector.getInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_1__["GL"]), injector.getInstance(_fs_fs__WEBPACK_IMPORTED_MODULE_2__["FS"]), injector.getInstance(_utils_imglib__WEBPACK_IMPORTED_MODULE_3__["INDEXED_IMG_LIB"])]);
    var file = yield fs.get('texlist.lst');
    var decoder = new TextDecoder('utf-8');
    var list = decoder.decode(file);
    var lexer = createLexer(list);

    try {
      for (;;) {
        var id = lexer.get('INT');
        var path = lexer.get('STRING');
        var options = lexer.get('ID');
        lexer.get('SEMICOLON');

        if (options == 'plain') {
          var opts = {
            filter: WebGLRenderingContext.NEAREST,
            repeat: WebGLRenderingContext.CLAMP_TO_EDGE
          };
          textures[id] = yield loadTexture(gl, path, opts);
        } else if (options == 'palletize') {
          var texture = yield fs.get(path);
          var [w, h, buff] = yield Object(_utils_imgutils__WEBPACK_IMPORTED_MODULE_4__["loadImageFromBuffer"])(texture);
          var indexed = lib.palettize(w, h, buff);
          textures[id] = Object(_buildartprovider__WEBPACK_IMPORTED_MODULE_1__["createIndexedTexture"])(gl, w, h, indexed, true, lib);
        }
      }
    } finally {
      return id => textures[id];
    }
  });
  return _DefaultAdditionalTextures.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/duke/module.ts":
/*!****************************************!*\
  !*** ./src/app/modules/duke/module.ts ***!
  \****************************************/
/*! exports provided: DukeModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DukeModule", function() { return DukeModule; });
/* harmony import */ var _build_board_structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _build_maploader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/maploader */ "./src/build/maploader.ts");
/* harmony import */ var _build_formats_art__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/formats/art */ "./src/build/formats/art.ts");
/* harmony import */ var _build_formats_grp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../build/formats/grp */ "./src/build/formats/grp.ts");
/* harmony import */ var _utils_gl_textures__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/gl/textures */ "./src/utils/gl/textures.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../edit/messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _artselector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../artselector */ "./src/app/modules/artselector.ts");
/* harmony import */ var _buildartprovider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../buildartprovider */ "./src/app/modules/buildartprovider.ts");
/* harmony import */ var _fs_fs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../fs/fs */ "./src/app/modules/fs/fs.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
/* harmony import */ var _selectmap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../selectmap */ "./src/app/modules/selectmap.ts");
/* harmony import */ var _view_boardrenderer3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../view/boardrenderer3d */ "./src/app/modules/view/boardrenderer3d.ts");
/* harmony import */ var _fs_manager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../fs/manager */ "./src/app/modules/fs/manager.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _utils_stream__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../utils/stream */ "./src/utils/stream.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


















var GRP = new _utils_injector__WEBPACK_IMPORTED_MODULE_5__["Dependency"]('Grp File');
var SHADOW_TABLE = new _utils_injector__WEBPACK_IMPORTED_MODULE_5__["Dependency"]('Shadow Table');

function loadArtFiles(_x) {
  return _loadArtFiles.apply(this, arguments);
}

function _loadArtFiles() {
  _loadArtFiles = _asyncToGenerator(function* (injector) {
    var grp = yield injector.getInstance(GRP);
    var artFiles = [];

    for (var a = 0; a < 20; a++) {
      artFiles.push(new _build_formats_art__WEBPACK_IMPORTED_MODULE_2__["ArtFile"](grp.get('tiles0' + ("00" + a).slice(-2) + '.art')));
    }

    return new _build_formats_art__WEBPACK_IMPORTED_MODULE_2__["ArtFiles"](artFiles);
  });
  return _loadArtFiles.apply(this, arguments);
}

function loadPal(_x2) {
  return _loadPal.apply(this, arguments);
}

function _loadPal() {
  _loadPal = _asyncToGenerator(function* (injector) {
    var grp = yield injector.getInstance(GRP);
    return Object(_build_formats_grp__WEBPACK_IMPORTED_MODULE_3__["createPalette"])(grp.get('PALETTE.DAT'));
  });
  return _loadPal.apply(this, arguments);
}

function loadPalTexture(_x3) {
  return _loadPalTexture.apply(this, arguments);
}

function _loadPalTexture() {
  _loadPalTexture = _asyncToGenerator(function* (injector) {
    return Promise.all([injector.getInstance(_artselector__WEBPACK_IMPORTED_MODULE_8__["RAW_PAL"]), injector.getInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_9__["GL"])]).then((_ref2) => {
      var [pal, gl] = _ref2;
      return Object(_utils_gl_textures__WEBPACK_IMPORTED_MODULE_4__["createTexture"])(256, 1, gl, {
        filter: gl.NEAREST
      }, pal, gl.RGB, 3);
    });
  });
  return _loadPalTexture.apply(this, arguments);
}

function loadShadowTable(_x4) {
  return _loadShadowTable.apply(this, arguments);
}

function _loadShadowTable() {
  _loadShadowTable = _asyncToGenerator(function* (injector) {
    var grp = yield injector.getInstance(GRP);
    return Object(_build_formats_grp__WEBPACK_IMPORTED_MODULE_3__["loadShadeTables"])(grp.get('PALETTE.DAT'));
  });
  return _loadShadowTable.apply(this, arguments);
}

function loadLookups(_x5) {
  return _loadLookups.apply(this, arguments);
}

function _loadLookups() {
  _loadLookups = _asyncToGenerator(function* (injector) {
    var grp = yield injector.getInstance(GRP);
    return Object(_build_formats_grp__WEBPACK_IMPORTED_MODULE_3__["loadPlus"])(grp.get('LOOKUP.DAT'));
  });
  return _loadLookups.apply(this, arguments);
}

function loadPluTexture(_x6) {
  return _loadPluTexture.apply(this, arguments);
}

function _loadPluTexture() {
  _loadPluTexture = _asyncToGenerator(function* (injector) {
    var [shadows, gl, lookups] = yield Promise.all([injector.getInstance(SHADOW_TABLE), injector.getInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_9__["GL"]), injector.getInstance(_artselector__WEBPACK_IMPORTED_MODULE_8__["RAW_PLUs"])]);
    var tex = new Uint8Array(256 * shadows.length * lookups.length);

    for (var i = 0; i < lookups.length; i++) {
      var lookup = lookups[i];
      var shadowed = new Uint8Array(256 * shadows.length);

      for (var s = 0; s < shadows.length; s++) {
        var shadow = shadows[s];

        for (var c = 0; c < 256; c++) {
          shadowed[s * 256 + c] = shadow[lookup[c]];
        }
      }

      tex.set(shadowed, 256 * shadows.length * i);
    }

    return Object(_utils_gl_textures__WEBPACK_IMPORTED_MODULE_4__["createTexture"])(256, shadows.length * lookups.length, gl, {
      filter: gl.NEAREST
    }, tex, gl.LUMINANCE);
  });
  return _loadPluTexture.apply(this, arguments);
}

function loadMapImpl(name) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      var res = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_15__["RESOURCES"]);
      return Object(_build_maploader__WEBPACK_IMPORTED_MODULE_1__["loadBuildMap"])(new _utils_stream__WEBPACK_IMPORTED_MODULE_16__["Stream"](yield res.get(name), true));
    });

    return function (_x7) {
      return _ref.apply(this, arguments);
    };
  }();
}

function createBoard() {
  var board = new _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["Board"]();
  board.walls = [];
  board.sectors = [];
  board.sprites = [];
  board.numwalls = 0;
  board.numsectors = 0;
  board.numsprites = 0;
  board.version = 0x0007;
  board.posx = board.posy = board.posz = board.cursectnum = board.ang = 0;
  return board;
}

function DukeImplementation() {
  var _rorLinks = new _view_boardrenderer3d__WEBPACK_IMPORTED_MODULE_13__["RorLinks"]();

  return {
    rorLinks: () => _rorLinks,

    isMirrorPic(picnum) {
      return picnum == -1;
    }

  };
}

function loadGrp(_x8) {
  return _loadGrp.apply(this, arguments);
}

function _loadGrp() {
  _loadGrp = _asyncToGenerator(function* (injector) {
    var fs = yield injector.getInstance(_fs_fs__WEBPACK_IMPORTED_MODULE_10__["FS"]);
    var grp = yield fs.get('DUKE3D.GRP');
    return new _build_formats_grp__WEBPACK_IMPORTED_MODULE_3__["GrpFile"](grp);
  });
  return _loadGrp.apply(this, arguments);
}

function getMapNames(_x9) {
  return _getMapNames.apply(this, arguments);
}

function _getMapNames() {
  _getMapNames = _asyncToGenerator(function* (injector) {
    var res = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_15__["RESOURCES"]);
    return () => res.list().then(list => list.filter(f => f.toLowerCase().endsWith('.map')));
  });
  return _getMapNames.apply(this, arguments);
}

function shadowsteps(_x10) {
  return _shadowsteps.apply(this, arguments);
}

function _shadowsteps() {
  _shadowsteps = _asyncToGenerator(function* (injector) {
    var shadows = yield injector.getInstance(SHADOW_TABLE);
    return shadows.length;
  });
  return _shadowsteps.apply(this, arguments);
}

function palswaps(_x11) {
  return _palswaps.apply(this, arguments);
}

function _palswaps() {
  _palswaps = _asyncToGenerator(function* (injector) {
    var lookups = yield injector.getInstance(_artselector__WEBPACK_IMPORTED_MODULE_8__["RAW_PLUs"]);
    return lookups.length;
  });
  return _palswaps.apply(this, arguments);
}

function PicTags(_x12) {
  return _PicTags.apply(this, arguments);
}

function _PicTags() {
  _PicTags = _asyncToGenerator(function* (injector) {
    return {
      allTags() {
        return [];
      },

      tags(id) {
        return [];
      }

    };
  });
  return _PicTags.apply(this, arguments);
}

function Resources(_x13) {
  return _Resources.apply(this, arguments);
}

function _Resources() {
  _Resources = _asyncToGenerator(function* (injector) {
    var fs = yield injector.getInstance(_fs_fs__WEBPACK_IMPORTED_MODULE_10__["FS"]);
    var grp = yield injector.getInstance(GRP);
    return {
      get: function () {
        var _get = _asyncToGenerator(function* (name) {
          var file = yield fs.get(name);
          if (file != null) return file;
          return grp.getArrayBuffer(name);
        });

        function get(_x16) {
          return _get.apply(this, arguments);
        }

        return get;
      }(),
      list: function () {
        var _list = _asyncToGenerator(function* () {
          var files = new Set(Object.keys(grp.files));
          (yield fs.list()).forEach(f => files.add(f));
          return [...files];
        });

        function list() {
          return _list.apply(this, arguments);
        }

        return list;
      }()
    };
  });
  return _Resources.apply(this, arguments);
}

function mapLoader(_x14) {
  return _mapLoader.apply(this, arguments);
}

function _mapLoader() {
  _mapLoader = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_7__["namedMessageHandler"])('load_map', /*#__PURE__*/_asyncToGenerator(function* () {
          var mapName = yield Object(_selectmap__WEBPACK_IMPORTED_MODULE_12__["showMapSelection"])(injector);
          if (!mapName) return;
          var map = yield loadMapImpl(mapName)(injector);
          bus.handle(new _edit_messages__WEBPACK_IMPORTED_MODULE_7__["LoadBoard"](map));
        })));
      });

      return function (_x17) {
        return _ref3.apply(this, arguments);
      };
    }());
  });
  return _mapLoader.apply(this, arguments);
}

function mapSaver(_x15) {
  return _mapSaver.apply(this, arguments);
}

function _mapSaver() {
  _mapSaver = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
        var fsmgr = yield injector.getInstance(_fs_manager__WEBPACK_IMPORTED_MODULE_14__["FS_MANAGER"]);
        var board = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_15__["BOARD"]);
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_7__["namedMessageHandler"])('save_map', /*#__PURE__*/_asyncToGenerator(function* () {
          fsmgr.write('newboard.map', Object(_build_maploader__WEBPACK_IMPORTED_MODULE_1__["saveBuildMap"])(board()));
        })));
      });

      return function (_x18) {
        return _ref5.apply(this, arguments);
      };
    }());
  });
  return _mapSaver.apply(this, arguments);
}

function engineApi() {
  return {
    cloneBoard: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["cloneBoard"],
    cloneWall: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["cloneWall"],
    cloneSprite: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["cloneSprite"],
    cloneSector: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["cloneSector"],
    newWall: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["newWall"],
    newSector: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["newSector"],
    newSprite: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["newSprite"],
    newBoard: _build_maploader__WEBPACK_IMPORTED_MODULE_1__["newBoard"]
  };
}

function DukeModule(module) {
  module.bindInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_9__["PARALLAX_TEXTURES"], 5);
  module.bindInstance(_apis_app__WEBPACK_IMPORTED_MODULE_15__["ENGINE_API"], engineApi());
  module.bindInstance(_view_boardrenderer3d__WEBPACK_IMPORTED_MODULE_13__["Implementation_"], DukeImplementation());
  module.bind(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["PALSWAPS"], palswaps);
  module.bind(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["SHADOWSTEPS"], shadowsteps);
  module.bind(GRP, loadGrp);
  module.bind(_buildartprovider__WEBPACK_IMPORTED_MODULE_9__["ART_FILES"], loadArtFiles);
  module.bind(_artselector__WEBPACK_IMPORTED_MODULE_8__["RAW_PAL"], loadPal);
  module.bind(_artselector__WEBPACK_IMPORTED_MODULE_8__["RAW_PLUs"], loadLookups);
  module.bind(SHADOW_TABLE, loadShadowTable);
  module.bind(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["PAL_TEXTURE"], loadPalTexture);
  module.bind(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["PLU_TEXTURE"], loadPluTexture);
  module.bind(_selectmap__WEBPACK_IMPORTED_MODULE_12__["MAP_NAMES"], getMapNames);
  module.bind(_artselector__WEBPACK_IMPORTED_MODULE_8__["PIC_TAGS"], PicTags);
  module.bindInstance(_apis_app__WEBPACK_IMPORTED_MODULE_15__["DEFAULT_BOARD"], createBoard());
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_15__["RESOURCES"], Resources);
  module.install(mapLoader);
  module.install(mapSaver);
}

/***/ }),

/***/ "./src/app/modules/fs/db.ts":
/*!**********************************!*\
  !*** ./src/app/modules/fs/db.ts ***!
  \**********************************/
/*! exports provided: StorageFs, DbFsModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StorageFs", function() { return StorageFs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DbFsModule", function() { return DbFsModule; });
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fs */ "./src/app/modules/fs/fs.ts");
/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./manager */ "./src/app/modules/fs/manager.ts");
/* harmony import */ var _mount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mount */ "./src/app/modules/fs/mount.ts");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../db */ "./src/app/modules/db.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }







function createDb(name) {
  var db = null;
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      if (db == null) {
        var storages = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_0__["STORAGES"]);
        db = yield storages(name);
      }

      return db;
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}

var fsProvider = createDb('filesystem');
var fsinfoProvider = createDb('filesystem-info');
function StorageFs(_x2) {
  return _StorageFs.apply(this, arguments);
}

function _StorageFs() {
  _StorageFs = _asyncToGenerator(function* (injector) {
    var fs = yield fsProvider(injector);
    return {
      get: function () {
        var _get = _asyncToGenerator(function* (name) {
          return fs.get(name);
        });

        function get(_x4) {
          return _get.apply(this, arguments);
        }

        return get;
      }(),
      list: function () {
        var _list = _asyncToGenerator(function* () {
          return fs.keys();
        });

        function list() {
          return _list.apply(this, arguments);
        }

        return list;
      }()
    };
  });
  return _StorageFs.apply(this, arguments);
}

function StorageFsManager(_x3) {
  return _StorageFsManager.apply(this, arguments);
}

function _StorageFsManager() {
  _StorageFsManager = _asyncToGenerator(function* (injector) {
    var fs = yield fsProvider(injector);
    var fsinfo = yield fsinfoProvider(injector);
    return {
      read: name => fs.get(name),
      write: function () {
        var _write = _asyncToGenerator(function* (name, data) {
          return yield Promise.all([fs.set(name, data), fsinfo.set(name, {
            size: data.byteLength
          })]);
        });

        function write(_x5, _x6) {
          return _write.apply(this, arguments);
        }

        return write;
      }(),
      delete: function () {
        var _delete2 = _asyncToGenerator(function* (name) {
          return yield Promise.all([fs.delete(name), fsinfo.delete(name)]);
        });

        function _delete(_x7) {
          return _delete2.apply(this, arguments);
        }

        return _delete;
      }(),
      list: () => fsinfo.keys()
    };
  });
  return _StorageFsManager.apply(this, arguments);
}

function DbFsModule(rom) {
  if (rom === void 0) {
    rom = null;
  }

  return module => {
    module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_0__["STORAGES"], _db__WEBPACK_IMPORTED_MODULE_4__["StorageDbConstructor"]);
    module.bind(_fs__WEBPACK_IMPORTED_MODULE_1__["FS"], _mount__WEBPACK_IMPORTED_MODULE_3__["MountableFs"]);
    module.bind(_mount__WEBPACK_IMPORTED_MODULE_3__["MOUNTS"], StorageFs);
    if (rom != null) module.bind(_mount__WEBPACK_IMPORTED_MODULE_3__["MOUNTS"], Object(_fs__WEBPACK_IMPORTED_MODULE_1__["UrlFs"])(rom));
    module.bind(_manager__WEBPACK_IMPORTED_MODULE_2__["FS_MANAGER"], StorageFsManager);
  };
}

/***/ }),

/***/ "./src/app/modules/fs/fs.ts":
/*!**********************************!*\
  !*** ./src/app/modules/fs/fs.ts ***!
  \**********************************/
/*! exports provided: FS, UrlFs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FS", function() { return FS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlFs", function() { return UrlFs; });
/* harmony import */ var _utils_getter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/getter */ "./src/utils/getter.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }



var FS = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('FileSystem');
function UrlFs(path) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      return {
        get: function () {
          var _get = _asyncToGenerator(function* (name) {
            return Object(_utils_getter__WEBPACK_IMPORTED_MODULE_0__["loadBin"])(path + name);
          });

          function get(_x2) {
            return _get.apply(this, arguments);
          }

          return get;
        }(),
        list: function () {
          var _list = _asyncToGenerator(function* () {
            return [];
          });

          function list() {
            return _list.apply(this, arguments);
          }

          return list;
        }()
      };
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
} // export function ZipFs(injector: Injector): Promise<FileProvider> {
//   return new Promise(resolve => {
//     const fileReader = new FileReader();
//     const win = document.getElementById("zipfile");
//     win.classList.remove('hidden');
//     win.addEventListener("dragenter", drag, false);
//     win.addEventListener("dragover", drag, false);
//     win.addEventListener("drop", (e) => {
//       e.stopPropagation();
//       e.preventDefault();
//       fileReader.readAsArrayBuffer(e.dataTransfer.files[0])
//     }, false);
//     fileReader.onload = async e => {
//       win.classList.add('hidden');
//       const zfs = await loadZip(e.target.result);
//       const files = Object.keys(zfs.files);
//       const nameMap = new Map<string, any>();
//       files.forEach(f => nameMap.set(f.toLowerCase(), zfs.file(f)));
//       resolve((name: string) => nameMap.get(name.toLowerCase()).async('arraybuffer'));
//     }
//   })
// }

/***/ }),

/***/ "./src/app/modules/fs/manager.ts":
/*!***************************************!*\
  !*** ./src/app/modules/fs/manager.ts ***!
  \***************************************/
/*! exports provided: FS_MANAGER, showFileBrowser, FileBrowserModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FS_MANAGER", function() { return FS_MANAGER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showFileBrowser", function() { return showFileBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileBrowserModule", function() { return FileBrowserModule; });
/* harmony import */ var _utils_filesave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/filesave */ "./src/utils/filesave.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_ui_renderers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/ui/renderers */ "./src/utils/ui/renderers.ts");
/* harmony import */ var _utils_ui_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/ui/ui */ "./src/utils/ui/ui.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../apis/ui */ "./src/app/apis/ui.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../edit/messages */ "./src/app/edit/messages.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }









var FS_MANAGER = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('FileSystem Manager');

class FileBrowser {
  constructor(ui, manager) {
    var _this = this;

    this.window = void 0;
    this.selected = new Set();
    this.gridModel = this.createGridModel();
    this.manager = manager;
    this.window = ui.builder.window().id('fileBrowser').title('Files').draggable(true).closeable(true).centered(true).size(600, 600).toolbar(ui.builder.toolbar().startGroup().button('icon-arrows-ccw', () => this.refreshContent()).button('icon-download', () => this.downloadSelected()).button('icon-trash', () => this.deleteSelected()).endGroup()).build();
    var win = this.window.winElement;
    Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_4__["addDragAndDrop"])(win, e => {
      var _loop = function _loop(file) {
        var fileReader = new FileReader();
        var name = file.name;
        fileReader.readAsArrayBuffer(file);

        fileReader.onload = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator(function* (e) {
            var data = e.target.result;
            yield manager.write(name, data);

            _this.refreshContent();
          });

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }();
      };

      for (var file of e.dataTransfer.files) {
        _loop(file);
      }
    });
  }

  createGridModel() {
    var columns = [_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_3__["IconTextRenderer"]];

    var item = f => {
      return {
        text: f,
        icon: this.getIcon(f),
        style: this.selected.has(f) ? "selected" : ""
      };
    };

    var self = this;
    return {
      rows() {
        return _asyncToGenerator(function* () {
          return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(yield self.manager.list()).map(f => [item(f)]);
        })();
      },

      columns() {
        return columns;
      },

      onClick(row, rowElement) {
        self.toggleItem(rowElement.elem(), row[0].text);
      }

    };
  }

  refreshContent() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var table = yield Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_3__["renderGrid"])(_this2.gridModel);

      _this2.replaceContent(table.elem());
    })();
  }

  getIcon(name) {
    if (name.toLowerCase().endsWith('.map')) return 'icon-globe';
    if (name.toLowerCase().endsWith('.art')) return 'icon-picture';
    return 'icon-doc';
  }

  replaceContent(newContent) {
    var content = this.window.contentElement.firstChild;
    if (content) this.window.contentElement.replaceChild(newContent, content);else this.window.contentElement.appendChild(newContent);
  }

  toggleItem(target, name) {
    target.classList.toggle('selected');
    if (this.selected.has(name)) this.selected.delete(name);else this.selected.add(name);
  }

  deleteSelected() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      for (var file of _this3.selected) {
        yield _this3.manager.delete(file);

        _this3.selected.delete(file);
      }

      _this3.refreshContent();
    })();
  }

  downloadSelected() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      for (var file of _this4.selected) {
        Object(_utils_filesave__WEBPACK_IMPORTED_MODULE_0__["saveAs"])(yield _this4.manager.read(file), file);

        _this4.selected.delete(file);
      }

      _this4.refreshContent();
    })();
  }

  show() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      yield _this5.refreshContent();

      _this5.window.show();
    })();
  }

}

var browser;

function getFileBrowser(_x2) {
  return _getFileBrowser.apply(this, arguments);
}

function _getFileBrowser() {
  _getFileBrowser = _asyncToGenerator(function* (injector) {
    if (browser == null) browser = yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_1__["create"])(injector, FileBrowser, _apis_ui__WEBPACK_IMPORTED_MODULE_6__["UI"], FS_MANAGER);
    return browser;
  });
  return _getFileBrowser.apply(this, arguments);
}

function showFileBrowser(_x3) {
  return _showFileBrowser.apply(this, arguments);
}

function _showFileBrowser() {
  _showFileBrowser = _asyncToGenerator(function* (injector) {
    var browser = yield getFileBrowser(injector);
    browser.show();
  });
  return _showFileBrowser.apply(this, arguments);
}

function FileBrowserModule(_x4) {
  return _FileBrowserModule.apply(this, arguments);
}

function _FileBrowserModule() {
  _FileBrowserModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_5__["BUS"]);
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_7__["namedMessageHandler"])('show_files', () => showFileBrowser(injector)));
      });

      return function (_x5) {
        return _ref2.apply(this, arguments);
      };
    }());
  });
  return _FileBrowserModule.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/fs/mount.ts":
/*!*************************************!*\
  !*** ./src/app/modules/fs/mount.ts ***!
  \*************************************/
/*! exports provided: MOUNTS, MountableFs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNTS", function() { return MOUNTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MountableFs", function() { return MountableFs; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var MOUNTS = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]("Mounts", true);
function MountableFs(_x) {
  return _MountableFs.apply(this, arguments);
}

function _MountableFs() {
  _MountableFs = _asyncToGenerator(function* (injector) {
    return {
      get: function () {
        var _get = _asyncToGenerator(function* (name) {
          var mounts = yield injector.getInstance(MOUNTS);

          for (var mount of mounts) {
            var file = yield mount.get(name);
            if (file) return file;
          }

          return null;
        });

        function get(_x2) {
          return _get.apply(this, arguments);
        }

        return get;
      }(),
      list: function () {
        var _list = _asyncToGenerator(function* () {
          var mounts = yield injector.getInstance(MOUNTS);
          var files = new Set();

          for (var mount of mounts) {
            var _list2 = yield mount.list();

            _list2.forEach(f => files.add(f));
          }

          return [...files];
        });

        function list() {
          return _list.apply(this, arguments);
        }

        return list;
      }()
    };
  });
  return _MountableFs.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/common.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/geometry/builders/common.ts ***!
  \*****************************************************/
/*! exports provided: GRID_SECTOR_MATRIX, WallGridType, createGridWallMatrix, buildCeilingHinge, buildFloorHinge, text, writeText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_SECTOR_MATRIX", function() { return GRID_SECTOR_MATRIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallGridType", function() { return WallGridType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGridWallMatrix", function() { return createGridWallMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildCeilingHinge", function() { return buildCeilingHinge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildFloorHinge", function() { return buildFloorHinge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeText", function() { return writeText; });
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_tiler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/tiler */ "./src/utils/tiler.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../build/board/mutations/internal */ "./src/build/board/mutations/internal.ts");






var GRID_SECTOR_MATRIX = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].identity(GRID_SECTOR_MATRIX);
_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].rotateX(GRID_SECTOR_MATRIX, GRID_SECTOR_MATRIX, -Math.PI / 2);
var WallGridType;

(function (WallGridType) {
  WallGridType[WallGridType["VOID"] = 0] = "VOID";
  WallGridType[WallGridType["BOT"] = 1] = "BOT";
  WallGridType[WallGridType["TOP"] = 2] = "TOP";
  WallGridType[WallGridType["MID"] = 3] = "MID";
})(WallGridType || (WallGridType = {}));

function getBaseZ(type, wall, sector, nextsector) {
  if (nextsector == undefined) return wall.cstat.alignBottom ? sector.floorz : sector.ceilingz;

  switch (type) {
    case WallGridType.VOID:
      return wall.cstat.alignBottom ? sector.floorz : sector.ceilingz;

    case WallGridType.BOT:
      return wall.cstat.alignBottom ? sector.ceilingz : nextsector.floorz;

    case WallGridType.TOP:
      return wall.cstat.alignBottom ? sector.ceilingz : nextsector.ceilingz;

    case WallGridType.MID:
      return wall.cstat.alignBottom ? Math.min(sector.floorz, nextsector.floorz) : Math.max(sector.ceilingz, nextsector.ceilingz);
  }
}

var tmp = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["vec4"].create();
var texMat = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
function createGridWallMatrix(board, id, type) {
  var wall1 = board.walls[id];
  var wall2 = board.walls[wall1.point2];
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var sector = board.sectors[Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["sectorOfWall"])(board, id)];
  var nextsector = board.sectors[wall1.nextsector];
  var zbase = getBaseZ(type, wall1, sector, nextsector);
  var wlen = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_4__["walllen"])(board, id);
  var sx = wall1.xrepeat * _build_board_mutations_internal__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_REPEAT_RATE"] / wlen;
  var sy = wall1.yrepeat / 8;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["vec4"].set(tmp, sx, sy, 1, 1);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].scale(texMat, texMat, tmp);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].rotateY(texMat, texMat, -Math.atan2(-dy, dx));
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["vec4"].set(tmp, -wall1.x, -zbase / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"], -wall1.y, 0);
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].translate(texMat, texMat, tmp);
}
function buildCeilingHinge(ctx, sectorId, builder) {
  return prepareHinge(ctx, sectorId, true, builder);
}
function buildFloorHinge(ctx, sectorId, builder) {
  return prepareHinge(ctx, sectorId, false, builder);
}

function prepareHinge(ctx, sectorId, ceiling, builder) {
  var board = ctx.board();
  builder.mode = WebGLRenderingContext.TRIANGLES;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["vec4"].set(builder.color, 0.7, 0.7, 0.7, 0.7);
  var size = 128;
  var buff = builder.buff;
  buff.allocate(6, 24);
  var sec = board.sectors[sectorId];
  var wall1 = board.walls[sec.wallptr];
  var wall2 = board.walls[wall1.point2];
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var dl = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["len2d"])(dx, dy);
  var x = wall1.x + dx / 2;
  var y = wall1.y + dy / 2;
  dx /= dl;
  dy /= dl;
  var z = (ceiling ? sec.ceilingz : sec.floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var dz = ceiling ? -size / 2 : size / 2;
  var x1 = x - dx * size;
  var y1 = y - dy * size;
  var x2 = x + dx * size;
  var y2 = y + dy * size;
  var x3 = x1 - dy * (size / 2);
  var y3 = y1 + dx * (size / 2);
  var x4 = x2 - dy * (size / 2);
  var y4 = y2 + dx * (size / 2);
  var heinum = ceiling ? sec.ceilingheinum : sec.floorheinum;
  var s = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["slope"])(board, sectorId, x3, y3, heinum) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  buff.writePos(0, x1, z, y1);
  buff.writePos(1, x2, z, y2);
  buff.writePos(2, x3, z + s, y3);
  buff.writePos(3, x4, z + s, y4);
  buff.writePos(4, x1, z + dz, y1);
  buff.writePos(5, x2, z + dz, y2);
  buff.writeQuad(0, 0, 1, 3, 2);
  buff.writeQuad(6, 2, 3, 1, 0);
  buff.writeQuad(12, 0, 1, 5, 4);
  buff.writeQuad(18, 4, 5, 1, 0);
  return builder;
}

function text(builder, text, posx, posy, posz, charW, charH, tex) {
  builder.tex = tex;
  var buff = builder.buff;
  buff.allocate((text.length * 2 + 3) * 4, (text.length * 2 + 3) * 6);
  writeText(buff, 0, text, charW, charH, posx, posy, posz);
  return builder;
}
function writeText(buff, bufferOff, text, charW, charH, posx, posy, posz) {
  var tiler = new _utils_tiler__WEBPACK_IMPORTED_MODULE_3__["Tiler"]();

  for (var i = 0; i < text.length; i++) {
    tiler.put(i + 1, 1, text.charCodeAt(i)).put(i + 1, 0, 3);
  }

  tiler.put(0, 0, 2).put(0, 1, 0).put(text.length + 1, 1, 1);
  var vtxoff = bufferOff * 4;
  var idxoff = bufferOff * 6;
  var charTexSize = 1 / 16;
  var centerXOff = -charW * (text.length / 2 + 1);
  var centerYOff = charH / 2;
  tiler.tile((x, y, tileId) => {
    var row = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(tileId / 16) * charTexSize;
    var column = tileId % 16 * charTexSize;
    var xoff = x * charW + centerXOff;
    var yoff = -y * charH + centerYOff;
    buff.writePos(vtxoff + 0, posx, posz, posy);
    buff.writePos(vtxoff + 1, posx, posz, posy);
    buff.writePos(vtxoff + 2, posx, posz, posy);
    buff.writePos(vtxoff + 3, posx, posz, posy);
    buff.writeTcLighting(vtxoff + 0, column, row + charTexSize);
    buff.writeTcLighting(vtxoff + 1, column, row);
    buff.writeTcLighting(vtxoff + 2, column + charTexSize, row);
    buff.writeTcLighting(vtxoff + 3, column + charTexSize, row + charTexSize);
    buff.writeNormal(vtxoff + 0, xoff, yoff, 0);
    buff.writeNormal(vtxoff + 1, xoff, yoff + charH, 0);
    buff.writeNormal(vtxoff + 2, xoff + charW, yoff + charH, 0);
    buff.writeNormal(vtxoff + 3, xoff + charW, yoff, 0);
    buff.writeQuad(idxoff, vtxoff + 0, vtxoff + 1, vtxoff + 2, vtxoff + 3);
    vtxoff += 4;
    idxoff += 6;
  });
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/sector.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/geometry/builders/sector.ts ***!
  \*****************************************************/
/*! exports provided: SectorBuilder, triangulate, updateSector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorBuilder", function() { return SectorBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangulate", function() { return triangulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSector", function() { return updateSector; });
/* harmony import */ var _build_board_loops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/loops */ "./src/build/board/loops.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");






class SectorBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_5__["Builders"] {
  constructor(factory, ceiling, floor) {
    if (ceiling === void 0) {
      ceiling = factory.solid('sector');
    }

    if (floor === void 0) {
      floor = factory.solid('sector');
    }

    super([ceiling, floor]);
    this.ceiling = ceiling;
    this.floor = floor;
  }

}

function applySectorTextureTransform(board, sectorId, ceiling, info, texMat) {
  var sector = board.sectors[sectorId];
  var xpan = (ceiling ? sector.ceilingxpanning : sector.floorxpanning) / 256.0;
  var ypan = (ceiling ? sector.ceilingypanning : sector.floorypanning) / 256.0;
  var stats = ceiling ? sector.ceilingstat : sector.floorstat;
  var scale = stats.doubleSmooshiness ? 8.0 : 16.0;
  var parallaxscale = stats.parallaxing ? 6.0 : 1.0;
  var tcscalex = (stats.xflip ? -1.0 : 1.0) / (info.w * scale * parallaxscale);
  var tcscaley = (stats.yflip ? -1.0 : 1.0) / (info.h * scale);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [xpan, ypan, 0, 0]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [tcscalex, -tcscaley, 1, 1]);

  if (stats.swapXY) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [-1, -1, 1, 1]);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateZ(texMat, texMat, Math.PI / 2);
  }

  if (stats.alignToFirstWall) {
    var w1 = board.walls[sector.wallptr];
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateZ(texMat, texMat, Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["getFirstWallAngle"])(board, sectorId));
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [-w1.x, -w1.y, 0, 0]);
  }

  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateX(texMat, texMat, -Math.PI / 2);
}

var tc_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].create();

function fillBuffersForSectorNormal(ceil, board, sectorId, buff, vtxs, vidxs, normal, t) {
  var sector = board.sectors[sectorId];
  var heinum = ceil ? sector.ceilingheinum : sector.floorheinum;
  var shade = ceil ? sector.ceilingshade : sector.floorshade;
  var pal = ceil ? sector.ceilingpal : sector.floorpal;
  var z = ceil ? sector.ceilingz : sector.floorz;
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["createSlopeCalculator"])(board, sectorId);

  for (var i = 0; i < vtxs.length; i++) {
    var vx = vtxs[i][0];
    var vy = vtxs[i][1];
    var vz = (slope(vx, vy, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
    buff.writePos(i, vx, vz, vy);
    buff.writeNormal(i, normal[0], normal[1], normal[2]);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc_, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc_, vx, vz, vy, 1), t);
    buff.writeTcLighting(i, tc_[0], tc_[1], pal, shade);
  }

  for (var _i = 0; _i < vidxs.length; _i += 3) {
    if (ceil) {
      buff.writeTriangle(_i, vidxs[_i + 0], vidxs[_i + 1], vidxs[_i + 2]);
    } else {
      buff.writeTriangle(_i, vidxs[_i + 2], vidxs[_i + 1], vidxs[_i + 0]);
    }
  }
}

function compress(triangles) {
  var vtxidx = [];
  var vtxset = [];
  var indexes = [];
  Object(_utils_iter__WEBPACK_IMPORTED_MODULE_4__["iter"])(triangles).forEach((_ref) => {
    var [x0, y0] = _ref;
    var vtx0 = x0 + "," + y0;
    var idx = vtxidx.indexOf(vtx0);

    if (idx == -1) {
      idx = vtxset.length;
      vtxidx.push(vtx0);
      vtxset.push([x0, y0]);
    }

    indexes.push(idx);
  });
  return [vtxset, indexes];
}

var trapCmp = (lh, rh) => {
  return lh.x0 + lh.x1 - rh.x0 - rh.x1;
};

function triangulate(board, sectorId) {
  var secy = [...new Set(Object(_utils_iter__WEBPACK_IMPORTED_MODULE_4__["iter"])(Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["sectorWalls"])(board, sectorId)).map(w => board.walls[w].y).collect().sort((l, r) => l - r))];
  var zoids = new _utils_collections__WEBPACK_IMPORTED_MODULE_3__["Deck"]();

  for (var [sy0, sy1] of Object(_utils_iter__WEBPACK_IMPORTED_MODULE_4__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_3__["range"])(0, secy.length - 1)).map(i => [secy[i], secy[i + 1]])) {
    var ts = new _utils_collections__WEBPACK_IMPORTED_MODULE_3__["Deck"]();

    for (var [w0, w1] of Object(_utils_iter__WEBPACK_IMPORTED_MODULE_4__["iter"])(Object(_build_board_loops__WEBPACK_IMPORTED_MODULE_0__["sectorWalls"])(board, sectorId)).map(w => [board.walls[w], board.walls[board.walls[w].point2]])) {
      var [x0, y0, x1, y1] = w0.y > w1.y ? [w1.x, w1.y, w0.x, w0.y] : [w0.x, w0.y, w1.x, w1.y];
      if (y0 >= sy1 || y1 <= sy0) continue;
      if (y0 < sy0) x0 = (sy0 - w0.y) * (w1.x - w0.x) / (w1.y - w0.y) + w0.x;
      if (y1 > sy1) x1 = (sy1 - w0.y) * (w1.x - w0.x) / (w1.y - w0.y) + w0.x;
      ts.push({
        x0,
        x1,
        w: w0
      });
    }

    var traps = [...ts].sort(trapCmp);
    var j = 0;

    for (var i = 0; i < traps.length; i = j + 1) {
      j = i + 1;
      var trapi = traps[i];
      var trapi1 = traps[i + 1];
      if (trapi1.x0 <= trapi.x0 && trapi1.x1 <= trapi.x1) continue;

      while (j + 2 < traps.length && traps[j + 1].x0 <= traps[j].x0 && traps[j + 1].x1 <= traps[j].x1) {
        j += 2;
      }

      var _x = trapi.x0;
      var _x2 = traps[j].x0;
      var x2 = traps[j].x1;
      var x3 = trapi.x1;
      var _y = sy0;
      var _y2 = sy1;
      var _w = trapi.w;
      var _w2 = traps[j].w;
      zoids.push({
        x: [_x, _x2, x2, x3],
        y: [_y, _y2],
        w: [_w, _w2]
      });
    }
  }

  var triangles = [];

  for (var _i2 = 0; _i2 < zoids.length(); _i2++) {
    var pol = new _utils_collections__WEBPACK_IMPORTED_MODULE_3__["Deck"]();

    for (var _j = 0; _j < 4; _j++) {
      var polx = zoids.get(_i2).x[_j];

      var poly = zoids.get(_i2).y[_j >> 1];

      if (pol.length() == 0 || polx != Object(_utils_collections__WEBPACK_IMPORTED_MODULE_3__["last"])(pol).x || poly != Object(_utils_collections__WEBPACK_IMPORTED_MODULE_3__["last"])(pol).y) pol.push({
        x: polx,
        y: poly
      });
    }

    if (pol.length() < 3) continue;
    var fp0x = pol.get(0).x;
    var fp0y = pol.get(0).y;

    for (var _j2 = 2; _j2 < pol.length(); _j2++) {
      var fp1x = pol.get(_j2).x;
      var fp1y = pol.get(_j2).y;
      var fp2x = pol.get(_j2 - 1).x;
      var fp2y = pol.get(_j2 - 1).y;
      triangles.push([fp2x, fp2y]);
      triangles.push([fp1x, fp1y]);
      triangles.push([fp0x, fp0y]);
    }
  }

  return compress(triangles);
}

function fillBuffersForSector(ceil, board, s, builder, normal, t) {
  var [vtxs, vidxs] = triangulate(board, s);
  var d = ceil ? builder.ceiling : builder.floor;
  d.buff.allocate(vtxs.length, vidxs.length);
  fillBuffersForSectorNormal(ceil, board, s, d.buff, vtxs, vidxs, normal, t);
}

var sectorNormal_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var texMat_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
function updateSector(ctx, sectorId, builder) {
  builder = builder == null ? new SectorBuilder(ctx.factory) : builder;
  var board = ctx.board();
  var art = ctx.art;
  var sector = board.sectors[sectorId];
  var ceilinginfo = art.getInfo(sector.ceilingpicnum);
  applySectorTextureTransform(board, sectorId, true, ceilinginfo, texMat_);
  fillBuffersForSector(true, board, sectorId, builder, Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["sectorNormal"])(sectorNormal_, board, sectorId, true), texMat_);
  builder.ceiling.tex = sector.ceilingstat.parallaxing ? art.getParallaxTexture(sector.ceilingpicnum) : art.get(sector.ceilingpicnum);
  builder.ceiling.parallax = sector.ceilingstat.parallaxing;
  var floorinfo = art.getInfo(sector.floorpicnum);
  applySectorTextureTransform(board, sectorId, false, floorinfo, texMat_);
  fillBuffersForSector(false, board, sectorId, builder, Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["sectorNormal"])(sectorNormal_, board, sectorId, false), texMat_);
  builder.floor.tex = sector.floorstat.parallaxing ? art.getParallaxTexture(sector.floorpicnum) : art.get(sector.floorpicnum);
  builder.floor.parallax = sector.floorstat.parallaxing;
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/sectorcluster.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/geometry/builders/sectorcluster.ts ***!
  \************************************************************/
/*! exports provided: ClusterBuilder, updateCluster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClusterBuilder", function() { return ClusterBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateCluster", function() { return updateCluster; });
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");

class ClusterBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_0__["Builders"] {
  constructor(factory, solids, sprites, transSprites, transSolids) {
    if (solids === void 0) {
      solids = factory.solid('cluster');
    }

    if (sprites === void 0) {
      sprites = null;
    }

    if (transSprites === void 0) {
      transSprites = null;
    }

    if (transSolids === void 0) {
      transSolids = null;
    }

    super([]);
    this.solids = solids;
    this.sprites = sprites;
    this.transSprites = transSprites;
    this.transSolids = transSolids;
  }

}
function updateCluster(ctx, sectorId, builder) {
  return null;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/sectorhelper.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/geometry/builders/sectorhelper.ts ***!
  \***********************************************************/
/*! exports provided: SectorHelperBuilder, updateSectorHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorHelperBuilder", function() { return SectorHelperBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSectorHelper", function() { return updateSectorHelper; });
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ "./src/app/modules/geometry/builders/common.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../build/board/query */ "./src/build/board/query.ts");






class SectorHelperBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_1__["Builders"] {
  constructor(factory, ceilpoints, ceilwire, ceilhinge, ceilgrid, floorpoints, floorwire, floorhinge, floorgrid, ceiling, floor) {
    if (ceilpoints === void 0) {
      ceilpoints = factory.pointSprite('helper');
    }

    if (ceilwire === void 0) {
      ceilwire = factory.wireframe('helper');
    }

    if (ceilhinge === void 0) {
      ceilhinge = factory.wireframe('helper');
    }

    if (ceilgrid === void 0) {
      ceilgrid = factory.grid('helper').knd(_apis_renderable__WEBPACK_IMPORTED_MODULE_2__["HELPER_GRID"]);
    }

    if (floorpoints === void 0) {
      floorpoints = factory.pointSprite('helper');
    }

    if (floorwire === void 0) {
      floorwire = factory.wireframe('helper');
    }

    if (floorhinge === void 0) {
      floorhinge = factory.wireframe('helper');
    }

    if (floorgrid === void 0) {
      floorgrid = factory.grid('helper').knd(_apis_renderable__WEBPACK_IMPORTED_MODULE_2__["HELPER_GRID"]);
    }

    if (ceiling === void 0) {
      ceiling = new _apis_renderable__WEBPACK_IMPORTED_MODULE_2__["Renderables"]([ceilpoints, ceilwire, ceilhinge, ceilgrid]);
    }

    if (floor === void 0) {
      floor = new _apis_renderable__WEBPACK_IMPORTED_MODULE_2__["Renderables"]([floorpoints, floorwire, floorhinge, floorgrid]);
    }

    super([ceilpoints, ceilwire, ceilhinge, ceilgrid, floorpoints, floorwire, floorhinge, floorgrid]);
    this.ceilpoints = ceilpoints;
    this.ceilwire = ceilwire;
    this.ceilhinge = ceilhinge;
    this.ceilgrid = ceilgrid;
    this.floorpoints = floorpoints;
    this.floorwire = floorwire;
    this.floorhinge = floorhinge;
    this.floorgrid = floorgrid;
    this.ceiling = ceiling;
    this.floor = floor;
  }

}

function fillBufferForWallPoint(offset, board, wallId, buff, d, z) {
  var wall = board.walls[wallId];
  var vtxOff = offset * 4;
  buff.writePos(vtxOff + 0, wall.x, z, wall.y);
  buff.writePos(vtxOff + 1, wall.x, z, wall.y);
  buff.writePos(vtxOff + 2, wall.x, z, wall.y);
  buff.writePos(vtxOff + 3, wall.x, z, wall.y);
  buff.writeNormal(vtxOff + 0, -d, d, 0);
  buff.writeNormal(vtxOff + 1, d, d, 0);
  buff.writeNormal(vtxOff + 2, d, -d, 0);
  buff.writeNormal(vtxOff + 3, -d, -d, 0);
  buff.writeTcLighting(vtxOff + 0, 0, 0);
  buff.writeTcLighting(vtxOff + 1, 1, 0);
  buff.writeTcLighting(vtxOff + 2, 1, 1);
  buff.writeTcLighting(vtxOff + 3, 0, 1);
  buff.writeQuad(offset * 6, vtxOff, vtxOff + 1, vtxOff + 2, vtxOff + 3);
}

function addWallPoint(offset, builder, ctx, ceiling, wallId, d) {
  var board = ctx.board();
  var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_5__["sectorOfWall"])(board, wallId);
  var sec = board.sectors[s];
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["createSlopeCalculator"])(board, s);
  var h = ceiling ? sec.ceilingheinum : sec.floorheinum;
  var z = ceiling ? sec.ceilingz : sec.floorz;
  var wall = board.walls[wallId];
  var zz = (slope(wall.x, wall.y, h) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  fillBufferForWallPoint(offset, board, wallId, builder.buff, d, zz);
}

function fillBuffersForSectorWireframe(s, sec, heinum, z, board, builder) {
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["createSlopeCalculator"])(board, s);
  var buff = builder.buff;
  buff.allocate(sec.wallnum, sec.wallnum * 2);
  var fw = sec.wallptr;
  var off = 0;

  for (var w = 0; w < sec.wallnum; w++) {
    var wid = sec.wallptr + w;
    var wall = board.walls[wid];
    var vx = wall.x;
    var vy = wall.y;
    var vz = (slope(vx, vy, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
    buff.writePos(w, vx, vz, vy);

    if (fw != wid) {
      off = buff.writeLine(off, w - 1, w);
    }

    if (wall.point2 == fw) {
      off = buff.writeLine(off, w, fw - sec.wallptr);
      fw = wid + 1;
    }
  }
}

function updateSectorHelper(cache, ctx, secId, builder) {
  builder = builder == null ? new SectorHelperBuilder(ctx.factory) : builder;
  var pointTex = ctx.art.get(-1);
  var board = ctx.board();
  builder.ceilpoints.tex = pointTex;
  builder.floorpoints.tex = pointTex;
  var sec = board.sectors[secId];
  var wallnum = sec.wallnum;
  builder.ceilpoints.buff.allocate(wallnum * 4, wallnum * 6);
  builder.floorpoints.buff.allocate(wallnum * 4, wallnum * 6);

  for (var i = 0; i < wallnum; i++) {
    var w = sec.wallptr + i;
    addWallPoint(i, builder.ceilpoints, ctx, true, w, 2.5);
    addWallPoint(i, builder.floorpoints, ctx, false, w, 2.5);
  }

  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec4"].set(builder.ceilwire.color, 1, 1, 1, -100);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec4"].set(builder.floorwire.color, 1, 1, 1, -100);
  fillBuffersForSectorWireframe(secId, sec, sec.ceilingheinum, sec.ceilingz, board, builder.ceilwire);
  fillBuffersForSectorWireframe(secId, sec, sec.floorheinum, sec.floorz, board, builder.floorwire);
  Object(_common__WEBPACK_IMPORTED_MODULE_3__["buildCeilingHinge"])(ctx, secId, builder.ceilhinge);
  Object(_common__WEBPACK_IMPORTED_MODULE_3__["buildFloorHinge"])(ctx, secId, builder.floorhinge);
  var sectorRenderable = cache.sector(secId);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["mat4"].copy(builder.ceilgrid.gridTexMat, _common__WEBPACK_IMPORTED_MODULE_3__["GRID_SECTOR_MATRIX"]);
  builder.ceilgrid.solid = sectorRenderable.ceiling;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["mat4"].copy(builder.floorgrid.gridTexMat, _common__WEBPACK_IMPORTED_MODULE_3__["GRID_SECTOR_MATRIX"]);
  builder.floorgrid.solid = sectorRenderable.floor;
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/selected.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/geometry/builders/selected.ts ***!
  \*******************************************************/
/*! exports provided: SectorSelectedBuilder, WallSelectedBuilder, updateSectorSelected, updateWallSelected */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorSelectedBuilder", function() { return SectorSelectedBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallSelectedBuilder", function() { return WallSelectedBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSectorSelected", function() { return updateSectorSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWallSelected", function() { return updateWallSelected; });
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");

class SectorSelectedBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_0__["Builders"] {
  constructor(factory, ceiling, floor) {
    if (ceiling === void 0) {
      ceiling = factory.flat('');
    }

    if (floor === void 0) {
      floor = factory.flat('');
    }

    super([ceiling, floor]);
    this.ceiling = ceiling;
    this.floor = floor;
  }

}
class WallSelectedBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_0__["Builders"] {
  constructor(factory, top, mid, bot) {
    if (top === void 0) {
      top = factory.flat('');
    }

    if (mid === void 0) {
      mid = factory.flat('');
    }

    if (bot === void 0) {
      bot = factory.flat('');
    }

    super([top, mid, bot]);
    this.top = top;
    this.mid = mid;
    this.bot = bot;
  }

}
function updateSectorSelected(cache, ctx, id, builder) {
  builder = builder == null ? new SectorSelectedBuilder(ctx.factory) : builder;
  var sector = cache.sector(id);
  builder.ceiling.solid = sector.ceiling;
  builder.floor.solid = sector.floor;
  return builder;
}
function updateWallSelected(cache, ctx, id, builder) {
  builder = builder == null ? new WallSelectedBuilder(ctx.factory) : builder;
  var wall = cache.wall(id);
  builder.top.solid = wall.top;
  builder.mid.solid = wall.mid;
  builder.bot.solid = wall.bot;
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/setups.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/geometry/builders/setups.ts ***!
  \*****************************************************/
/*! exports provided: GenericBufferSetup, BufferSetup, SolidSetup, GridSetup, WireframeSetup, PointSpriteSetup, BufferRenderable, hash */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GenericBufferSetup", function() { return GenericBufferSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferSetup", function() { return BufferSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidSetup", function() { return SolidSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridSetup", function() { return GridSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeSetup", function() { return WireframeSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSpriteSetup", function() { return PointSpriteSetup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferRenderable", function() { return BufferRenderable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_gl_stategl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/gl/stategl */ "./src/utils/gl/stategl.ts");


class GenericBufferSetup {
  constructor(state) {
    this.values = new _utils_collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.buff = void 0;
    this.offset = void 0;
    this.size = void 0;
    this.mode = void 0;
    this.shaderIdx = void 0;
    this.aIndexIdx = void 0;
    this.aPosIdx = void 0;
    this.shaderIdx = this.register('shader', state);
    this.aIndexIdx = this.register('aIndex', state);
    this.aPosIdx = this.register('aPos', state);
  }

  register(name, state) {
    this.values.push(state.getState(name));
    var valueIdx = this.values.length();
    this.values.push(null);
    return valueIdx;
  }

  createDrawCall(kind) {
    var hint = hash(this.values[this.shaderIdx], this.buff, this.textureHint(), this.offset);
    return new _utils_gl_stategl__WEBPACK_IMPORTED_MODULE_1__["DrawCall"]([...this.values], this.buff, this.offset, this.size, this.mode, hint, kind);
  }

  textureHint() {
    return null;
  }

  shader(shader) {
    this.values.set(this.shaderIdx, shader);
    return this;
  }

  drawMode(mode) {
    this.mode = mode;
    return this;
  }

  buffer(buffer) {
    this.values.set(this.aIndexIdx, buffer.getIdxBuffer());
    this.values.set(this.aPosIdx, buffer.getPosBuffer());
    var pointer = buffer.get();
    this.buff = pointer.buffer;
    this.offset = pointer.idx.offset;
    this.size = buffer.getSize();
    return this;
  }

}
class BufferSetup extends GenericBufferSetup {
  constructor(state) {
    super(state);
    this.aNormIdx = void 0;
    this.aTcps = void 0;
    this.aNormIdx = this.register('aNorm', state);
    this.aTcps = this.register('aTcps', state);
  }

  buffer(buffer) {
    super.buffer(buffer);
    this.values.set(this.aNormIdx, buffer.getNormBuffer());
    this.values.set(this.aTcps, buffer.getTexCoordBuffer());
    return this;
  }

}
class SolidSetup extends BufferSetup {
  constructor(state) {
    super(state);
    this.baseIdx = void 0;
    this.colorIdx = void 0;
    this.baseIdx = this.register('base', state);
    this.colorIdx = this.register('color', state);
  }

  base(tex) {
    this.values.set(this.baseIdx, tex);
    return this;
  }

  color(color) {
    this.values.set(this.colorIdx, color);
    return this;
  }

  textureHint() {
    return this.values.get(this.baseIdx);
  }

}
class GridSetup extends BufferSetup {
  constructor(state) {
    super(state);
    this.GTIdx = void 0;
    this.gridIdx = void 0;
    this.GTIdx = this.register('GT', state);
    this.gridIdx = this.register('grid', state);
  }

  grid(grid) {
    this.values.set(this.GTIdx, grid);
    return this;
  }

  gridSettings(settings) {
    this.values.set(this.gridIdx, settings);
    return this;
  }

}
class WireframeSetup extends BufferSetup {
  constructor(state) {
    super(state);
    this.colorIdx = void 0;
    this.colorIdx = this.register('color', state);
  }

  color(color) {
    this.values.set(this.colorIdx, color);
    return this;
  }

}
class PointSpriteSetup extends BufferSetup {
  constructor(state) {
    super(state);
    this.baseIdx = void 0;
    this.colorIdx = void 0;
    this.baseIdx = this.register('base', state);
    this.colorIdx = this.register('color', state);
  }

  base(tex) {
    this.values.set(this.baseIdx, tex);
    return this;
  }

  color(color) {
    this.values.set(this.colorIdx, color);
    return this;
  }

  textureHint() {
    return this.values.get(this.baseIdx);
  }

}
class BufferRenderable {
  constructor(setup) {
    this.mode = WebGLRenderingContext.TRIANGLES;
    this.cachedDrawCall = void 0;
    this.kind = 0;
    this.setup = setup;
  }

  drawCall(consumer) {
    if (this.buff.getSize() == 0) return;

    if (this.cachedDrawCall == null) {
      this.setup.buffer(this.buff).drawMode(this.mode);
      this.applySetup(this.setup);
      this.cachedDrawCall = this.setup.createDrawCall(this.kind);
    }

    consumer(this.cachedDrawCall);
  }

  needToRebuild() {
    this.cachedDrawCall = null;
  }

  knd(kind) {
    this.kind = kind;
    return this;
  }

  get() {
    return this;
  }

}
var textureMap = new Map();
var bufferMap = new Map();
var shaderMap = new Map();
function hash(sh, buff, tex, offset) {
  var shader = shaderMap.get(sh);

  if (shader == undefined) {
    shader = shaderMap.size;
    shaderMap.set(sh, shader);
  }

  var texture = textureMap.get(tex);

  if (texture == undefined) {
    texture = textureMap.size;
    textureMap.set(tex, texture);
  }

  var buffer = bufferMap.get(buff);

  if (buffer == undefined) {
    buffer = bufferMap.size;
    bufferMap.set(buff, buffer);
  }

  return offset + (texture << 16) + (buffer << 24) + (shader << 28);
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/sprite.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/geometry/builders/sprite.ts ***!
  \*****************************************************/
/*! exports provided: updateSprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSprite", function() { return updateSprite; });
/* harmony import */ var _build_board_structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common */ "./src/app/modules/geometry/common.ts");





function normals(n) {
  return [n[0], n[1], n[2], n[0], n[1], n[2], n[0], n[1], n[2], n[0], n[1], n[2]];
}

function writePos(buff, c) {
  buff.writePos(0, c[0], c[2], c[1]);
  buff.writePos(1, c[3], c[5], c[4]);
  buff.writePos(2, c[6], c[8], c[7]);
  buff.writePos(3, c[9], c[11], c[10]);
}

var tc_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].create();

function writeTransformTc(buff, t, c, pal, shade) {
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc_, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc_, c[0], c[2], c[1], 1), t);
  buff.writeTcLighting(0, tc_[0], tc_[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc_, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc_, c[3], c[5], c[4], 1), t);
  buff.writeTcLighting(1, tc_[0], tc_[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc_, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc_, c[6], c[8], c[7], 1), t);
  buff.writeTcLighting(2, tc_[0], tc_[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc_, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc_, c[9], c[11], c[10], 1), t);
  buff.writeTcLighting(3, tc_[0], tc_[1], pal, shade);
}

function writeTc(buff, t, pal, shade) {
  buff.writeTcLighting(0, t[0], t[1], pal, shade);
  buff.writeTcLighting(1, t[2], t[3], pal, shade);
  buff.writeTcLighting(2, t[4], t[5], pal, shade);
  buff.writeTcLighting(3, t[6], t[7], pal, shade);
}

function writeNormal(buff, n) {
  buff.writeNormal(0, n[0], n[1], n[2]);
  buff.writeNormal(1, n[3], n[4], n[5]);
  buff.writeNormal(2, n[6], n[7], n[8]);
  buff.writeNormal(3, n[9], n[10], n[11]);
}

function genQuad(c, n, t, pal, shade, buff, onesided) {
  if (onesided === void 0) {
    onesided = 1;
  }

  buff.allocate(4, onesided ? 6 : 12);
  writePos(buff, c);
  writeTransformTc(buff, t, c, pal, shade);
  writeNormal(buff, n);
  buff.writeQuad(0, 0, 1, 2, 3);
  if (!onesided) buff.writeQuad(6, 3, 2, 1, 0);
}

var texMat_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();

function fillbuffersForWallSprite(x, y, z, xo, yo, hw, hh, ang, xf, yf, onesided, pal, shade, renderable) {
  var dx = Math.sin(ang) * hw;
  var dy = Math.cos(ang) * hw;
  var xs = xf ? -1.0 : 1.0;
  var ys = yf ? -1.0 : 1.0;
  var texMat = texMat_;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [xs / (hw * 2), -ys / (hh * 2), 1, 1]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateY(texMat, texMat, -ang - Math.PI / 2);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [-x - xs * dx, -z - ys * hh - yo, -y - xs * dy, 0]);
  genQuad([x - dx, y - dy, z - hh + yo, x + dx, y + dy, z - hh + yo, x + dx, y + dy, z + hh + yo, x - dx, y - dy, z + hh + yo], normals(Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["ang2vec"])(ang)), texMat, pal, shade, renderable.buff, onesided);
}

function fillbuffersForFloorSprite(x, y, z, xo, yo, hw, hh, ang, xf, yf, onesided, pal, shade, renderable) {
  var dwx = Math.sin(ang) * hw;
  var dwy = Math.cos(ang) * hw;
  var dhx = Math.sin(ang + Math.PI / 2) * hh;
  var dhy = Math.cos(ang + Math.PI / 2) * hh;
  var s = !(xf || yf) ? 1 : -1;
  var xs = xf ? -1.0 : 1.0;
  var ys = yf ? -1.0 : 1.0;
  var texMat = texMat_;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [xs / (hw * 2), ys / (hh * 2), 1, 1]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [hw, hh, 0, 0]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateZ(texMat, texMat, ang - Math.PI / 2);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [-x, -y, 0, 0]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateX(texMat, texMat, -Math.PI / 2);
  genQuad([x - dwx - dhx, y - dwy - dhy, z, x + s * (-dwx + dhx), y + s * (-dwy + dhy), z, x + dwx + dhx, y + dwy + dhy, z, x + s * (dwx - dhx), y + s * (dwy - dhy), z], normals([0, s, 0]), texMat, pal, shade, renderable.buff, onesided);
}

function genSpriteQuad(x, y, z, n, t, pal, shade, buff) {
  buff.allocate(4, 12);
  writePos(buff, [x, y, z, x, y, z, x, y, z, x, y, z]);
  writeTc(buff, t, pal, shade);
  writeNormal(buff, n);
  buff.writeQuad(0, 0, 1, 2, 3);
  buff.writeQuad(6, 3, 2, 1, 0);
}

function fillBuffersForFaceSprite(x, y, z, xo, yo, hw, hh, xf, yf, pal, shade, renderable) {
  var texMat = texMat_;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [1 / (hw * 2), -1 / (hh * 2), 1, 1]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [hw - xo, -hh - yo, 0, 0]);
  genSpriteQuad(x, y, z, [-hw + xo, +hh + yo, 0, +hw + xo, +hh + yo, 0, +hw + xo, -hh + yo, 0, -hw + xo, -hh + yo, 0], [0, 0, 1, 0, 1, 1, 0, 1], pal, shade, renderable.buff);
}

function updateSprite(ctx, sprId, builder) {
  builder = builder == null ? ctx.factory.solid('sprite') : builder;
  var board = ctx.board();
  var spr = board.sprites[sprId];
  if (spr.picnum == 0 || spr.cstat.invisible) return builder;
  var x = spr.x;
  var y = spr.y;
  var z = spr.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var info = ctx.art.getInfo(spr.picnum);
  var tex = ctx.art.get(spr.picnum);
  var w = info.w * spr.xrepeat / 4;
  var hw = w >> 1;
  var h = info.h * spr.yrepeat / 4;
  var hh = h >> 1;
  var ang = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["spriteAngle"])(spr.ang);
  var xo = info.attrs.xoff * spr.xrepeat / 4;
  var yo = info.attrs.yoff * spr.yrepeat / 4 + (spr.cstat.realCenter ? 0 : hh);
  var xf = spr.cstat.xflip;
  var yf = spr.cstat.yflip;
  var sec = board.sectors[spr.sectnum];
  var sectorShade = sec ? sec.floorshade : spr.shade;
  var shade = spr.shade == -8 ? sectorShade : spr.shade;
  var trans = spr.cstat.translucent ? spr.cstat.tranclucentReversed ? 0.66 : 0.33 : 1;
  builder.tex = tex;
  builder.trans = trans;

  if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["FACE_SPRITE"]) {
    fillBuffersForFaceSprite(x, y, z, xo, yo, hw, hh, xf, yf, spr.pal, shade, builder);
    builder.type = _common__WEBPACK_IMPORTED_MODULE_3__["Type"].FACE;
  } else if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["WALL_SPRITE"]) {
    fillbuffersForWallSprite(x, y, z, xo, yo, hw, hh, ang, xf, yf, spr.cstat.onesided, spr.pal, shade, builder);
  } else if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["FLOOR_SPRITE"]) {
    fillbuffersForFloorSprite(x, y, z, xo, yo, hw, hh, ang, xf, yf, spr.cstat.onesided, spr.pal, shade, builder);
  }

  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/sprite2d.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/geometry/builders/sprite2d.ts ***!
  \*******************************************************/
/*! exports provided: Sprite2dBuilder, updateSprite2d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite2dBuilder", function() { return Sprite2dBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSprite2d", function() { return updateSprite2d; });
/* harmony import */ var _build_board_structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cache */ "./src/app/modules/geometry/cache.ts");







class Sprite2dBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_4__["Builders"] {
  constructor(factory, ang, lines, img) {
    if (ang === void 0) {
      ang = factory.wireframe('2d');
    }

    if (lines === void 0) {
      lines = factory.wireframe('2d');
    }

    if (img === void 0) {
      img = factory.solid('2d').knd(_apis_renderable__WEBPACK_IMPORTED_MODULE_5__["SPRITE_LABEL"]);
    }

    super([ang, img, lines]);
    this.ang = ang;
    this.lines = lines;
    this.img = img;
  }

}
var CIRCLE_SECTIONS = 12;
var CIRCLE_OUT_RADIUS = 96;
var CIRCLE_IN_RADIUS = 80;

function genSpriteMarker(builder, x, y, z, ang, color) {
  builder.mode = WebGLRenderingContext.TRIANGLES;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].copy(builder.color, color);
  var buff = builder.buff;
  buff.allocate(CIRCLE_SECTIONS * 2 + 4, CIRCLE_SECTIONS * 6 + 6);
  var off = 0;

  for (var i = 0; i < CIRCLE_SECTIONS; i++) {
    var _ang = Math.PI * 2 * (i / CIRCLE_SECTIONS);

    var dxo = Math.sin(_ang) * CIRCLE_OUT_RADIUS;
    var dxi = Math.sin(_ang) * CIRCLE_IN_RADIUS;
    var dyo = Math.cos(_ang) * CIRCLE_OUT_RADIUS;
    var dyi = Math.cos(_ang) * CIRCLE_IN_RADIUS;
    buff.writePos(off + 0, x + dxo, z, y + dyo);
    buff.writePos(off + 1, x + dxi, z, y + dyi);
    off += 2;
  }

  var angle = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["spriteAngle"])(ang | 0);
  var hw = (CIRCLE_OUT_RADIUS - CIRCLE_IN_RADIUS) / 2;
  var dx = Math.sin(angle) * hw;
  var dy = Math.cos(angle) * hw;
  var dx1 = Math.sin(angle + Math.PI / 2) * CIRCLE_IN_RADIUS;
  var dy1 = Math.cos(angle + Math.PI / 2) * CIRCLE_IN_RADIUS;
  buff.writePos(off++, x - dx + dx1, z, y - dy + dy1);
  buff.writePos(off++, x + dx + dx1, z, y + dy + dy1);
  buff.writePos(off++, x + dx, z, y + dy);
  buff.writePos(off++, x - dx, z, y - dy);
  off = 0;

  for (var [i1, i2] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_3__["cyclicPairs"])(CIRCLE_SECTIONS)) {
    var off1 = i1 * 2;
    var off2 = i2 * 2;
    buff.writeTriangle(off, off1, off2, off1 + 1);
    buff.writeTriangle(off + 3, off1 + 1, off2, off2 + 1);
    off += 6;
  }

  var vtxoff = CIRCLE_SECTIONS * 2;
  buff.writeQuad(off, vtxoff, vtxoff + 1, vtxoff + 2, vtxoff + 3);
}

function updateSpriteAngle(ctx, spriteId, builder) {
  builder.mode = WebGLRenderingContext.TRIANGLES;
  var board = ctx.board();
  var sprite = board.sprites[spriteId];
  genSpriteMarker(builder, sprite.x, sprite.y, sprite.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], sprite.ang, ctx.state.get(_cache__WEBPACK_IMPORTED_MODULE_6__["SPRITE_COLOR"]));
  return builder;
}

function updateSpriteImage(ctx, spriteId, builder) {
  var board = ctx.board();
  var sprite = board.sprites[spriteId];
  if (sprite.picnum == 0 || sprite.cstat.type != _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["FACE_SPRITE"]) return;
  builder.tex = ctx.art.get(sprite.picnum);
  var buff = builder.buff;
  var x = sprite.x;
  var y = sprite.y;
  var z = sprite.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var pal = sprite.pal;
  var shade = -127;
  var info = ctx.art.getInfo(sprite.picnum);
  var w = info.w * 8;
  var h = info.h * 8;
  buff.allocate(4, 6);
  buff.writePos(0, x - w / 2, z, y);
  buff.writePos(1, x - w / 2, z, y - h);
  buff.writePos(2, x + w / 2, z, y - h);
  buff.writePos(3, x + w / 2, z, y);
  buff.writeTcLighting(0, 0, 1, pal, shade);
  buff.writeTcLighting(1, 0, 0, pal, shade);
  buff.writeTcLighting(2, 1, 0, pal, shade);
  buff.writeTcLighting(3, 1, 1, pal, shade);
  buff.writeQuad(0, 0, 1, 2, 3);
}

var WALL_SPRITE_LINE_WIDTH = 32;

function updateSpriteLine(ctx, spriteId, builder) {
  var board = ctx.board();
  var sprite = board.sprites[spriteId];
  if (sprite.picnum == 0 || sprite.cstat.type != _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["WALL_SPRITE"]) return;
  var info = ctx.art.getInfo(sprite.picnum);
  var w = info.w * sprite.xrepeat / 4;
  var hw = w >> 1;
  var ang = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["spriteAngle"])(sprite.ang);
  var dx = Math.sin(ang) * hw;
  var dy = Math.cos(ang) * hw;
  var dxt = Math.sin(ang + Math.PI / 2) * (WALL_SPRITE_LINE_WIDTH / 2);
  var dyt = Math.cos(ang + Math.PI / 2) * (WALL_SPRITE_LINE_WIDTH / 2);
  var x = sprite.x;
  var y = sprite.y;
  var z = sprite.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].copy(builder.color, ctx.state.get(_cache__WEBPACK_IMPORTED_MODULE_6__["SPRITE_COLOR"]));
  builder.mode = WebGLRenderingContext.TRIANGLES;
  var buff = builder.buff;
  buff.allocate(4, 6);
  buff.writePos(0, x - dx + dxt, z, y - dy + dyt);
  buff.writePos(1, x + dx + dxt, z, y + dy + dyt);
  buff.writePos(2, x + dx - dxt, z, y + dy - dyt);
  buff.writePos(3, x - dx - dxt, z, y - dy - dyt);
  buff.writeQuad(0, 0, 1, 2, 3);
}

function updateSprite2d(ctx, sprId, builder) {
  builder = builder == null ? new Sprite2dBuilder(ctx.factory) : builder;
  var board = ctx.board();
  var sprite = board.sprites[sprId]; // text(builder.label, sprId + "", sprite.x, sprite.y, sprite.z / ZSCALE, 8, 8, ctx.art.get(-2));

  updateSpriteAngle(ctx, sprId, builder.ang);
  updateSpriteImage(ctx, sprId, builder.img);
  updateSpriteLine(ctx, sprId, builder.lines);
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/spritehelper.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/geometry/builders/spritehelper.ts ***!
  \***********************************************************/
/*! exports provided: SpriteHelperBuillder, updateSpriteHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteHelperBuillder", function() { return SpriteHelperBuillder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSpriteHelper", function() { return updateSpriteHelper; });
/* harmony import */ var _build_board_structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common */ "./src/app/modules/geometry/common.ts");





class SpriteHelperBuillder extends _apis_builder__WEBPACK_IMPORTED_MODULE_3__["Builders"] {
  constructor(factory, wire, angle) {
    if (wire === void 0) {
      wire = factory.wireframe('helper');
    }

    if (angle === void 0) {
      angle = factory.wireframe('helper');
    }

    super([wire, angle]);
    this.wire = wire;
    this.angle = angle;
  }

}

function genQuadWireframe(coords, normals, builder) {
  var buff = builder.buff;
  buff.allocate(4, 8);
  var [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = coords;
  buff.writePos(0, x1, z1, y1);
  buff.writePos(1, x2, z2, y2);
  buff.writePos(2, x3, z3, y3);
  buff.writePos(3, x4, z4, y4);

  if (normals != null) {
    buff.writeNormal(0, normals[0], normals[1], 0);
    buff.writeNormal(1, normals[2], normals[3], 0);
    buff.writeNormal(2, normals[4], normals[5], 0);
    buff.writeNormal(3, normals[6], normals[7], 0);
  }

  buff.writeLine(0, 0, 1);
  buff.writeLine(2, 1, 2);
  buff.writeLine(4, 2, 3);
  buff.writeLine(6, 3, 0);
}

function fillbuffersForWallSpriteWireframe(x, y, z, xo, yo, hw, hh, ang, builder) {
  var dx = Math.sin(ang) * hw;
  var dy = Math.cos(ang) * hw;
  genQuadWireframe([x - dx, y - dy, z - hh + yo, x + dx, y + dy, z - hh + yo, x + dx, y + dy, z + hh + yo, x - dx, y - dy, z + hh + yo], null, builder);
}

function fillbuffersForFloorSpriteWireframe(x, y, z, xo, yo, hw, hh, ang, builder) {
  var dwx = Math.sin(ang) * hw;
  var dwy = Math.cos(ang) * hw;
  var dhx = Math.sin(ang + Math.PI / 2) * hh;
  var dhy = Math.cos(ang + Math.PI / 2) * hh;
  genQuadWireframe([x - dwx - dhx, y - dwy - dhy, z, x + dwx - dhx, y + dwy - dhy, z, x + dwx + dhx, y + dwy + dhy, z, x - dwx + dhx, y - dwy + dhy, z], null, builder);
}

function fillBuffersForFaceSpriteWireframe(x, y, z, xo, yo, hw, hh, builder) {
  genQuadWireframe([x, y, z, x, y, z, x, y, z, x, y, z], [-hw + xo, +hh + yo, +hw + xo, +hh + yo, +hw + xo, -hh + yo, -hw + xo, -hh + yo], builder);
}

function updateSpriteWireframe(ctx, sprId, builder) {
  var board = ctx.board();
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(builder.color, 1, 1, 1, -100);
  var spr = board.sprites[sprId];
  if (spr.picnum == 0 || spr.cstat.invisible) return builder;
  var x = spr.x;
  var y = spr.y;
  var z = spr.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var info = ctx.art.getInfo(spr.picnum);
  var w = info.w * spr.xrepeat / 4;
  var hw = w >> 1;
  var h = info.h * spr.yrepeat / 4;
  var hh = h >> 1;
  var ang = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["spriteAngle"])(spr.ang);
  var xo = info.attrs.xoff * spr.xrepeat / 4;
  var yo = info.attrs.yoff * spr.yrepeat / 4 + (spr.cstat.realCenter ? 0 : hh);

  if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["FACE_SPRITE"]) {
    builder.type = _common__WEBPACK_IMPORTED_MODULE_4__["Type"].FACE;
    fillBuffersForFaceSpriteWireframe(x, y, z, xo, yo, hw, hh, builder);
  } else if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["WALL_SPRITE"]) {
    builder.type = _common__WEBPACK_IMPORTED_MODULE_4__["Type"].SURFACE;
    fillbuffersForWallSpriteWireframe(x, y, z, xo, yo, hw, hh, ang, builder);
  } else if (spr.cstat.type == _build_board_structs__WEBPACK_IMPORTED_MODULE_0__["FLOOR_SPRITE"]) {
    builder.type = _common__WEBPACK_IMPORTED_MODULE_4__["Type"].SURFACE;
    fillbuffersForFloorSpriteWireframe(x, y, z, xo, yo, hw, hh, ang, builder);
  }

  return builder;
}

function updateSpriteAngle(ctx, spriteId, renderable) {
  renderable.mode = WebGLRenderingContext.TRIANGLES;
  var buff = renderable.buff;
  var board = ctx.board();
  buff.allocate(3, 6);
  var spr = board.sprites[spriteId];
  var x = spr.x,
      y = spr.y,
      z = spr.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var ang = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["spriteAngle"])(spr.ang);
  var size = 128;
  var vec1 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["ang2vec"])(ang);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].scale(vec1, vec1, size);
  var vec2 = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["ang2vec"])(ang + Math.PI / 2);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].scale(vec2, vec2, size / 4);
  buff.writePos(0, x + vec1[0], z, y + vec1[2]);
  buff.writePos(1, x + vec2[0], z, y + vec2[2]);
  buff.writePos(2, x - vec2[0], z, y - vec2[2]);
  buff.writeTriangle(0, 0, 1, 2);
  buff.writeTriangle(3, 2, 1, 0);
  return renderable;
}

function updateSpriteHelper(ctx, sprId, builder) {
  builder = builder == null ? new SpriteHelperBuillder(ctx.factory) : builder;
  updateSpriteWireframe(ctx, sprId, builder.wire);
  updateSpriteAngle(ctx, sprId, builder.angle);
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/wall.ts":
/*!***************************************************!*\
  !*** ./src/app/modules/geometry/builders/wall.ts ***!
  \***************************************************/
/*! exports provided: WallBuilder, updateWall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallBuilder", function() { return WallBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWall", function() { return updateWall; });
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");





class WallBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_4__["Builders"] {
  constructor(factory, top, mid, bot) {
    if (top === void 0) {
      top = factory.solid('wall');
    }

    if (mid === void 0) {
      mid = factory.solid('wall');
    }

    if (bot === void 0) {
      bot = factory.solid('wall');
    }

    super([top, mid, bot]);
    this.top = top;
    this.mid = mid;
    this.bot = bot;
  }

}

function normals(n) {
  return [n[0], n[1], n[2], n[0], n[1], n[2], n[0], n[1], n[2], n[0], n[1], n[2]];
}

function getWallCoords(x1, y1, x2, y2, slope, nextslope, heinum, nextheinum, z, nextz, check) {
  var z1 = (slope(x1, y1, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var z2 = (slope(x2, y2, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var z3 = (nextslope(x2, y2, nextheinum) + nextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var z4 = (nextslope(x1, y1, nextheinum) + nextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  if (check && z4 >= z1 && z3 >= z2) return null;

  if (z4 > z1) {
    var d = 1 - 1 / ((z4 - z1) / (z2 - z3) + 1);
    var x1_ = x1 + (x2 - x1) * d;
    var y1_ = y1 + (y2 - y1) * d;
    var z1_ = z1 + (z2 - z1) * d;
    return [x1_, y1_, z1_, x2, y2, z2, x2, y2, z3, x1_, y1_, z1_];
  } else if (z3 > z2) {
    var _d = 1 - 1 / ((z1 - z4) / (z3 - z2) + 1);

    var x2_ = x1 + (x2 - x1) * _d;
    var y2_ = y1 + (y2 - y1) * _d;
    var z2_ = z1 + (z2 - z1) * _d;
    return [x1, y1, z1, x2_, y2_, z2_, x2_, y2_, z2_, x1, y1, z4];
  }

  return [x1, y1, z1, x2, y2, z2, x2, y2, z3, x1, y1, z4];
}

function applyWallTextureTransform(wall, wall2, info, base, originalWall, texMat) {
  if (originalWall === void 0) {
    originalWall = wall;
  }

  var wall1 = wall;
  if (originalWall.cstat.xflip) [wall1, wall2] = [wall2, wall1];
  var flip = wall == originalWall ? 1 : -1;
  var tw = info.w;
  var th = info.h;
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var tcscalex = wall.xrepeat * 8.0 / (flip * Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["len2d"])(dx, dy) * tw);
  var tcscaley = -(wall.yrepeat / 8.0) / (th * 16.0) * (originalWall.cstat.yflip ? -1 : 1);
  var tcxoff = wall.xpanning / tw;
  var tcyoff = wall.ypanning / 256.0;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].identity(texMat);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [tcxoff, tcyoff, 0, 0]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].scale(texMat, texMat, [tcscalex, tcscaley, 1, 1]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].rotateY(texMat, texMat, -Math.atan2(-dy, dx));
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(texMat, texMat, [-wall1.x, -base / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], -wall1.y, 0]);
}

function writePos(buff, c) {
  buff.writePos(0, c[0], c[2], c[1]);
  buff.writePos(1, c[3], c[5], c[4]);
  buff.writePos(2, c[6], c[8], c[7]);
  buff.writePos(3, c[9], c[11], c[10]);
}

var tc = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].create();

function writeTransformTc(buff, t, c, pal, shade) {
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc, c[0], c[2], c[1], 1), t);
  buff.writeTcLighting(0, tc[0], tc[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc, c[3], c[5], c[4], 1), t);
  buff.writeTcLighting(1, tc[0], tc[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc, c[6], c[8], c[7], 1), t);
  buff.writeTcLighting(2, tc[0], tc[1], pal, shade);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].transformMat4(tc, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec4"].set(tc, c[9], c[11], c[10], 1), t);
  buff.writeTcLighting(3, tc[0], tc[1], pal, shade);
}

function writeNormal(buff, n) {
  buff.writeNormal(0, n[0], n[1], n[2]);
  buff.writeNormal(1, n[3], n[4], n[5]);
  buff.writeNormal(2, n[6], n[7], n[8]);
  buff.writeNormal(3, n[9], n[10], n[11]);
}

function genQuad(c, n, t, pal, shade, buff) {
  buff.allocate(4, 6);
  writePos(buff, c);
  writeTransformTc(buff, t, c, pal, shade);
  writeNormal(buff, n);
  buff.writeQuad(0, 0, 1, 2, 3);
}

function getMaskedWallCoords(x1, y1, x2, y2, slope, nextslope, ceilheinum, ceilnextheinum, ceilz, ceilnextz, floorheinum, floornextheinum, floorz, floornextz) {
  var currz1 = (slope(x1, y1, ceilheinum) + ceilz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var currz2 = (slope(x2, y2, ceilheinum) + ceilz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var currz3 = (slope(x2, y2, floorheinum) + floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var currz4 = (slope(x1, y1, floorheinum) + floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var nextz1 = (nextslope(x1, y1, ceilnextheinum) + ceilnextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var nextz2 = (nextslope(x2, y2, ceilnextheinum) + ceilnextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var nextz3 = (nextslope(x2, y2, floornextheinum) + floornextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var nextz4 = (nextslope(x1, y1, floornextheinum) + floornextz) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  var z1 = Math.min(currz1, nextz1);
  var z2 = Math.min(currz2, nextz2);
  var z3 = Math.max(currz3, nextz3);
  var z4 = Math.max(currz4, nextz4);
  return [x1, y1, z1, x2, y2, z2, x2, y2, z3, x1, y1, z4];
}

var wallNormal_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var texMat_ = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
function updateWall(ctx, wallId, builder) {
  builder = builder == null ? new WallBuilder(ctx.factory) : builder;
  var board = ctx.board();
  var art = ctx.art;
  var wall = board.walls[wallId];
  var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_0__["sectorOfWall"])(board, wallId);
  var sector = board.sectors[sectorId];
  var wall2 = board.walls[wall.point2];
  var x1 = wall.x;
  var y1 = wall.y;
  var x2 = wall2.x;
  var y2 = wall2.y;
  var tex = art.get(wall.picnum);
  var info = art.getInfo(wall.picnum);
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["createSlopeCalculator"])(board, sectorId);
  var ceilingheinum = sector.ceilingheinum;
  var ceilingz = sector.ceilingz;
  var floorheinum = sector.floorheinum;
  var floorz = sector.floorz;
  var trans = wall.cstat.translucent ? wall.cstat.translucentReversed ? 0.66 : 0.33 : 1;
  var normal = normals(Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["wallNormal"])(wallNormal_, board, wallId));

  if (wall.nextwall == -1 || wall.cstat.oneWay) {
    var coords = getWallCoords(x1, y1, x2, y2, slope, slope, ceilingheinum, floorheinum, ceilingz, floorz, false);
    var base = wall.cstat.alignBottom ? floorz : ceilingz;
    applyWallTextureTransform(wall, wall2, info, base, wall, texMat_);
    genQuad(coords, normal, texMat_, wall.pal, wall.shade, builder.mid.buff);
    builder.mid.tex = tex;
  } else {
    var nextsector = board.sectors[wall.nextsector];
    var nextslope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["createSlopeCalculator"])(board, wall.nextsector);
    var nextfloorz = nextsector.floorz;
    var nextceilingz = nextsector.ceilingz;
    var nextfloorheinum = nextsector.floorheinum;
    var floorcoords = getWallCoords(x1, y1, x2, y2, nextslope, slope, nextfloorheinum, floorheinum, nextfloorz, floorz, true);

    if (floorcoords != null) {
      var pal = 0;
      var shade = 0;

      if (sector.floorstat.parallaxing && nextsector.floorstat.parallaxing && sector.floorpicnum == nextsector.floorpicnum) {
        builder.bot.tex = art.getParallaxTexture(sector.floorpicnum);
        shade = sector.floorshade;
        pal = sector.floorpal;
        builder.bot.parallax = 1;
      } else {
        var wall_ = wall.cstat.swapBottoms ? board.walls[wall.nextwall] : wall;
        var wall2_ = wall.cstat.swapBottoms ? board.walls[wall_.point2] : wall2;
        var tex_ = wall.cstat.swapBottoms ? art.get(wall_.picnum) : tex;
        var info_ = wall.cstat.swapBottoms ? art.getInfo(wall_.picnum) : info;

        var _base = wall.cstat.alignBottom ? ceilingz : nextfloorz;

        applyWallTextureTransform(wall_, wall2_, info_, _base, wall, texMat_);
        builder.bot.tex = tex_;
        shade = wall_.shade;
        pal = wall_.pal;
      }

      genQuad(floorcoords, normal, texMat_, pal, shade, builder.bot.buff);
    }

    var nextceilingheinum = nextsector.ceilingheinum;
    var ceilcoords = getWallCoords(x1, y1, x2, y2, slope, nextslope, ceilingheinum, nextceilingheinum, ceilingz, nextceilingz, true);

    if (ceilcoords != null) {
      var _pal = 0;
      var _shade = 0;

      if (sector.ceilingstat.parallaxing && nextsector.ceilingstat.parallaxing && sector.ceilingpicnum == nextsector.ceilingpicnum) {
        builder.top.tex = art.getParallaxTexture(sector.ceilingpicnum);
        _shade = sector.ceilingshade;
        _pal = sector.ceilingpal;
        builder.top.parallax = 1;
      } else {
        var _base2 = wall.cstat.alignBottom ? ceilingz : nextceilingz;

        applyWallTextureTransform(wall, wall2, info, _base2, wall, texMat_);
        builder.top.tex = tex;
        _shade = wall.shade;
        _pal = wall.pal;
      }

      genQuad(ceilcoords, normal, texMat_, _pal, _shade, builder.top.buff);
    }

    if (wall.cstat.masking) {
      var tex1 = art.get(wall.overpicnum);
      var info1 = art.getInfo(wall.overpicnum);

      var _coords = getMaskedWallCoords(x1, y1, x2, y2, slope, nextslope, ceilingheinum, nextceilingheinum, ceilingz, nextceilingz, floorheinum, nextfloorheinum, floorz, nextfloorz);

      var _base3 = wall.cstat.alignBottom ? Math.min(floorz, nextfloorz) : Math.max(ceilingz, nextceilingz);

      applyWallTextureTransform(wall, wall2, info1, _base3, wall, texMat_);
      genQuad(_coords, normal, texMat_, wall.pal, wall.shade, builder.mid.buff);
      builder.mid.tex = tex1;
      builder.mid.trans = trans;
    }
  }

  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/wall2d.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/geometry/builders/wall2d.ts ***!
  \*****************************************************/
/*! exports provided: Wall2dBuilder, updateWall2d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wall2dBuilder", function() { return Wall2dBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWall2d", function() { return updateWall2d; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cache */ "./src/app/modules/geometry/cache.ts");



class Wall2dBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_1__["Builders"] {
  constructor(factory, top, mid, bot) {
    if (top === void 0) {
      top = factory.wireframe('2d');
    }

    if (mid === void 0) {
      mid = factory.wireframe('2d');
    }

    if (bot === void 0) {
      bot = factory.wireframe('2d');
    }

    super([top, mid, bot]);
    this.top = top;
    this.mid = mid;
    this.bot = bot;
  }

}
function updateWall2d(ctx, wallId, builder) {
  builder = builder == null ? new Wall2dBuilder(ctx.factory) : builder;
  var board = ctx.board();
  var buff = builder.mid.buff;
  buff.allocate(2, 2);
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  buff.writePos(0, wall.x, 0, wall.y);
  buff.writePos(1, wall2.x, 0, wall2.y);
  buff.writeLine(0, 0, 1);
  var state = ctx.state;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].copy(builder.mid.color, wall.cstat.masking ? state.get(_cache__WEBPACK_IMPORTED_MODULE_2__["MASKED_WALL_COLOR"]) : wall.nextwall == -1 ? state.get(_cache__WEBPACK_IMPORTED_MODULE_2__["WALL_COLOR"]) : state.get(_cache__WEBPACK_IMPORTED_MODULE_2__["INTERSECTOR_WALL_COLOR"]));
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/wallhelper.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/geometry/builders/wallhelper.ts ***!
  \*********************************************************/
/*! exports provided: WallHelperBuilder, updateWallWireframe, updateWallHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallHelperBuilder", function() { return WallHelperBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWallWireframe", function() { return updateWallWireframe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWallHelper", function() { return updateWallHelper; });
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common */ "./src/app/modules/geometry/builders/common.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../build/board/query */ "./src/build/board/query.ts");







class WallHelperBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_2__["Builders"] {
  constructor(factory, topWire, topGrid, topPoints, topLength, midWire, midGrid, botWire, botGrid, botPoints, botLength, top, mid, bot) {
    if (topWire === void 0) {
      topWire = factory.wireframe('helper');
    }

    if (topGrid === void 0) {
      topGrid = factory.grid('helper');
    }

    if (topPoints === void 0) {
      topPoints = factory.pointSprite('helper');
    }

    if (topLength === void 0) {
      topLength = factory.pointSprite('helper');
    }

    if (midWire === void 0) {
      midWire = factory.wireframe('helper');
    }

    if (midGrid === void 0) {
      midGrid = factory.grid('helper');
    }

    if (botWire === void 0) {
      botWire = factory.wireframe('helper');
    }

    if (botGrid === void 0) {
      botGrid = factory.grid('helper');
    }

    if (botPoints === void 0) {
      botPoints = factory.pointSprite('helper');
    }

    if (botLength === void 0) {
      botLength = factory.pointSprite('helper');
    }

    if (top === void 0) {
      top = new _apis_renderable__WEBPACK_IMPORTED_MODULE_3__["Renderables"]([topWire, topGrid, topPoints, topLength]);
    }

    if (mid === void 0) {
      mid = new _apis_renderable__WEBPACK_IMPORTED_MODULE_3__["Renderables"]([midWire, midGrid]);
    }

    if (bot === void 0) {
      bot = new _apis_renderable__WEBPACK_IMPORTED_MODULE_3__["Renderables"]([botWire, botGrid, botPoints, botLength]);
    }

    super([topWire, midWire, botWire, topGrid, midGrid, botGrid, topPoints, botPoints, topLength, botLength]);
    this.topWire = topWire;
    this.topGrid = topGrid;
    this.topPoints = topPoints;
    this.topLength = topLength;
    this.midWire = midWire;
    this.midGrid = midGrid;
    this.botWire = botWire;
    this.botGrid = botGrid;
    this.botPoints = botPoints;
    this.botLength = botLength;
    this.top = top;
    this.mid = mid;
    this.bot = bot;
  }

}

function genQuadWireframe(coords, normals, buff) {
  buff.allocate(4, 8);
  var [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = coords;
  buff.writePos(0, x1, z1, y1);
  buff.writePos(1, x2, z2, y2);
  buff.writePos(2, x3, z3, y3);
  buff.writePos(3, x4, z4, y4);

  if (normals != null) {
    buff.writeNormal(0, normals[0], normals[1], 0);
    buff.writeNormal(1, normals[2], normals[3], 0);
    buff.writeNormal(2, normals[4], normals[5], 0);
    buff.writeNormal(3, normals[6], normals[7], 0);
  }

  buff.writeLine(0, 0, 1);
  buff.writeLine(2, 1, 2);
  buff.writeLine(4, 2, 3);
  buff.writeLine(6, 3, 0);
}

function getWallCoords(x1, y1, x2, y2, slope, nextslope, heinum, nextheinum, z, nextz, check, line) {
  if (line === void 0) {
    line = false;
  }

  var z1 = (slope(x1, y1, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var z2 = (slope(x2, y2, heinum) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var z3 = (nextslope(x2, y2, nextheinum) + nextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var z4 = (nextslope(x1, y1, nextheinum) + nextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];

  if (check) {
    if (line && z4 > z1 && z3 > z2) return null;
    if (!line && z4 >= z1 && z3 >= z2) return null;
  }

  return [x1, y1, z1, x2, y2, z2, x2, y2, z3, x1, y1, z4];
}

function getMaskedWallCoords(x1, y1, x2, y2, slope, nextslope, ceilheinum, ceilnextheinum, ceilz, ceilnextz, floorheinum, floornextheinum, floorz, floornextz) {
  var currz1 = (slope(x1, y1, ceilheinum) + ceilz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var currz2 = (slope(x2, y2, ceilheinum) + ceilz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var currz3 = (slope(x2, y2, floorheinum) + floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var currz4 = (slope(x1, y1, floorheinum) + floorz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var nextz1 = (nextslope(x1, y1, ceilnextheinum) + ceilnextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var nextz2 = (nextslope(x2, y2, ceilnextheinum) + ceilnextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var nextz3 = (nextslope(x2, y2, floornextheinum) + floornextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var nextz4 = (nextslope(x1, y1, floornextheinum) + floornextz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  var z1 = Math.min(currz1, nextz1);
  var z2 = Math.min(currz2, nextz2);
  var z3 = Math.max(currz3, nextz3);
  var z4 = Math.max(currz4, nextz4);
  return [x1, y1, z1, x2, y2, z2, x2, y2, z3, x1, y1, z4];
}

function updateWallWireframe(ctx, wallId, builder) {
  var board = ctx.board();
  var wall = board.walls[wallId];
  var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_6__["sectorOfWall"])(board, wallId);
  var sector = board.sectors[sectorId];
  var wall2 = board.walls[wall.point2];
  var x1 = wall.x;
  var y1 = wall.y;
  var x2 = wall2.x;
  var y2 = wall2.y;
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["createSlopeCalculator"])(board, sectorId);
  var ceilingheinum = sector.ceilingheinum;
  var ceilingz = sector.ceilingz;
  var floorheinum = sector.floorheinum;
  var floorz = sector.floorz;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["vec4"].set(builder.topWire.color, 1, 1, 1, -100);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["vec4"].set(builder.midWire.color, 1, 1, 1, -100);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["vec4"].set(builder.botWire.color, 1, 1, 1, -100);

  if (wall.nextwall == -1 || wall.cstat.oneWay) {
    var coords = getWallCoords(x1, y1, x2, y2, slope, slope, ceilingheinum, floorheinum, ceilingz, floorz, false);
    genQuadWireframe(coords, null, builder.midWire.buff);
  } else {
    var nextsector = board.sectors[wall.nextsector];
    var nextslope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["createSlopeCalculator"])(board, wall.nextsector);
    var nextfloorz = nextsector.floorz;
    var nextceilingz = nextsector.ceilingz;
    var nextfloorheinum = nextsector.floorheinum;
    var botcoords = getWallCoords(x1, y1, x2, y2, nextslope, slope, nextfloorheinum, floorheinum, nextfloorz, floorz, true, true);
    if (botcoords != null) genQuadWireframe(botcoords, null, builder.botWire.buff);
    var nextceilingheinum = nextsector.ceilingheinum;
    var topcoords = getWallCoords(x1, y1, x2, y2, slope, nextslope, ceilingheinum, nextceilingheinum, ceilingz, nextceilingz, true, true);
    if (topcoords != null) genQuadWireframe(topcoords, null, builder.topWire.buff);

    if (wall.cstat.masking) {
      var _coords = getMaskedWallCoords(x1, y1, x2, y2, slope, nextslope, ceilingheinum, nextceilingheinum, ceilingz, nextceilingz, floorheinum, nextfloorheinum, floorz, nextfloorz);

      genQuadWireframe(_coords, null, builder.midWire.buff);
    }
  }

  return builder;
}

function fillBufferForWallPoint(offset, board, wallId, buff, d, z) {
  var wall = board.walls[wallId];
  var vtxOff = offset * 4;
  buff.writePos(vtxOff + 0, wall.x, z, wall.y);
  buff.writePos(vtxOff + 1, wall.x, z, wall.y);
  buff.writePos(vtxOff + 2, wall.x, z, wall.y);
  buff.writePos(vtxOff + 3, wall.x, z, wall.y);
  buff.writeNormal(vtxOff + 0, -d, d, 0);
  buff.writeNormal(vtxOff + 1, d, d, 0);
  buff.writeNormal(vtxOff + 2, d, -d, 0);
  buff.writeNormal(vtxOff + 3, -d, -d, 0);
  buff.writeTcLighting(vtxOff + 0, 0, 0);
  buff.writeTcLighting(vtxOff + 1, 1, 0);
  buff.writeTcLighting(vtxOff + 2, 1, 1);
  buff.writeTcLighting(vtxOff + 3, 0, 1);
  buff.writeQuad(offset * 6, vtxOff, vtxOff + 1, vtxOff + 2, vtxOff + 3);
}

function updateWallPoint(offset, builder, ctx, ceiling, wallId, d) {
  var board = ctx.board();
  var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_6__["sectorOfWall"])(board, wallId);
  var sec = board.sectors[s];
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["createSlopeCalculator"])(board, s);
  var h = ceiling ? sec.ceilingheinum : sec.floorheinum;
  var z = ceiling ? sec.ceilingz : sec.floorz;
  var wall = board.walls[wallId];
  var zz = (slope(wall.x, wall.y, h) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"];
  fillBufferForWallPoint(offset, board, wallId, builder.buff, d, zz);
}

function addWallPoints(ctx, builder, wallId, ceiling) {
  var pointTex = ctx.art.get(-1);
  var board = ctx.board();
  builder.tex = pointTex;
  builder.buff.allocate(8, 12);
  updateWallPoint(0, builder, ctx, ceiling, wallId, 2.5);
  var wallId2 = board.walls[wallId].point2;
  updateWallPoint(1, builder, ctx, ceiling, wallId2, 2.5);
}

function addLength(ctx, builder, wallId, ceiling) {
  var board = ctx.board();
  var wallId2 = board.walls[wallId].point2;
  var wall = board.walls[wallId];
  var wall2 = board.walls[wallId2];
  var cx = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(wall.x + (wall2.x - wall.x) * 0.5);
  var cy = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(wall.y + (wall2.y - wall.y) * 0.5);
  var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_6__["sectorOfWall"])(board, wallId);
  var sector = board.sectors[sectorId];
  var fz = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["slope"])(board, sectorId, cx, cy, sector.floorheinum) + sector.floorz;
  var cz = Object(_build_utils__WEBPACK_IMPORTED_MODULE_0__["slope"])(board, sectorId, cx, cy, sector.ceilingheinum) + sector.ceilingz;
  var length = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_6__["walllen"])(board, wallId).toFixed(2).replace(/\.00$/, "");
  Object(_common__WEBPACK_IMPORTED_MODULE_4__["text"])(builder, length, cx, cy, (ceiling ? cz : fz) / _build_utils__WEBPACK_IMPORTED_MODULE_0__["ZSCALE"], 8, 8, ctx.art.get(-2));
}

function updateWallHelper(cache, ctx, wallId, builder) {
  builder = builder == null ? new WallHelperBuilder(ctx.factory) : builder;
  updateWallWireframe(ctx, wallId, builder);
  var wallRenderable = cache.wall(wallId);
  var board = ctx.board();
  var wall = board.walls[wallId];
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["mat4"].copy(builder.topGrid.gridTexMat, Object(_common__WEBPACK_IMPORTED_MODULE_4__["createGridWallMatrix"])(board, wallId, _common__WEBPACK_IMPORTED_MODULE_4__["WallGridType"].TOP));
  builder.topGrid.solid = wallRenderable.top;
  addWallPoints(ctx, builder.topPoints, wallId, true);
  addLength(ctx, builder.topLength, wallId, true);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["mat4"].copy(builder.midGrid.gridTexMat, Object(_common__WEBPACK_IMPORTED_MODULE_4__["createGridWallMatrix"])(board, wallId, wall.nextsector == -1 ? _common__WEBPACK_IMPORTED_MODULE_4__["WallGridType"].VOID : _common__WEBPACK_IMPORTED_MODULE_4__["WallGridType"].MID));
  builder.midGrid.solid = wallRenderable.mid;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_5__["mat4"].copy(builder.botGrid.gridTexMat, Object(_common__WEBPACK_IMPORTED_MODULE_4__["createGridWallMatrix"])(board, wallId, _common__WEBPACK_IMPORTED_MODULE_4__["WallGridType"].BOT));
  builder.botGrid.solid = wallRenderable.bot;
  addWallPoints(ctx, builder.botPoints, wallId, false);
  addLength(ctx, builder.botLength, wallId, false);
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/builders/wallpointhelper.ts":
/*!**************************************************************!*\
  !*** ./src/app/modules/geometry/builders/wallpointhelper.ts ***!
  \**************************************************************/
/*! exports provided: WallPointHelperBuilder, updateWallPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallPointHelperBuilder", function() { return WallPointHelperBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateWallPoint", function() { return updateWallPoint; });
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _apis_builder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apis/builder */ "./src/app/apis/builder.ts");



class WallPointHelperBuilder extends _apis_builder__WEBPACK_IMPORTED_MODULE_2__["Builders"] {
  constructor(factory, points, line) {
    if (points === void 0) {
      points = factory.pointSprite('helper');
    }

    if (line === void 0) {
      line = factory.wireframe('helper');
    }

    super([points, line]);
    this.points = points;
    this.line = line;
  }

}

function updateWallLine(ctx, wallId, builder) {
  var board = ctx.board();
  var buff = builder.buff;
  buff.allocate(2, 2);
  var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_0__["sectorOfWall"])(board, wallId);
  var sector = board.sectors[sectorId];
  var wall = board.walls[wallId];
  var fz = sector.floorz + Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["slope"])(board, sectorId, wall.x, wall.y, sector.floorheinum);
  var cz = sector.ceilingz + Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["slope"])(board, sectorId, wall.x, wall.y, sector.ceilingheinum);
  buff.writePos(0, wall.x, fz / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], wall.y);
  buff.writePos(1, wall.x, cz / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], wall.y);
  buff.writeLine(0, 0, 1);
  return builder;
}

function fillBufferForWallPoint(offset, board, wallId, buff, d, z) {
  var wall = board.walls[wallId];
  var vtxOff = offset * 4;
  buff.writePos(vtxOff + 0, wall.x, z, wall.y);
  buff.writePos(vtxOff + 1, wall.x, z, wall.y);
  buff.writePos(vtxOff + 2, wall.x, z, wall.y);
  buff.writePos(vtxOff + 3, wall.x, z, wall.y);
  buff.writeNormal(vtxOff + 0, -d, d, 0);
  buff.writeNormal(vtxOff + 1, d, d, 0);
  buff.writeNormal(vtxOff + 2, d, -d, 0);
  buff.writeNormal(vtxOff + 3, -d, -d, 0);
  buff.writeTcLighting(vtxOff + 0, 0, 0);
  buff.writeTcLighting(vtxOff + 1, 1, 0);
  buff.writeTcLighting(vtxOff + 2, 1, 1);
  buff.writeTcLighting(vtxOff + 3, 0, 1);
  buff.writeQuad(offset * 6, vtxOff, vtxOff + 1, vtxOff + 2, vtxOff + 3);
}

function addWallPoint(offset, builder, ctx, ceiling, wallId, d) {
  var board = ctx.board();
  var s = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_0__["sectorOfWall"])(board, wallId);
  var sec = board.sectors[s];
  var slope = Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["createSlopeCalculator"])(board, s);
  var h = ceiling ? sec.ceilingheinum : sec.floorheinum;
  var z = ceiling ? sec.ceilingz : sec.floorz;
  var wall = board.walls[wallId];
  var zz = (slope(wall.x, wall.y, h) + z) / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
  fillBufferForWallPoint(offset, board, wallId, builder.buff, d, zz);
}

function updateWallPoint(ctx, wallId, builder) {
  builder = builder == null ? new WallPointHelperBuilder(ctx.factory) : builder;
  builder.points.tex = ctx.art.get(-1);
  builder.points.buff.allocate(8, 12);
  addWallPoint(0, builder.points, ctx, true, wallId, 2.5);
  addWallPoint(1, builder.points, ctx, false, wallId, 2.5);
  updateWallLine(ctx, wallId, builder.line);
  return builder;
}

/***/ }),

/***/ "./src/app/modules/geometry/cache.ts":
/*!*******************************************!*\
  !*** ./src/app/modules/geometry/cache.ts ***!
  \*******************************************/
/*! exports provided: CachedTopDownBuildRenderableProvider, CachedBuildRenderableProvider, CachedSelectedRenderableProvider, CachedHelperBuildRenderableProvider, RENDRABLES_CACHE, RenderablesCacheContext, WALL_COLOR, MASKED_WALL_COLOR, INTERSECTOR_WALL_COLOR, SPRITE_COLOR, RenderablesCacheModule, RenderablesCacheImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedTopDownBuildRenderableProvider", function() { return CachedTopDownBuildRenderableProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedBuildRenderableProvider", function() { return CachedBuildRenderableProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedSelectedRenderableProvider", function() { return CachedSelectedRenderableProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedHelperBuildRenderableProvider", function() { return CachedHelperBuildRenderableProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RENDRABLES_CACHE", function() { return RENDRABLES_CACHE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderablesCacheContext", function() { return RenderablesCacheContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WALL_COLOR", function() { return WALL_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MASKED_WALL_COLOR", function() { return MASKED_WALL_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERSECTOR_WALL_COLOR", function() { return INTERSECTOR_WALL_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPRITE_COLOR", function() { return SPRITE_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderablesCacheModule", function() { return RenderablesCacheModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderablesCacheImpl", function() { return RenderablesCacheImpl; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _builders_sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builders/sector */ "./src/app/modules/geometry/builders/sector.ts");
/* harmony import */ var _builders_sectorcluster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./builders/sectorcluster */ "./src/app/modules/geometry/builders/sectorcluster.ts");
/* harmony import */ var _builders_sectorhelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./builders/sectorhelper */ "./src/app/modules/geometry/builders/sectorhelper.ts");
/* harmony import */ var _builders_sprite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./builders/sprite */ "./src/app/modules/geometry/builders/sprite.ts");
/* harmony import */ var _builders_sprite2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./builders/sprite2d */ "./src/app/modules/geometry/builders/sprite2d.ts");
/* harmony import */ var _builders_spritehelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./builders/spritehelper */ "./src/app/modules/geometry/builders/spritehelper.ts");
/* harmony import */ var _builders_wall__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./builders/wall */ "./src/app/modules/geometry/builders/wall.ts");
/* harmony import */ var _builders_wall2d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./builders/wall2d */ "./src/app/modules/geometry/builders/wall2d.ts");
/* harmony import */ var _builders_wallhelper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./builders/wallhelper */ "./src/app/modules/geometry/builders/wallhelper.ts");
/* harmony import */ var _builders_wallpointhelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./builders/wallpointhelper */ "./src/app/modules/geometry/builders/wallpointhelper.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _builders_selected__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./builders/selected */ "./src/app/modules/geometry/builders/selected.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

















class Entry {
  constructor(value, valid) {
    if (valid === void 0) {
      valid = false;
    }

    this.value = value;
    this.valid = valid;
  }

  update(value) {
    this.value = value;
    this.valid = true;
  }

}

class CacheMap {
  constructor(update) {
    this.cache = {};
    this.update = update;
  }

  get(id, ctx) {
    var v = this.ensureValue(id);

    if (!v.valid) {
      v.update(this.update(ctx, id, v.value));
      v.value.needToRebuild();
    }

    return v.value;
  }

  ensureValue(id) {
    var v = this.cache[id];

    if (v == undefined) {
      v = new Entry(null);
      this.cache[id] = v;
    }

    return v;
  }

  invalidate(id) {
    var v = this.cache[id];
    if (v == undefined) return;
    v.value.reset();
    v.valid = false;
  }

  invalidateAll() {
    for (var _id in this.cache) {
      this.invalidate(_id);
    }
  }

}

class CachedTopDownBuildRenderableProvider {
  constructor(ctx, NULL_SECTOR_RENDERABLE) {
    if (NULL_SECTOR_RENDERABLE === void 0) {
      NULL_SECTOR_RENDERABLE = new _builders_sector__WEBPACK_IMPORTED_MODULE_3__["SectorBuilder"](ctx.factory);
    }

    this.walls = new CacheMap(_builders_wall2d__WEBPACK_IMPORTED_MODULE_10__["updateWall2d"]);
    this.sprites = new CacheMap(_builders_sprite2d__WEBPACK_IMPORTED_MODULE_7__["updateSprite2d"]);
    this.ctx = ctx;
    this.NULL_SECTOR_RENDERABLE = NULL_SECTOR_RENDERABLE;
  }

  sector(id) {
    return this.NULL_SECTOR_RENDERABLE;
  }

  sectorCluster(id) {
    throw new Error('Cant render clusters');
  }

  wall(id) {
    return this.walls.get(id, this.ctx);
  }

  wallPoint(id) {
    throw new Error('Cant render points');
  }

  sprite(id) {
    return this.sprites.get(id, this.ctx);
  }

  invalidateSector(id) {}

  invalidateWall(id) {
    this.walls.invalidate(id);
  }

  invalidateSprite(id) {
    this.sprites.invalidate(id);
  }

  invalidateAll() {
    this.walls.invalidateAll();
    this.sprites.invalidateAll();
  }

}
class CachedBuildRenderableProvider {
  constructor(ctx) {
    this.sectors = new CacheMap(_builders_sector__WEBPACK_IMPORTED_MODULE_3__["updateSector"]);
    this.walls = new CacheMap(_builders_wall__WEBPACK_IMPORTED_MODULE_9__["updateWall"]);
    this.sprites = new CacheMap(_builders_sprite__WEBPACK_IMPORTED_MODULE_6__["updateSprite"]);
    this.clusters = new CacheMap(_builders_sectorcluster__WEBPACK_IMPORTED_MODULE_4__["updateCluster"]);
    this.ctx = ctx;
  }

  sector(id) {
    return this.sectors.get(id, this.ctx);
  }

  sectorCluster(id) {
    return this.clusters.get(id, this.ctx);
  }

  wall(id) {
    return this.walls.get(id, this.ctx);
  }

  wallPoint(id) {
    throw new Error('Cant render points');
  }

  sprite(id) {
    return this.sprites.get(id, this.ctx);
  }

  invalidateSector(id) {
    this.sectors.invalidate(id);
  }

  invalidateWall(id) {
    this.walls.invalidate(id);
  }

  invalidateSprite(id) {
    this.sprites.invalidate(id);
  }

  invalidateAll() {
    this.sectors.invalidateAll();
    this.walls.invalidateAll();
    this.sprites.invalidateAll();
  }

}
class CachedSelectedRenderableProvider {
  constructor(ctx, cache) {
    this.sectors = new CacheMap((ctx, id, value) => Object(_builders_selected__WEBPACK_IMPORTED_MODULE_14__["updateSectorSelected"])(this.cache, ctx, id, value));
    this.walls = new CacheMap((ctx, id, value) => Object(_builders_selected__WEBPACK_IMPORTED_MODULE_14__["updateWallSelected"])(this.cache, ctx, id, value));
    this.ctx = ctx;
    this.cache = cache;
  }

  sector(id) {
    return this.sectors.get(id, this.ctx);
  }

  sectorCluster(id) {
    throw new Error('Cant render clusters');
  }

  wall(id) {
    return this.walls.get(id, this.ctx);
  }

  wallPoint(id) {
    return null;
  }

  sprite(id) {
    return null;
  }

}
class CachedHelperBuildRenderableProvider {
  constructor(ctx, cache) {
    this.sectors = new CacheMap((ctx, id, value) => Object(_builders_sectorhelper__WEBPACK_IMPORTED_MODULE_5__["updateSectorHelper"])(this.cache, ctx, id, value));
    this.walls = new CacheMap((ctx, id, value) => Object(_builders_wallhelper__WEBPACK_IMPORTED_MODULE_11__["updateWallHelper"])(this.cache, ctx, id, value));
    this.sprites = new CacheMap(_builders_spritehelper__WEBPACK_IMPORTED_MODULE_8__["updateSpriteHelper"]);
    this.wallPoints = new CacheMap(_builders_wallpointhelper__WEBPACK_IMPORTED_MODULE_12__["updateWallPoint"]);
    this.ctx = ctx;
    this.cache = cache;
  }

  sector(id) {
    return this.sectors.get(id, this.ctx);
  }

  sectorCluster(id) {
    throw new Error('Cant render clusters');
  }

  wall(id) {
    return this.walls.get(id, this.ctx);
  }

  wallPoint(id) {
    return this.wallPoints.get(id, this.ctx);
  }

  sprite(id) {
    return this.sprites.get(id, this.ctx);
  }

  invalidateSector(id) {
    this.sectors.invalidate(id);
  }

  invalidateSprite(id) {
    this.sprites.invalidate(id);
  }

  invalidateWall(id) {
    this.walls.invalidate(id);
    this.wallPoints.invalidate(id);
  }

  invalidateAll() {
    this.sectors.invalidateAll();
    this.walls.invalidateAll();
    this.sprites.invalidateAll();
    this.wallPoints.invalidateAll();
  }

}
var RENDRABLES_CACHE = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('RenderablesCache');
class RenderablesCacheContext {
  constructor() {
    this.board = void 0;
    this.art = void 0;
    this.factory = void 0;
    this.state = void 0;
  }

}
var RENDERABLES_CACHE_CONTEXT = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('RenderablesCacheContext');

function RenderablesCacheContextConstructor(_x) {
  return _RenderablesCacheContextConstructor.apply(this, arguments);
}

function _RenderablesCacheContextConstructor() {
  _RenderablesCacheContextConstructor = _asyncToGenerator(function* (injector) {
    var [board, art, factory, state] = yield Promise.all([injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["ART"]), injector.getInstance(_common__WEBPACK_IMPORTED_MODULE_13__["BUILDERS_FACTORY"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["STATE"])]);
    return {
      board,
      art,
      factory,
      state
    };
  });
  return _RenderablesCacheContextConstructor.apply(this, arguments);
}

function RenderablesCacheConstructor(_x2) {
  return _RenderablesCacheConstructor.apply(this, arguments);
}

function _RenderablesCacheConstructor() {
  _RenderablesCacheConstructor = _asyncToGenerator(function* (injector) {
    return Object(_utils_injector__WEBPACK_IMPORTED_MODULE_0__["create"])(injector, RenderablesCacheImpl, RENDERABLES_CACHE_CONTEXT, _apis_app__WEBPACK_IMPORTED_MODULE_1__["SCHEDULER"]);
  });
  return _RenderablesCacheConstructor.apply(this, arguments);
}

var WALL_COLOR = 'wallColor';
var MASKED_WALL_COLOR = 'maskedWallColor';
var INTERSECTOR_WALL_COLOR = 'intersectorWallColor';
var SPRITE_COLOR = 'spriteColor';
function RenderablesCacheModule(_x3) {
  return _RenderablesCacheModule.apply(this, arguments);
}

function _RenderablesCacheModule() {
  _RenderablesCacheModule = _asyncToGenerator(function* (module) {
    module.bind(RENDERABLES_CACHE_CONTEXT, RenderablesCacheContextConstructor);
    module.bind(RENDRABLES_CACHE, RenderablesCacheConstructor);
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var state = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_1__["STATE"]);
        state.register(WALL_COLOR, [1, 1, 1, 1]);
        state.register(INTERSECTOR_WALL_COLOR, [1, 0, 0, 1]);
        state.register(MASKED_WALL_COLOR, [0, 0, 1, 1]);
        state.register(SPRITE_COLOR, [0, 1, 1, 1]);
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]);
        var cache = yield injector.getInstance(RENDRABLES_CACHE);
        bus.connect(cache);
      });

      return function (_x4) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _RenderablesCacheModule.apply(this, arguments);
}

class RenderablesCacheImpl extends _apis_handler__WEBPACK_IMPORTED_MODULE_2__["MessageHandlerReflective"] {
  constructor(ctx, scheduler) {
    super();
    this.geometry = void 0;
    this.helpers = void 0;
    this.topdown = void 0;
    this.selected = void 0;
    this.preloadTask = void 0;
    this.ctx = ctx;
    this.scheduler = scheduler;
    this.geometry = new CachedBuildRenderableProvider(ctx);
    this.helpers = new CachedHelperBuildRenderableProvider(ctx, this.geometry);
    this.topdown = new CachedTopDownBuildRenderableProvider(ctx);
    this.selected = new CachedSelectedRenderableProvider(ctx, this.geometry);
    this.launchPrebuild();
  }

  launchPrebuild() {
    if (this.preloadTask != null) this.preloadTask.stop();
    this.preloadTask = this.scheduler.addTask(this.prebuild());
  }

  *prebuild() {
    var handle = yield;
    handle.setDescription('Prebuild...');
    var board = this.ctx.board();

    for (var i = 0; i < board.sectors.length; i++) {
      this.geometry.sector(i);
      this.topdown.sector(i);
      handle.setDescription("Prebuild. Sector " + i);
      handle = yield;
    }

    handle.setProgress(33);

    for (var _i = 0; _i < board.walls.length; _i++) {
      this.geometry.wall(_i);
      this.helpers.wall(_i);
      handle.setDescription("Prebuild. Wall " + _i);
      handle = yield;
    }

    handle.setProgress(66);

    for (var _i2 = 0; _i2 < board.sprites.length; _i2++) {
      this.geometry.sprite(_i2);
      this.topdown.sprite(_i2);
      handle.setDescription("Prebuild. Sprite " + _i2);
      handle = yield;
    }
  }

  LoadBoard(msg) {
    this.invalidateAll();
    this.launchPrebuild();
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.invalidateAll();else if (msg.ent.isSector()) this.invalidateSector(msg.ent.id);else if (msg.ent.isSprite()) this.invalidateSprite(msg.ent.id);else if (msg.ent.isWall()) this.invalidateWall(msg.ent.id);
  }

  invalidateAll() {
    this.geometry.invalidateAll();
    this.helpers.invalidateAll();
    this.topdown.invalidateAll();
  }

  invalidateSector(id) {
    this.geometry.invalidateSector(id);
    this.helpers.invalidateSector(id);
    this.topdown.invalidateSector(id);
  }

  invalidateWall(id) {
    this.geometry.invalidateWall(id);
    this.helpers.invalidateWall(id);
    this.topdown.invalidateWall(id);
  }

  invalidateSprite(id) {
    this.geometry.invalidateSprite(id);
    this.helpers.invalidateSprite(id);
    this.topdown.invalidateSprite(id);
  }

}

/***/ }),

/***/ "./src/app/modules/geometry/common.ts":
/*!********************************************!*\
  !*** ./src/app/modules/geometry/common.ts ***!
  \********************************************/
/*! exports provided: BUILDERS_FACTORY, DefaultBuildersFactory, Type, SolidBuilder, GridBuilder, FlatBuilder, PointSpriteBuilder, WireframeBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUILDERS_FACTORY", function() { return BUILDERS_FACTORY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultBuildersFactory", function() { return DefaultBuildersFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Type", function() { return Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidBuilder", function() { return SolidBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridBuilder", function() { return GridBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatBuilder", function() { return FlatBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSpriteBuilder", function() { return PointSpriteBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeBuilder", function() { return WireframeBuilder; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _gl_buffers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gl/buffers */ "./src/app/modules/gl/buffers.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
/* harmony import */ var _builders_setups__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./builders/setups */ "./src/app/modules/geometry/builders/setups.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }







var BUILDERS_FACTORY = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('Builder Factory');
function DefaultBuildersFactory(_x) {
  return _DefaultBuildersFactory.apply(this, arguments);
}

function _DefaultBuildersFactory() {
  _DefaultBuildersFactory = _asyncToGenerator(function* (injector) {
    var bufferFactory = yield injector.getInstance(_gl_buffers__WEBPACK_IMPORTED_MODULE_3__["BUFFER_FACTORY"]);
    var buildgl = yield injector.getInstance(_gl_buildgl__WEBPACK_IMPORTED_MODULE_4__["BUILD_GL"]);
    var grid = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_2__["GRID"]);

    var solidSetup = () => new _builders_setups__WEBPACK_IMPORTED_MODULE_5__["SolidSetup"](buildgl.state);

    var gridSetup = () => new _builders_setups__WEBPACK_IMPORTED_MODULE_5__["GridSetup"](buildgl.state);

    var bufferSetup = () => new _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferSetup"](buildgl.state);

    var pointspriteSetup = () => new _builders_setups__WEBPACK_IMPORTED_MODULE_5__["PointSpriteSetup"](buildgl.state);

    var wireframeSetup = () => new _builders_setups__WEBPACK_IMPORTED_MODULE_5__["WireframeSetup"](buildgl.state);

    return {
      solid: hint => new SolidBuilder(solidSetup(), bufferFactory.get('solid-' + hint)),
      grid: function (_grid) {
        function grid(_x2) {
          return _grid.apply(this, arguments);
        }

        grid.toString = function () {
          return _grid.toString();
        };

        return grid;
      }(hint => new GridBuilder(gridSetup(), grid)),
      flat: hint => new FlatBuilder(bufferSetup()),
      pointSprite: hint => new PointSpriteBuilder(pointspriteSetup(), bufferFactory.get('pointsprite-' + hint)),
      wireframe: hint => new WireframeBuilder(wireframeSetup(), bufferFactory.get('wireframe-' + hint))
    };
  });
  return _DefaultBuildersFactory.apply(this, arguments);
}

var Type;

(function (Type) {
  Type[Type["SURFACE"] = 0] = "SURFACE";
  Type[Type["FACE"] = 1] = "FACE";
})(Type || (Type = {}));

class SolidBuilder extends _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferRenderable"] {
  constructor(setup, buff) {
    super(setup);
    this.type = Type.SURFACE;
    this.tex = void 0;
    this.trans = 1;
    this.parallax = 0;
    this.color = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].create();
    this.buff = buff;
  }

  textureHint() {
    return this.tex;
  }

  applySetup(setup) {
    setup.shader(this.type == Type.SURFACE ? this.parallax ? 'parallax' : 'baseShader' : 'spriteShader').base(this.tex).color(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.color, 1, 1, 1, this.trans));
  }

  reset() {
    this.buff.deallocate();
    this.type = Type.SURFACE;
    this.trans = 1;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.color, 1, 1, 1, 1);
    this.parallax = 0;
    this.tex = null;
  }

}
class GridBuilder extends _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferRenderable"] {
  constructor(setup, grid) {
    super(setup);
    this.solid = void 0;
    this.gridTexMat = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this.range = 4.0;
    this.gridSettings = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].create();
    this.grid = grid;
  }

  get buff() {
    return this.solid.buff;
  }

  reset() {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this.gridTexMat);
  }

  textureHint() {
    return null;
  }

  applySetup(setup) {
    setup.shader('grid').grid(this.gridTexMat).gridSettings(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.gridSettings, this.grid.getGridSize(), this.range, 0, 0));
  }

  drawCall(consumer) {
    this.needToRebuild();
    super.drawCall(consumer);
  }

}
class FlatBuilder extends _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferRenderable"] {
  constructor(setup) {
    super(setup);
    this.solid = void 0;
  }

  get buff() {
    return this.solid.buff;
  }

  reset() {}

  textureHint() {
    return null;
  }

  applySetup(setup) {
    setup.shader('baseFlatShader');
  }

  drawCall(consumer) {
    this.needToRebuild();
    super.drawCall(consumer);
  }

}
class PointSpriteBuilder extends _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferRenderable"] {
  constructor(setup, buff) {
    super(setup);
    this.tex = void 0;
    this.color = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].fromValues(1, 1, 1, 1);
    this.buff = buff;
  }

  applySetup(setup) {
    setup.shader('spriteFaceShader').base(this.tex).color(this.color);
  }

  textureHint() {
    return this.tex;
  }

  reset() {
    this.buff.deallocate();
    this.tex = null;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.color, 1, 1, 1, 1);
  }

}
class WireframeBuilder extends _builders_setups__WEBPACK_IMPORTED_MODULE_5__["BufferRenderable"] {
  constructor(setup, buff) {
    super(setup);
    this.type = Type.SURFACE;
    this.color = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].fromValues(1, 1, 1, 1);
    this.mode = WebGLRenderingContext.LINES;
    this.buff = buff;
  }

  applySetup(setup) {
    setup.shader(this.type == Type.SURFACE ? 'baseFlatShader' : 'spriteFlatShader').color(this.color);
  }

  textureHint() {
    return null;
  }

  clr(r, g, b, a) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.color, r, g, b, a);
    return this;
  }

  reset() {
    this.buff.deallocate();
    this.type = Type.SURFACE;
    this.mode = WebGLRenderingContext.LINES;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(this.color, 1, 1, 1, 1);
  }

}

/***/ }),

/***/ "./src/app/modules/gl/buffers.ts":
/*!***************************************!*\
  !*** ./src/app/modules/gl/buffers.ts ***!
  \***************************************/
/*! exports provided: BUFFER_FACTORY, DefaultBufferFactory, PointSpritesBuilder, LineBuilder, BuildBufferImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUFFER_FACTORY", function() { return BUFFER_FACTORY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultBufferFactory", function() { return DefaultBufferFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointSpritesBuilder", function() { return PointSpritesBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBuilder", function() { return LineBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildBufferImpl", function() { return BuildBufferImpl; });
/* harmony import */ var _utils_gl_buffergl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/gl/buffergl */ "./src/utils/gl/buffergl.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _buildartprovider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buildartprovider */ "./src/app/modules/buildartprovider.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var BUFFER_FACTORY = new _utils_injector__WEBPACK_IMPORTED_MODULE_1__["Dependency"]('Build Buffer Factory');
function DefaultBufferFactory(_x) {
  return _DefaultBufferFactory.apply(this, arguments);
}

function _DefaultBufferFactory() {
  _DefaultBufferFactory = _asyncToGenerator(function* (injector) {
    var gl = yield injector.getInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_2__["GL"]);
    return new BuildBufferFactoryImpl(gl);
  });
  return _DefaultBufferFactory.apply(this, arguments);
}

class PointSpritesBuilder {
  constructor() {
    this.sprites = [];
  }

  add(x, y, z) {
    this.sprites.push([x, y, z]);
  }

  build(buff, d) {
    var size = this.sprites.length;
    buff.allocate(size * 4, size * 6);

    for (var i = 0; i < size; i++) {
      var _off = i * 4;

      var [_x2, _y, _z] = this.sprites[i];
      buff.writePos(_off + 0, _x2, _y, _z);
      buff.writePos(_off + 1, _x2, _y, _z);
      buff.writePos(_off + 2, _x2, _y, _z);
      buff.writePos(_off + 3, _x2, _y, _z);
      buff.writeTcLighting(_off + 0, 0, 0);
      buff.writeTcLighting(_off + 1, 1, 0);
      buff.writeTcLighting(_off + 2, 1, 1);
      buff.writeTcLighting(_off + 3, 0, 1);
      buff.writeNormal(_off + 0, -d, d, 0);
      buff.writeNormal(_off + 1, d, d, 0);
      buff.writeNormal(_off + 2, d, -d, 0);
      buff.writeNormal(_off + 3, -d, -d, 0);
      buff.writeQuad(i * 6, _off, _off + 1, _off + 2, _off + 3);
    }
  }

}
class LineBuilder {
  constructor() {
    this.vtxIndex = new Map();
    this.linesIndex = new Set();
    this.vtxs = [];
    this.lines = [];
  }

  segment(x1, y1, z1, x2, y2, z2) {
    var idx1 = this.addVtx(x1, y1, z1);
    var idx2 = this.addVtx(x2, y2, z2);
    this.addLine(idx1, idx2);
  }

  rect(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    this.segment(x1, y1, z1, x2, y2, z2);
    this.segment(x2, y2, z2, x3, y3, z3);
    this.segment(x3, y3, z3, x4, y4, z4);
    this.segment(x4, y4, z4, x1, y1, z1);
  }

  build(buff) {
    buff.allocate(this.vtxs.length, this.lines.length * 2);

    for (var i = 0; i < this.vtxs.length; i++) {
      var vtx = this.vtxs[i];
      buff.writePos(i, vtx[0], vtx[1], vtx[2]);
    }

    for (var _i = 0; _i < this.lines.length; _i++) {
      var line = this.lines[_i];
      buff.writeLine(_i * 2, line[0], line[1]);
    }
  }

  addVtx(x, y, z) {
    var key = x + "," + y + "," + z;
    var idx = this.vtxIndex.get(key);

    if (idx == undefined) {
      idx = this.vtxs.length;
      this.vtxIndex.set(key, idx);
      this.vtxs.push([x, y, z]);
    }

    return idx;
  }

  addLine(idx1, idx2) {
    if (idx1 == idx2) return;
    var key = idx1 + "," + idx2;
    this.linesIndex.has(key);

    if (!this.linesIndex.has(key)) {
      this.linesIndex.add(key);
      this.lines.push([idx1, idx2]);
    }
  }

}
var POSITION = 0;
var NORMAL = 1;
var TEX_SHADING = 2;

class BuildBufferFactoryImpl {
  constructor(gl) {
    this.buffers = new Map();
    this.gl = gl;
  }

  addNewBuffer(hint) {
    var buffer = new _utils_gl_buffergl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](this.gl, new _utils_gl_buffergl__WEBPACK_IMPORTED_MODULE_0__["BufferBuilder"]().addVertexBuffer(this.gl, this.gl.FLOAT, 3).addVertexBuffer(this.gl, this.gl.FLOAT, 3).addVertexBuffer(this.gl, this.gl.FLOAT, 4));
    var buffers = this.buffers.get(hint);
    buffers.push(buffer);
    return buffer;
  }

  get(hint) {
    var buffers = this.buffers.get(hint);

    if (buffers == undefined) {
      buffers = [];
      this.buffers.set(hint, buffers);
    }

    return new BuildBufferImpl(this, hint);
  }

  allocate(hint, vtxSize, idxSize) {
    for (var buff of this.buffers.get(hint)) {
      var ptr = buff.allocate(vtxSize, idxSize);
      if (ptr != null) return ptr;
    }

    return this.addNewBuffer(hint).allocate(vtxSize, idxSize);
  }

}

class BuildBufferImpl {
  constructor(factory, hint) {
    this.ptr = void 0;
    this.size = 0;
    this.factory = factory;
    this.hint = hint;
  }

  get() {
    return this.ptr;
  }

  getSize() {
    return this.size;
  }

  remove() {
    this.ptr.buffer.deallocate(this.ptr);
  }

  allocate(vtxCount, triIndexCount) {
    if (this.ptr != null) {
      if (this.ptr.vtx.size >= vtxCount && this.ptr.idx.size >= triIndexCount) {
        this.size = triIndexCount;
        return;
      }

      this.remove();
    }

    this.ptr = this.factory.allocate(this.hint, vtxCount, triIndexCount);
    this.size = this.ptr.idx.size;
  }

  deallocate() {
    if (this.ptr != null) {
      this.remove();
      this.ptr = null;
      this.size = 0;
    }
  }

  writePos(off, x, y, z) {
    this.ptr.buffer.writeVertex(this.ptr, POSITION, off, [x, y, z]);
    return off + 1;
  }

  writeNormal(off, x, y, z) {
    this.ptr.buffer.writeVertex(this.ptr, NORMAL, off, [x, y, z]);
    return off + 1;
  }

  writeTcLighting(off, u, v, pal, shade) {
    if (pal === void 0) {
      pal = 0;
    }

    if (shade === void 0) {
      shade = 0;
    }

    this.ptr.buffer.writeVertex(this.ptr, TEX_SHADING, off, [u, v, pal, shade]);
    return off + 1;
  }

  writeTriangle(off, a, b, c) {
    this.ptr.buffer.writeIndex(this.ptr, off, [a, b, c]);
    return off + 3;
  }

  writeQuad(off, a, b, c, d) {
    this.ptr.buffer.writeIndex(this.ptr, off, [a, c, b, a, d, c]);
    return off + 6;
  }

  writeLine(off, a, b) {
    this.ptr.buffer.writeIndex(this.ptr, off, [a, b]);
    return off + 2;
  }

  getPosBuffer() {
    return this.ptr.buffer.getVertexBuffer(POSITION);
  }

  getNormBuffer() {
    return this.ptr.buffer.getVertexBuffer(NORMAL);
  }

  getTexCoordBuffer() {
    return this.ptr.buffer.getVertexBuffer(TEX_SHADING);
  }

  getIdxBuffer() {
    return this.ptr.buffer.getIndexBuffer();
  }

}

/***/ }),

/***/ "./src/app/modules/gl/buildgl.ts":
/*!***************************************!*\
  !*** ./src/app/modules/gl/buildgl.ts ***!
  \***************************************/
/*! exports provided: PAL_TEXTURE, PLU_TEXTURE, SHADOWSTEPS, PALSWAPS, BUILD_GL, BuildGlConstructor, BuildGl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAL_TEXTURE", function() { return PAL_TEXTURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLU_TEXTURE", function() { return PLU_TEXTURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHADOWSTEPS", function() { return SHADOWSTEPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PALSWAPS", function() { return PALSWAPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUILD_GL", function() { return BUILD_GL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildGlConstructor", function() { return BuildGlConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildGl", function() { return BuildGl; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/gl/shaders */ "./src/utils/gl/shaders.ts");
/* harmony import */ var _utils_gl_stategl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/gl/stategl */ "./src/utils/gl/stategl.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _buildartprovider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../buildartprovider */ "./src/app/modules/buildartprovider.ts");







var PAL_TEXTURE = new _utils_injector__WEBPACK_IMPORTED_MODULE_3__["Dependency"]('PAL Texture');
var PLU_TEXTURE = new _utils_injector__WEBPACK_IMPORTED_MODULE_3__["Dependency"]('PLU Texture');
var SHADOWSTEPS = new _utils_injector__WEBPACK_IMPORTED_MODULE_3__["Dependency"]('Shadowsteps');
var PALSWAPS = new _utils_injector__WEBPACK_IMPORTED_MODULE_3__["Dependency"]('Palswaps');
var BUILD_GL = new _utils_injector__WEBPACK_IMPORTED_MODULE_3__["Dependency"]('BuildGL');
function BuildGlConstructor(injector) {
  return new Promise(resolve => Promise.all([injector.getInstance(_buildartprovider__WEBPACK_IMPORTED_MODULE_6__["GL"]), injector.getInstance(PAL_TEXTURE), injector.getInstance(PLU_TEXTURE), injector.getInstance(PALSWAPS), injector.getInstance(SHADOWSTEPS)]).then((_ref) => {
    var [gl, pal, plus, plaswaps, shadowsteps] = _ref;
    var buildgl = new BuildGl(plaswaps, shadowsteps, gl, pal, plus, () => resolve(buildgl));
  }));
}
var SHADER_NAME = 'resources/shaders/build';
var inv = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
var pos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var clipPlane = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].create();
class BuildGl {
  constructor(palswaps, shadowsteps, gl, pal, plus, cb) {
    this.state = new _utils_gl_stategl__WEBPACK_IMPORTED_MODULE_2__["State"]();
    this.gl = gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    var defs = ['PALSWAPS (' + palswaps + '.0)', 'SHADOWSTEPS (' + shadowsteps + '.0)', 'PAL_LIGHTING'
    /*, 'DITHERING'*/
    ];
    Promise.all([Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs]).then(shader => this.state.registerShader('baseShader', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'SPRITE']).then(shader => this.state.registerShader('spriteShader', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'FLAT']).then(shader => this.state.registerShader('baseFlatShader', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'SPRITE', 'FLAT']).then(shader => this.state.registerShader('spriteFlatShader', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'PARALLAX']).then(shader => this.state.registerShader('parallax', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'GRID']).then(shader => this.state.registerShader('grid', shader)), Object(_utils_gl_shaders__WEBPACK_IMPORTED_MODULE_1__["createShader"])(gl, SHADER_NAME, [...defs, 'SPRITE_FACE']).then(shader => this.state.registerShader('spriteFaceShader', shader))]).then(r => {
      this.state.setTexture('pal', pal);
      this.state.setTexture('plu', plus);
      cb();
    });
  }

  setProjectionMatrix(proj) {
    this.state.setUniform('P', proj);
  }

  setPosition(pos) {
    this.state.setUniform('eyepos', pos);
  }

  setViewMatrix(view) {
    this.state.setUniform('V', view);
    if (this.state.isUniformEnabled('IV')) this.state.setUniform('IV', _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(inv, view));
  }

  setCursorPosiotion(x, y, z) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(pos, x, y, z);
    this.state.setUniform('curpos', pos);
  }

  setClipPlane(x, y, z, w) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].set(clipPlane, x, y, z, w);
    this.state.setUniform('clipPlane', clipPlane);
  }

  draw(renderable) {
    if (renderable == null) return;
    renderable.drawCall(dc => this.state.run(this.gl, dc));
  }

  newFrame() {
    this.updateProfile(this.state.profile);
    this.gl.clearColor(0.2, 0.2, 0.2, 1.0);
    this.gl.clearStencil(0);
    this.gl.clearDepth(1);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);
    this.state.setUniform('sys', [performance.now(), this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, 0]);
    this.modulation(1, 1, 1, 1);
  }

  modulation(r, g, b, a) {
    if (this.state.isUniformEnabled('modulation')) this.state.setUniform('modulation', [r, g, b, a]);
  }

  updateProfile(profile) {
    var p = _utils_profiler__WEBPACK_IMPORTED_MODULE_5__["get"](null);
    p.set('drawsRequested', profile.drawsRequested);
    p.set('drawsMerged', profile.drawsMerged);
    p.set('shaderChanges', profile.shaderChanges);
    p.set('uniformChanges', profile.uniformChanges);
    p.set('textureChanges', profile.textureChanges);
    p.set('bufferChanges', profile.bufferChanges);
    profile.reset();
  }

  printInfo() {
    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_4__["info"])(this.state.profile);
  }

  flush() {
    this.state.flush(this.gl);
  }

}

/***/ }),

/***/ "./src/app/modules/info.tsx":
/*!**********************************!*\
  !*** ./src/app/modules/info.tsx ***!
  \**********************************/
/*! exports provided: InfoModule, Info */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InfoModule", function() { return InfoModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Info", function() { return Info; });
/* harmony import */ var solid_js_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js/dom */ "./node_modules/solid-js/dist/dom/index.js");
/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! solid-js */ "./node_modules/solid-js/dist/index.js");
/* harmony import */ var stage0__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stage0 */ "./node_modules/stage0/index.js");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");







const _tmpl$ = Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["template"])(`<tr><td></td><td><span></span></td></tr>`, 8);

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["<table class=\"table-striped\" #table><tbody></tbody></table>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["<tr><td>#nameNode</td><td>#valueNode</td></tr>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }








function InfoModule(_x) {
  return _InfoModule.apply(this, arguments);
}

function _InfoModule() {
  _InfoModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
        bus.connect(yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_4__["create"])(injector, Info, _apis_app__WEBPACK_IMPORTED_MODULE_5__["VIEW"], _apis_app__WEBPACK_IMPORTED_MODULE_5__["BOARD"]));
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
  });
  return _InfoModule.apply(this, arguments);
}

var rowTemplate = Object(stage0__WEBPACK_IMPORTED_MODULE_2__["default"])(_templateObject());

function createRow(name) {
  var root = rowTemplate.cloneNode(true);
  var {
    nameNode,
    valueNode
  } = rowTemplate.collect(root);
  nameNode.nodeValue = name;

  var update = v => valueNode.nodeValue = v;

  return [root, update];
}

var rowsTemplate = Object(stage0__WEBPACK_IMPORTED_MODULE_2__["default"])(_templateObject2());

function createSprite() {
  var root = rowsTemplate.cloneNode(true);
  var {
    table
  } = rowsTemplate.collect(root);
  var [head, headUpdater] = createRow("Type");
  var [id, idUpdater] = createRow("Id");
  var [picnum, picnumUpdater] = createRow("Picnum");
  var [shade, shadeUpdater] = createRow("Shade");
  var [pal, palUpdater] = createRow("Palette");
  var [offset, offsetUpdater] = createRow("Offset");
  var [repeat, repeatUpdater] = createRow("Repeat");
  var [z, zUpdater] = createRow("Z");
  table.appendChild(head);
  table.appendChild(id);
  table.appendChild(picnum);
  table.appendChild(shade);
  table.appendChild(pal);
  table.appendChild(offset);
  table.appendChild(repeat);
  table.appendChild(z);
  headUpdater('Sprite');
}

var Row = ref => {
  return () => (() => {
    var _el$ = _tmpl$.cloneNode(true),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.nextSibling,
        _el$4 = _el$3.firstChild;

    Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["insert"])(_el$2, () => ref.name);

    Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["insert"])(_el$4, () => ref.value ? ref.value : "");

    return _el$;
  })();
};

var SpriteProperties = ref => {
  return () => [Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Type",
    value: "Sprite"
  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Id",

    get value() {
      return ref.id;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Picnum",

    get value() {
      var _ref$sprite;

      return (_ref$sprite = ref.sprite) == null ? void 0 : _ref$sprite.picnum;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Shade",

    get value() {
      var _ref$sprite2;

      return (_ref$sprite2 = ref.sprite) == null ? void 0 : _ref$sprite2.shade;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Palette",

    get value() {
      var _ref$sprite3;

      return (_ref$sprite3 = ref.sprite) == null ? void 0 : _ref$sprite3.pal;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Offset",

    get value() {
      var _ref$sprite$xoffset, _ref$sprite4, _ref$sprite$yoffset, _ref$sprite5;

      return ((_ref$sprite$xoffset = (_ref$sprite4 = ref.sprite) == null ? void 0 : _ref$sprite4.xoffset) != null ? _ref$sprite$xoffset : '') + ", " + ((_ref$sprite$yoffset = (_ref$sprite5 = ref.sprite) == null ? void 0 : _ref$sprite5.yoffset) != null ? _ref$sprite$yoffset : '');
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Repeat",

    get value() {
      var _ref$sprite$xrepeat, _ref$sprite6, _ref$sprite$yrepeat, _ref$sprite7;

      return ((_ref$sprite$xrepeat = (_ref$sprite6 = ref.sprite) == null ? void 0 : _ref$sprite6.xrepeat) != null ? _ref$sprite$xrepeat : '') + ", " + ((_ref$sprite$yrepeat = (_ref$sprite7 = ref.sprite) == null ? void 0 : _ref$sprite7.yrepeat) != null ? _ref$sprite$yrepeat : '');
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Z",

    get value() {
      var _ref$sprite8;

      return (_ref$sprite8 = ref.sprite) == null ? void 0 : _ref$sprite8.z;
    }

  })];
};

var WallProperties = ref => {
  return () => [Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Type",
    value: "Wall"
  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Id",

    get value() {
      return ref.id;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Picnum",

    get value() {
      var _ref$wall;

      return (_ref$wall = ref.wall) == null ? void 0 : _ref$wall.picnum;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Shade",

    get value() {
      var _ref$wall2;

      return (_ref$wall2 = ref.wall) == null ? void 0 : _ref$wall2.shade;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Palette",

    get value() {
      var _ref$wall3;

      return (_ref$wall3 = ref.wall) == null ? void 0 : _ref$wall3.pal;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Panning",

    get value() {
      var _ref$wall$xpanning, _ref$wall4, _ref$wall$ypanning, _ref$wall5;

      return ((_ref$wall$xpanning = (_ref$wall4 = ref.wall) == null ? void 0 : _ref$wall4.xpanning) != null ? _ref$wall$xpanning : '') + ", " + ((_ref$wall$ypanning = (_ref$wall5 = ref.wall) == null ? void 0 : _ref$wall5.ypanning) != null ? _ref$wall$ypanning : '');
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Repeat",

    get value() {
      var _ref$wall$xrepeat, _ref$wall6, _ref$wall$yrepeat, _ref$wall7;

      return ((_ref$wall$xrepeat = (_ref$wall6 = ref.wall) == null ? void 0 : _ref$wall6.xrepeat) != null ? _ref$wall$xrepeat : '') + ", " + ((_ref$wall$yrepeat = (_ref$wall7 = ref.wall) == null ? void 0 : _ref$wall7.yrepeat) != null ? _ref$wall$yrepeat : '');
    }

  })];
};

var SectorProperties = ref => {
  return () => [Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Type",
    value: "Sector"
  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Id",

    get value() {
      return ref.id;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Picnum",

    get value() {
      var _ref$sector;

      return (_ref$sector = ref.sector) == null ? void 0 : _ref$sector.floorpicnum;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Shade",

    get value() {
      var _ref$sector2;

      return (_ref$sector2 = ref.sector) == null ? void 0 : _ref$sector2.floorshade;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Palette",

    get value() {
      var _ref$sector3;

      return (_ref$sector3 = ref.sector) == null ? void 0 : _ref$sector3.floorpal;
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Panning",

    get value() {
      var _ref$sector$floorxpan, _ref$sector4, _ref$sector$floorypan, _ref$sector5;

      return ((_ref$sector$floorxpan = (_ref$sector4 = ref.sector) == null ? void 0 : _ref$sector4.floorxpanning) != null ? _ref$sector$floorxpan : '') + ", " + ((_ref$sector$floorypan = (_ref$sector5 = ref.sector) == null ? void 0 : _ref$sector5.floorypanning) != null ? _ref$sector$floorypan : '');
    }

  }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
    name: "Z",

    get value() {
      var _ref$sector6;

      return (_ref$sector6 = ref.sector) == null ? void 0 : _ref$sector6.floorz;
    }

  })];
};

var InfoPanel = (_ref) => {
  var {
    state
  } = _ref;
  return () => Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["Switch"], {
    get fallback() {
      return Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(Row, {
        name: "Type",
        value: "Value"
      });
    },

    get children() {
      return [Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["Match"], {
        get when() {
          return Object(_build_hitscan__WEBPACK_IMPORTED_MODULE_3__["isSprite"])(state.type);
        },

        get children() {
          return Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(SpriteProperties, {
            get id() {
              return state.id;
            },

            get sprite() {
              return state.board().sprites[state.id];
            }

          });
        }

      }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["Match"], {
        get when() {
          return Object(_build_hitscan__WEBPACK_IMPORTED_MODULE_3__["isSector"])(state.type);
        },

        get children() {
          return Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(SectorProperties, {
            get id() {
              return state.id;
            },

            get sector() {
              return state.board().sectors[state.id];
            }

          });
        }

      }), Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["Match"], {
        get when() {
          return Object(_build_hitscan__WEBPACK_IMPORTED_MODULE_3__["isWall"])(state.type);
        },

        get children() {
          return Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(WallProperties, {
            get id() {
              return state.id;
            },

            get wall() {
              return state.board().walls[state.id];
            }

          });
        }

      })];
    }

  });
};

class InfoPanelState {
  constructor(board) {
    this.id = void 0;
    this.type = void 0;
    this.board = board;
  }

}

class Info extends _apis_handler__WEBPACK_IMPORTED_MODULE_6__["MessageHandlerReflective"] {
  constructor(view, board) {
    super();
    this.state = void 0;
    this.setState = void 0;
    this.view = view;
    this.board = board;
    var [state, setState] = Object(solid_js__WEBPACK_IMPORTED_MODULE_1__["createState"])(new InfoPanelState(this.board));
    this.state = state;
    this.setState = setState;
    Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["render"])(() => Object(solid_js_dom__WEBPACK_IMPORTED_MODULE_0__["createComponent"])(InfoPanel, {
      state: state
    }), document.getElementById('info_panel'));
  }

  Frame(msg) {
    var ent = this.view.snapTarget().entity;
    if (ent == null) this.setState({
      id: 0,
      type: null
    });else this.setState({
      id: ent.id,
      type: ent.type
    });
  }

  BoardInvalidate(msg) {
    if (msg.ent == null) this.setState('type', this.state.type);else if (this.state.type == null) return;else if (msg.ent.id == this.state.id) this.setState('type', this.state.type);
  }

}

/***/ }),

/***/ "./src/app/modules/input.ts":
/*!**********************************!*\
  !*** ./src/app/modules/input.ts ***!
  \**********************************/
/*! exports provided: InputModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputModule", function() { return InputModule; });
/* harmony import */ var _app_input_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../app/input/keymap */ "./src/app/input/keymap.ts");
/* harmony import */ var _app_input_messageparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../app/input/messageparser */ "./src/app/input/messageparser.ts");
/* harmony import */ var _app_modules_buildartprovider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../app/modules/buildartprovider */ "./src/app/modules/buildartprovider.ts");
/* harmony import */ var _utils_getter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/getter */ "./src/utils/getter.ts");
/* harmony import */ var _utils_input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/input */ "./src/utils/input.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../edit/messages */ "./src/app/edit/messages.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }









var MOUSE = new _edit_messages__WEBPACK_IMPORTED_MODULE_7__["Mouse"](0, 0);
function InputModule(module) {
  module.execute( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (injector) {
      var gl = yield injector.getInstance(_app_modules_buildartprovider__WEBPACK_IMPORTED_MODULE_2__["GL"]);
      var keybinds = yield Object(_utils_getter__WEBPACK_IMPORTED_MODULE_3__["loadString"])('builded_binds.txt');
      var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_6__["BUS"]);
      var state = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_5__["STATE"]);
      var binder = new _app_input_keymap__WEBPACK_IMPORTED_MODULE_0__["Binder"]();
      Object(_app_input_keymap__WEBPACK_IMPORTED_MODULE_0__["loadBinds"])(keybinds, binder, _app_input_messageparser__WEBPACK_IMPORTED_MODULE_1__["messageParser"]);
      Object(_utils_input__WEBPACK_IMPORTED_MODULE_4__["bind"])(gl.canvas);
      bus.connect(new class extends _apis_handler__WEBPACK_IMPORTED_MODULE_6__["MessageHandlerReflective"] {
        mouseMove(input) {
          if (MOUSE.x == input.mouseX && MOUSE.y == input.mouseY) return;
          MOUSE.x = input.mouseX;
          MOUSE.y = input.mouseY;
          bus.handle(MOUSE);
        }

        PostFrame(msg) {
          var inputState = Object(_utils_input__WEBPACK_IMPORTED_MODULE_4__["get"])();
          this.mouseMove(inputState);
          binder.updateState(inputState, state);

          for (var m of binder.poolEvents(inputState)) {
            bus.handle(m);
          }

          Object(_utils_input__WEBPACK_IMPORTED_MODULE_4__["postFrame"])();
        }

      }());
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
}

/***/ }),

/***/ "./src/app/modules/photonui.ts":
/*!*************************************!*\
  !*** ./src/app/modules/photonui.ts ***!
  \*************************************/
/*! exports provided: PhotonUiModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PhotonUiModule", function() { return PhotonUiModule; });
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tippy.js */ "./node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ui/ui */ "./src/utils/ui/ui.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../apis/ui */ "./src/app/apis/ui.ts");




class PhotonWindow {
  constructor(id, title, w, h, draggable, centered, closeable) {
    if (draggable === void 0) {
      draggable = false;
    }

    if (centered === void 0) {
      centered = true;
    }

    if (closeable === void 0) {
      closeable = true;
    }

    this.onclose = void 0;
    this.contentElement = void 0;
    this.winElement = void 0;
    this.currentButtonGroup = void 0;
    this.toolbar = void 0;
    var titleElem = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('h1').className('title').text(title);
    var toolbar = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('toolbar-actions hidden');
    var header = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('header').className('toolbar toolbar-header').append(titleElem).append(toolbar);

    if (closeable) {
      var close = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["span"])().className('icon icon-record pull-right padded-horizontally red').click(() => this.close());
      titleElem.append(close);
    }

    var footer = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('footer').className('toolbar toolbar-footer');
    var content = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('window-content').size(w + 'px', h + 'px');
    var window = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('window-frame').id(id).append(header).append(content).append(footer);
    this.toolbar = toolbar;
    this.contentElement = content.elem();
    this.winElement = window.elem();
    if (centered) this.winElement.classList.add('fixed-center');
    if (draggable) Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["dragElement"])(titleElem.elem(), this.winElement);
    document.body.appendChild(this.winElement);
  }

  addToolbarWidget(widget) {
    var container = this.currentButtonGroup == null ? this.toolbar : this.currentButtonGroup;
    container.appendHtml(widget);
    this.toolbar.elem().classList.remove('hidden');
  }

  addToolMenuButton(icon, menu) {
    var container = this.currentButtonGroup == null ? this.toolbar : this.currentButtonGroup;
    var btn = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('button').className('btn btn-default btn-dropdown').append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["span"])().className('icon ' + icon));
    container.append(btn);
    menu.build(btn.elem());
    this.toolbar.elem().classList.remove('hidden');
  }

  addToolIconButton(icon, click) {
    var container = this.currentButtonGroup == null ? this.toolbar : this.currentButtonGroup;
    container.append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('button').className('btn btn-default').append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["span"])().className('icon ' + icon)).click(click));
    this.toolbar.elem().classList.remove('hidden');
  }

  addToolSearch(hint, change) {
    var suggestContainer = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('suggest');
    var container = this.currentButtonGroup == null ? this.toolbar : this.currentButtonGroup;
    var textBox = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('input').className('toolbar-control').attr('type', 'text').attr('placeholder', hint).change(s => change(s, suggestContainer.elem()));
    container.append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["tag"])('button').className('btn btn-default btn-mini pull-right').append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["span"])().className('icon icon-search')).append(textBox).click(() => {
      textBox.elem().value = '';
      change('', suggestContainer.elem());
    }));
    Object(tippy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(textBox.elem(), {
      allowHTML: true,
      placement: 'bottom-start',
      interactive: true,
      content: suggestContainer.elem(),
      trigger: 'focus',
      arrow: false,
      offset: [0, 0]
    });
    this.toolbar.elem().classList.remove('hidden');
  }

  startButtonGroup() {
    this.currentButtonGroup = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('btn-group');
    this.toolbar.append(this.currentButtonGroup);
  }

  endButtonGroup() {
    this.currentButtonGroup = null;
  }

  close() {
    this.hide();
    if (this.onclose) this.onclose();
  }

  show() {
    this.winElement.classList.remove('hidden');
  }

  hide() {
    this.winElement.classList.add('hidden');
  }

  setPosition(x, y) {
    var actualX = typeof x == 'number' ? x + 'px' : x;
    var actualY = typeof y == 'number' ? y + 'px' : y;
    this.winElement.style.left = actualX;
    this.winElement.style.top = actualY;
  }

}

class PhotonWindowBuilder {
  constructor() {
    this._id = void 0;
    this._title = void 0;
    this._draggable = false;
    this._centered = true;
    this._closeable = true;
    this._onclose = void 0;
    this._w = 250;
    this._h = 250;
    this._toolbar = void 0;
    this._content = void 0;
  }

  id(id) {
    this._id = id;
    return this;
  }

  title(title) {
    this._title = title;
    return this;
  }

  draggable(draggable) {
    this._draggable = draggable;
    return this;
  }

  centered(centered) {
    this._centered = centered;
    return this;
  }

  closeable(closeable) {
    this._closeable = closeable;
    return this;
  }

  onclose(h) {
    this._onclose = h;
    return this;
  }

  size(w, h) {
    this._w = w;
    this._h = h;
    return this;
  }

  toolbar(toolbar) {
    this._toolbar = toolbar;
    return this;
  }

  content(content) {
    this._content = content;
    return this;
  }

  build() {
    var win = new PhotonWindow(this._id, this._title, this._w, this._h, this._draggable, this._centered, this._closeable);
    win.onclose = this._onclose;
    if (this._toolbar) this._toolbar.build(win);
    if (this._content) win.contentElement.appendChild(this._content);
    return win;
  }

}

class ToolbarGroupBuilder {
  constructor() {
    this.items = [];
  }

  add(item) {
    this.items.push(item);
  }

  build(window) {
    window.startButtonGroup();

    for (var i of this.items) {
      i.build(window);
    }

    window.endButtonGroup();
  }

}

class PhotonToolbarBuilder {
  constructor() {
    this.groups = [];
    this.currentGroup = null;
  }

  startGroup() {
    if (this.currentGroup != null) this.groups.push(this.currentGroup);
    this.currentGroup = new ToolbarGroupBuilder();
    return this;
  }

  endGroup() {
    this.groups.push(this.currentGroup);
    this.currentGroup = null;
    return this;
  }

  addItem(item) {
    if (this.currentGroup == null) this.groups.push(item);else this.currentGroup.add(item);
  }

  button(icon, click) {
    var item = {
      build(window) {
        window.addToolIconButton(icon, click);
      }

    };
    this.addItem(item);
    return this;
  }

  menuButton(icon, menu) {
    var item = {
      build(window) {
        window.addToolMenuButton(icon, menu);
      }

    };
    this.addItem(item);
    return this;
  }

  search(hint, change) {
    var item = {
      build(window) {
        window.addToolSearch(hint, change);
      }

    };
    this.addItem(item);
    return this;
  }

  widget(widget) {
    var item = {
      build(window) {
        window.addToolbarWidget(widget);
      }

    };
    this.addItem(item);
    return this;
  }

  build(window) {
    for (var group of this.groups) {
      group.build(window);
    }
  }

}

class PhotonMenuBuilder {
  constructor() {
    this.items = [];
  }

  item(text, click) {
    this.items.push([text, click]);
    return this;
  }

  build(elem) {
    var menu = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('menu menu-default');
    var instance = null;

    var _loop = function _loop(label, click) {
      menu.append(Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["div"])('menu-item').text(label).click(() => {
        click(), instance.hide();
      }));
    };

    for (var [label, click] of this.items) {
      _loop(label, click);
    }

    instance = Object(tippy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(elem, {
      content: menu.elem(),
      allowHTML: true,
      placement: 'bottom-start',
      trigger: 'click',
      interactive: true,
      arrow: false,
      offset: [0, 0],
      duration: 100,
      appendTo: document.body
    });
  }

}

class Builder {
  window() {
    return new PhotonWindowBuilder();
  }

  toolbar() {
    return new PhotonToolbarBuilder();
  }

  menu() {
    return new PhotonMenuBuilder();
  }

}

function PhotonUiModule(module) {
  document.body.oncontextmenu = () => false;

  module.bindInstance(_apis_ui__WEBPACK_IMPORTED_MODULE_2__["UI"], {
    builder: new Builder()
  });
}

/***/ }),

/***/ "./src/app/modules/selectmap.ts":
/*!**************************************!*\
  !*** ./src/app/modules/selectmap.ts ***!
  \**************************************/
/*! exports provided: MAP_NAMES, showMapSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAP_NAMES", function() { return MAP_NAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showMapSelection", function() { return showMapSelection; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ui/ui */ "./src/utils/ui/ui.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../apis/ui */ "./src/app/apis/ui.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var MAP_NAMES = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('MapNames');
var selectMapWindow;

function getWindow(_x) {
  return _getWindow.apply(this, arguments);
}

function _getWindow() {
  _getWindow = _asyncToGenerator(function* (injector) {
    var ui = yield injector.getInstance(_apis_ui__WEBPACK_IMPORTED_MODULE_2__["UI"]);

    if (selectMapWindow == null) {
      selectMapWindow = ui.builder.window().id('map_select').title('Select Map').closeable(true).size(350, 600).build();
    }

    return selectMapWindow;
  });
  return _getWindow.apply(this, arguments);
}

function showMapSelection(injector) {
  return new Promise( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (resolve) {
      var mapNamesProvider = yield injector.getInstance(MAP_NAMES);
      var mapNames = yield mapNamesProvider();
      var win = yield getWindow(injector);

      win.onclose = () => resolve(null);

      var table = new _utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["Table"]();
      table.className("table-striped");
      mapNames.forEach(map => table.row([Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_1__["span"])().text(map)]).click(() => {
        win.hide();
        resolve(map);
      }));
      var lastTable = win.contentElement.firstChild;
      if (lastTable) win.contentElement.removeChild(lastTable);
      win.contentElement.appendChild(table.elem());
      win.show();
    });

    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }());
}

/***/ }),

/***/ "./src/app/modules/statusbar.ts":
/*!**************************************!*\
  !*** ./src/app/modules/statusbar.ts ***!
  \**************************************/
/*! exports provided: StatusBarModule, Statusbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusBarModule", function() { return StatusBarModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Statusbar", function() { return Statusbar; });
/* harmony import */ var stage0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stage0 */ "./node_modules/stage0/index.js");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
function _templateObject3() {
  var data = _taggedTemplateLiteralLoose(["<span class=\"pull-right\" #statusbar></span>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["<span class=\"title padded-horizontally-less\">#nameNode<span style=\"display: inline-block;\">#valueNode</span></span>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  <span class=\"title padded-horizontally-less\">Position:\n    <span style=\"width: 45px; display: inline-block; text-align: right;\">#posx</span>,\n    <span style=\"width: 45px; display: inline-block; text-align: left;\">#posy</span>\n  </span>\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }






function StatusBarModule(_x) {
  return _StatusBarModule.apply(this, arguments);
}

function _StatusBarModule() {
  _StatusBarModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_4__["BUS"]);
        bus.connect(yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_1__["create"])(injector, Statusbar, _apis_app__WEBPACK_IMPORTED_MODULE_3__["VIEW"]));
      });

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _StatusBarModule.apply(this, arguments);
}

var positionBoxTemplate = Object(stage0__WEBPACK_IMPORTED_MODULE_0__["default"])(_templateObject());

function PositionBox() {
  var root = positionBoxTemplate;
  var {
    posx,
    posy
  } = positionBoxTemplate.collect(root);
  var cachedPosX = 0;
  var cachedPosY = 0;

  var update = (x, y) => {
    if (x != cachedPosX) {
      cachedPosX = x;
      posx.nodeValue = "[" + x;
    }

    if (y != cachedPosY) {
      cachedPosY = y;
      posy.nodeValue = y + "]";
    }
  };

  return [root, update];
}

var valueBoxTemplate = Object(stage0__WEBPACK_IMPORTED_MODULE_0__["default"])(_templateObject2());

function ValueBox(name, size) {
  var root = valueBoxTemplate.cloneNode(true);
  var {
    nameNode,
    valueNode
  } = valueBoxTemplate.collect(root);
  nameNode.nodeValue = name + ": ";
  valueNode.parentElement.style.width = size + "px";
  var cachedValue = null;

  var update = value => {
    if (value != cachedValue) {
      valueNode.nodeValue = value;
      cachedValue = value;
    }
  };

  return [root, update];
}

var statusBarTemplate = Object(stage0__WEBPACK_IMPORTED_MODULE_0__["default"])(_templateObject3());

function StatusBar() {
  var root = statusBarTemplate;
  var {
    statusbar
  } = statusBarTemplate.collect(root);
  var [posBox, posUpdate] = PositionBox();
  var [sectorBox, sectorUpdate] = ValueBox('Sector', 25);
  var [drawsBox, drawsUpdate] = ValueBox('Draws', 85);
  var [fpsBox, fpsUpdate] = ValueBox('FPS', 35);
  statusbar.appendChild(posBox);
  statusbar.appendChild(sectorBox);
  statusbar.appendChild(drawsBox);
  statusbar.appendChild(fpsBox);
  return {
    root,
    updaters: {
      posUpdate,
      sectorUpdate,
      drawsUpdate,
      fpsUpdate
    }
  };
}

class Statusbar extends _apis_handler__WEBPACK_IMPORTED_MODULE_4__["MessageHandlerReflective"] {
  constructor(view) {
    super();
    this.updaters = void 0;
    this.view = view;
    var {
      root,
      updaters
    } = StatusBar();
    document.getElementById('footer').appendChild(root);
    this.updaters = updaters;
  }

  PostFrame(msg) {
    var _profile$counts$draws, _profile$counts$draws2;

    var view = this.view;
    var profile = _utils_profiler__WEBPACK_IMPORTED_MODULE_2__["get"](null);
    var draws = (_profile$counts$draws = profile.counts['drawsRequested']) != null ? _profile$counts$draws : 0;
    var skips = (_profile$counts$draws2 = profile.counts['drawsMerged']) != null ? _profile$counts$draws2 : 0;
    this.updaters.posUpdate(view.x, view.y);
    this.updaters.sectorUpdate(view.sec);
    this.updaters.fpsUpdate((1000 / profile.time).toFixed(0));
    this.updaters.drawsUpdate(draws + ' / ' + (draws - skips));
  }

}

/***/ }),

/***/ "./src/app/modules/taskmanager.ts":
/*!****************************************!*\
  !*** ./src/app/modules/taskmanager.ts ***!
  \****************************************/
/*! exports provided: showTasks, TaskManagerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showTasks", function() { return showTasks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TaskManagerModule", function() { return TaskManagerModule; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_ui_renderers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/ui/renderers */ "./src/utils/ui/renderers.ts");
/* harmony import */ var _utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ui/ui */ "./src/utils/ui/ui.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _apis_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../apis/ui */ "./src/app/apis/ui.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../edit/messages */ "./src/app/edit/messages.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }










class TaskWidget {
  constructor(handle) {
    this.updateHandler = void 0;
    this.handle = handle;
  }

  setUpdateHandler(handler) {
    this.updateHandler = handler;
  }

  update() {
    if (this.updateHandler != null) this.updateHandler(this.handle.getDescription(), this.handle.getProgress());
  }

}

function TaskWidgetRenderer(w) {
  var progress = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["tag"])('progress').css('width', '90%').css('height', '30px').attr('max', "100");
  var cancel = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["span"])().className('icon icon-cancel-circled').css('font-size', '20px').css('color', '#666').css('float', 'right').click(() => w.handle.stop());
  var descr = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["div"])('description').css('padding-left', '10px');
  var container = Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["div"])('task-container').css('width', 'auto').append(progress).append(descr);
  w.setUpdateHandler((s, p) => {
    progress.attr('value', p);
    descr.text(s);
  });
  return Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["div"])('task').append(cancel).append(container);
}

class TaskManager {
  constructor(ui, scheduler) {
    this.tasks = [];
    this.taskWidgets = [];
    this.window = void 0;
    this.active = false;
    this.gridModel = this.createGridModel();
    this.window = ui.builder.window().title('Tasks').draggable(true).closeable(true).centered(true).size(600, 600).build();

    this.window.onclose = () => this.active = false;

    scheduler.addHandler(this);

    for (var _task of scheduler.currentTasks()) {
      this.onTaskAdd(_task);
    }
  }

  onTaskAdd(task) {
    this.tasks.push(task);
    this.taskWidgets.push(new TaskWidget(task));
    this.refreshGrid();
  }

  onTaskStop(task) {
    var idx = this.tasks.indexOf(task);

    if (idx != -1) {
      this.tasks.splice(idx, 1);
      this.taskWidgets.splice(idx, 1);
      this.refreshGrid();
    }
  }

  onTaskUpdate(task) {
    if (!this.active) return;
    var idx = this.tasks.indexOf(task);
    if (idx != -1) this.taskWidgets[idx].update();
  }

  createGridModel() {
    var columns = [TaskWidgetRenderer];
    var self = this;
    return {
      rows() {
        return _asyncToGenerator(function* () {
          return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(self.taskWidgets).map(f => [f]);
        })();
      },

      columns() {
        return columns;
      },

      onClick(row, rowElement) {}

    };
  }

  refreshGrid() {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (!_this.active) return;
      Object(_utils_ui_ui__WEBPACK_IMPORTED_MODULE_3__["replaceContent"])(_this.window.contentElement, (yield Object(_utils_ui_renderers__WEBPACK_IMPORTED_MODULE_2__["renderGrid"])(_this.gridModel)).elem());
    })();
  }

  show() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.active = true;
      yield _this2.refreshGrid();

      _this2.window.show();
    })();
  }

}

var manager;

function getTaskManager(_x) {
  return _getTaskManager.apply(this, arguments);
}

function _getTaskManager() {
  _getTaskManager = _asyncToGenerator(function* (injector) {
    if (manager == null) manager = yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_0__["create"])(injector, TaskManager, _apis_ui__WEBPACK_IMPORTED_MODULE_6__["UI"], _apis_app__WEBPACK_IMPORTED_MODULE_4__["SCHEDULER"]);
    return manager;
  });
  return _getTaskManager.apply(this, arguments);
}

function showTasks(_x2) {
  return _showTasks.apply(this, arguments);
}

function _showTasks() {
  _showTasks = _asyncToGenerator(function* (injector) {
    var browser = yield getTaskManager(injector);
    browser.show();
  });
  return _showTasks.apply(this, arguments);
}

function* task() {
  var handler = yield;

  for (var i = 0; i < 100; i++) {
    handler.setDescription("Task " + i + "%");
    handler.setProgress(i);
    yield;
  }
}

function TaskManagerModule(_x3) {
  return _TaskManagerModule.apply(this, arguments);
}

function _TaskManagerModule() {
  _TaskManagerModule = _asyncToGenerator(function* (module) {
    module.execute( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (injector) {
        var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_5__["BUS"]);
        var scheduler = yield injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_4__["SCHEDULER"]);
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_7__["namedMessageHandler"])('show_tasks', () => showTasks(injector)));
        bus.connect(Object(_edit_messages__WEBPACK_IMPORTED_MODULE_7__["namedMessageHandler"])('add_test_task', () => scheduler.addTask(task())));
      });

      return function (_x4) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  return _TaskManagerModule.apply(this, arguments);
}

/***/ }),

/***/ "./src/app/modules/view/boardrenderer2d.ts":
/*!*************************************************!*\
  !*** ./src/app/modules/view/boardrenderer2d.ts ***!
  \*************************************************/
/*! exports provided: Renderer2D, BoardRenderer2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer2D", function() { return Renderer2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoardRenderer2D", function() { return BoardRenderer2D; });
/* harmony import */ var _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/boardvisitor */ "./src/build/boardvisitor.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _geometry_builders_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geometry/builders/common */ "./src/app/modules/geometry/builders/common.ts");
/* harmony import */ var _geometry_cache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geometry/cache */ "./src/app/modules/geometry/cache.ts");
/* harmony import */ var _geometry_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geometry/common */ "./src/app/modules/geometry/common.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }











var visible = new _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["AllBoardVisitorResult"]();
function Renderer2D(_x) {
  return _Renderer2D.apply(this, arguments);
}

function _Renderer2D() {
  _Renderer2D = _asyncToGenerator(function* (injector) {
    var [bgl, builders, renderables, board] = yield Promise.all([injector.getInstance(_gl_buildgl__WEBPACK_IMPORTED_MODULE_9__["BUILD_GL"]), injector.getInstance(_geometry_common__WEBPACK_IMPORTED_MODULE_8__["BUILDERS_FACTORY"]), injector.getInstance(_geometry_cache__WEBPACK_IMPORTED_MODULE_7__["RENDRABLES_CACHE"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_4__["BOARD"])]);
    return new BoardRenderer2D(bgl, builders, renderables.topdown, board);
  });
  return _Renderer2D.apply(this, arguments);
}

class BoardRenderer2D {
  constructor(bgl, builders, renderables, board) {
    this.grid = void 0;
    this.upp = 1;
    this.surfaces = new _utils_collections__WEBPACK_IMPORTED_MODULE_2__["Deck"]();
    this.pass = new _apis_renderable__WEBPACK_IMPORTED_MODULE_5__["SortingRenderable"](this.surfaces, kind => {
      var spriteLabel = kind & _apis_renderable__WEBPACK_IMPORTED_MODULE_5__["SPRITE_LABEL"] && this.upp > 20;
      var gridHelper = kind & _apis_renderable__WEBPACK_IMPORTED_MODULE_5__["HELPER_GRID"];
      return !spriteLabel && !gridHelper;
    });

    this.sectorVisitor_ = (board, sectorId) => this.sectorVisitor(board, sectorId);

    this.wallVisitor_ = (board, wallId, sectorId) => this.wallVisitor(board, wallId, sectorId);

    this.spriteVisitor_ = (board, spriteId) => this.spriteVisitor(board, spriteId);

    this.bgl = bgl;
    this.builders = builders;
    this.renderables = renderables;
    this.board = board;
  }

  getGrid() {
    if (this.grid != null) return this.grid;
    var gridSolid = this.builders.solid('utils');
    gridSolid.trans = 0.2;
    var buff = gridSolid.buff;
    var size = 1024 * 1024;
    buff.allocate(4, 6);
    buff.writePos(0, -size, 0, size);
    buff.writePos(1, size, 0, size);
    buff.writePos(2, size, 0, -size);
    buff.writePos(3, -size, 0, -size);
    buff.writeTcLighting(0, -1, 1);
    buff.writeTcLighting(1, 1, 1);
    buff.writeTcLighting(2, 1, -1);
    buff.writeTcLighting(3, -1, 1);
    buff.writeQuad(0, 3, 2, 1, 0);
    this.grid = this.builders.grid('');
    this.grid.range = size;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].copy(this.grid.gridTexMat, _geometry_builders_common__WEBPACK_IMPORTED_MODULE_6__["GRID_SECTOR_MATRIX"]);
    this.grid.solid = gridSolid;
    return this.grid;
  }

  drawTools(p) {
    this.bgl.gl.disable(WebGLRenderingContext.DEPTH_TEST);
    this.bgl.gl.enable(WebGLRenderingContext.BLEND);
    this.surfaces.clear().pushAll(p);
    this.bgl.modulation(0.984, 0.78, 0.118, 1);
    this.bgl.draw(this.pass);
    this.bgl.flush();
    this.bgl.gl.disable(WebGLRenderingContext.BLEND);
    this.bgl.gl.enable(WebGLRenderingContext.DEPTH_TEST);
  }

  draw(view, campos, dist, controller) {
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["startProfile"]('processing');
    this.upp = controller.getUnitsPerPixel();
    var result = visible.visit(this.board());
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["endProfile"]();
    this.bgl.setProjectionMatrix(view.getProjectionMatrix());
    this.bgl.setViewMatrix(view.getTransformMatrix());
    this.bgl.setPosition(view.getPosition());
    this.bgl.gl.disable(WebGLRenderingContext.DEPTH_TEST);
    this.bgl.gl.enable(WebGLRenderingContext.BLEND);
    this.bgl.draw(this.getGrid());
    this.bgl.flush();
    this.bgl.gl.disable(WebGLRenderingContext.BLEND);
    this.drawRooms(result);
    this.bgl.gl.enable(WebGLRenderingContext.DEPTH_TEST);
  }

  clearDrawLists() {
    this.surfaces.clear();
  }

  sectorVisitor(board, sectorId) {
    this.surfaces.push(this.renderables.sector(sectorId));
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["incCount"]('sectors');
  }

  wallVisitor(board, wallId, sectorId) {
    this.surfaces.push(this.renderables.wall(wallId));
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["incCount"]('walls');
  }

  spriteVisitor(board, spriteId) {
    this.surfaces.push(this.renderables.sprite(spriteId));
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["incCount"]('sprites');
  }

  drawRooms(result) {
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["startProfile"]('processing');
    this.clearDrawLists();
    var board = this.board();
    result.forSector(board, this.sectorVisitor_);
    result.forWall(board, this.wallVisitor_);
    result.forSprite(board, this.spriteVisitor_);
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["endProfile"]();
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["startProfile"]('draw');
    this.bgl.draw(this.pass);
    this.bgl.flush();
    _utils_profiler__WEBPACK_IMPORTED_MODULE_3__["endProfile"]();
  }

}

/***/ }),

/***/ "./src/app/modules/view/boardrenderer3d.ts":
/*!*************************************************!*\
  !*** ./src/app/modules/view/boardrenderer3d.ts ***!
  \*************************************************/
/*! exports provided: RorLink, RorLinks, Implementation_, Renderer3D, Boardrenderer3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RorLink", function() { return RorLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RorLinks", function() { return RorLinks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Implementation_", function() { return Implementation_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer3D", function() { return Renderer3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Boardrenderer3D", function() { return Boardrenderer3D; });
/* harmony import */ var _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/boardvisitor */ "./src/build/boardvisitor.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _utils_vecmath__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/vecmath */ "./src/utils/vecmath.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_renderable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../apis/renderable */ "./src/app/apis/renderable.ts");
/* harmony import */ var _geometry_cache__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geometry/cache */ "./src/app/modules/geometry/cache.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }













class RorLink {
  constructor(srcSpriteId, dstSpriteId) {
    this.srcSpriteId = srcSpriteId;
    this.dstSpriteId = dstSpriteId;
  }

}
class RorLinks {
  constructor() {
    this.ceilLinks = {};
    this.floorLinks = {};
  }

  hasRor(sectorId) {
    return this.ceilLinks[sectorId] != undefined || this.floorLinks[sectorId] != undefined;
  }

}
var Implementation_ = new _utils_injector__WEBPACK_IMPORTED_MODULE_4__["Dependency"]('Implementation');
var visible = new _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["PvsBoardVisitorResult"]();
var all = new _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["AllBoardVisitorResult"]();
var rorViss = new Map();
var diff = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var stackTransform = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
var srcPos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var dstPos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var npos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var mstmp = {
  sec: 0,
  x: 0,
  y: 0,
  z: 0
};
var mirrorVis = new _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["PvsBoardVisitorResult"]();
var wallNormal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec2"].create();
var mirrorNormal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
var mirroredTransform = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
var mpos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();

var polyOffsetOn = bgl => {
  bgl.gl.polygonOffset(0, -8);
};

var polyOffsetOff = bgl => {
  bgl.gl.polygonOffset(0, 0);
};

var blendOn = bgl => {
  bgl.gl.enable(WebGLRenderingContext.BLEND);
};

var blendOff = bgl => {
  bgl.gl.disable(WebGLRenderingContext.BLEND);
};

function list() {
  var list = new _utils_collections__WEBPACK_IMPORTED_MODULE_3__["Deck"]();
  var renderable = new _apis_renderable__WEBPACK_IMPORTED_MODULE_9__["SortingRenderable"](list);
  return {
    add: r => {
      list.push(r);
    },
    clear: () => list.clear(),
    drawCall: consumer => {
      renderable.drawCall(consumer);
    }
  };
}

function Renderer3D(_x) {
  return _Renderer3D.apply(this, arguments);
}

function _Renderer3D() {
  _Renderer3D = _asyncToGenerator(function* (injector) {
    var [impl, bgl, board, renderables] = yield Promise.all([injector.getInstance(Implementation_), injector.getInstance(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["BUILD_GL"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_8__["BOARD"]), injector.getInstance(_geometry_cache__WEBPACK_IMPORTED_MODULE_10__["RENDRABLES_CACHE"])]);
    return new Boardrenderer3D(impl, bgl, board, renderables.geometry);
  });
  return _Renderer3D.apply(this, arguments);
}

class Boardrenderer3D {
  constructor(impl, bgl, board, renderables) {
    this.rorSectorCollector = Object(_build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["createSectorCollector"])((board, sectorId) => this.impl.rorLinks().hasRor(sectorId));
    this.mirrorWallsCollector = Object(_build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["createWallCollector"])((board, wallId, sectorId) => this.impl.isMirrorPic(board.walls[wallId].picnum));
    this.surfaces = list();
    this.surfacesTrans = list();
    this.sprites = list();
    this.spritesTrans = list();

    this._sectorVisitor = (board, sectorId) => this.sectorVisitor(board, sectorId);

    this._wallVisitor = (board, wallId, sectorId) => this.wallVisitor(board, wallId, sectorId);

    this._spriteVisitor = (board, spriteId) => this.spriteVisitor(board, spriteId);

    this.impl = impl;
    this.bgl = bgl;
    this.board = board;
    this.renderables = renderables;
  }

  drawTools(p) {
    this.bgl.gl.disable(WebGLRenderingContext.DEPTH_TEST);
    this.bgl.gl.enable(WebGLRenderingContext.BLEND);
    this.surfaces.clear().pushAll(p);
    this.bgl.modulation(0.984, 0.78, 0.118, 1);
    this.bgl.draw(this.surfaces);
    this.bgl.flush();
    this.bgl.gl.disable(WebGLRenderingContext.BLEND);
    this.bgl.gl.enable(WebGLRenderingContext.DEPTH_TEST);
  }

  draw(view) {
    this.drawGeometry(view);
  }

  writeStencilOnly(value) {
    this.bgl.gl.stencilFunc(WebGLRenderingContext.ALWAYS, value, 0xff);
    this.bgl.gl.stencilOp(WebGLRenderingContext.KEEP, WebGLRenderingContext.KEEP, WebGLRenderingContext.REPLACE);
    this.bgl.gl.stencilMask(0xff);
    this.bgl.gl.depthMask(false);
    this.bgl.gl.colorMask(false, false, false, false);
  }

  writeStenciledOnly(value) {
    this.bgl.gl.stencilFunc(WebGLRenderingContext.EQUAL, value, 0xff);
    this.bgl.gl.stencilMask(0x0);
    this.bgl.gl.depthMask(true);
    this.bgl.gl.colorMask(true, true, true, true);
  }

  writeDepthOnly() {
    this.bgl.gl.colorMask(false, false, false, false);
  }

  writeAll() {
    this.bgl.gl.depthMask(true);
    this.bgl.gl.colorMask(true, true, true, true);
  }

  drawGeometry(view) {
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["startProfile"]('processing');
    var board = this.board();
    var result = view.sec == -1 ? all.visit(board) : visible.visit(board, view, view.getForward());
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["endProfile"]();
    this.bgl.setProjectionMatrix(view.getProjectionMatrix());
    this.drawMirrors(result, view);
    this.drawRor(result, view);
    this.bgl.setViewMatrix(view.getTransformMatrix());
    this.bgl.setPosition(view.getPosition());
    this.drawRooms(result);
  }

  getLinkVis(link) {
    var vis = rorViss.get(link);

    if (vis == undefined) {
      vis = new _build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["PvsBoardVisitorResult"]();
      rorViss.set(link, vis);
    }

    return vis;
  }

  drawStack(view, link, surface, stencilValue) {
    if (!link) return;
    this.bgl.setViewMatrix(view.getTransformMatrix());
    this.bgl.setPosition(view.getPosition());
    this.writeStencilOnly(stencilValue);
    this.bgl.draw(surface);
    this.bgl.flush();
    var board = this.board();
    var src = board.sprites[link.srcSpriteId];
    var dst = board.sprites[link.dstSpriteId];
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].set(srcPos, src.x, src.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], src.y);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].set(dstPos, dst.x, dst.z / _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"], dst.y);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].sub(diff, srcPos, dstPos);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].copy(stackTransform, view.getTransformMatrix());
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].translate(stackTransform, stackTransform, diff);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].sub(npos, view.getPosition(), diff);
    mstmp.sec = dst.sectnum;
    mstmp.x = npos[0];
    mstmp.y = npos[2];
    mstmp.z = npos[1] * _build_utils__WEBPACK_IMPORTED_MODULE_1__["ZSCALE"];
    this.bgl.setViewMatrix(stackTransform);
    this.bgl.setPosition(npos);
    this.writeStenciledOnly(stencilValue);
    this.drawRooms(this.getLinkVis(link).visit(this.board(), mstmp, view.getForward()));
    this.bgl.setViewMatrix(view.getTransformMatrix());
    this.bgl.setPosition(view.getPosition());
    this.writeDepthOnly();
    this.bgl.draw(surface);
    this.bgl.flush();
  }

  drawRor(result, view) {
    result.forSector(this.board(), this.rorSectorCollector.visit());
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["get"](null).inc('rors', this.rorSectorCollector.sectors.length());
    this.bgl.gl.enable(WebGLRenderingContext.STENCIL_TEST);

    for (var i = 0; i < this.rorSectorCollector.sectors.length(); i++) {
      var s = this.rorSectorCollector.sectors.get(i);
      var r = this.renderables.sector(s);
      this.drawStack(view, this.impl.rorLinks().ceilLinks[s], r.ceiling, i + 1);
      this.drawStack(view, this.impl.rorLinks().floorLinks[s], r.floor, i + 1);
    }

    this.bgl.gl.disable(WebGLRenderingContext.STENCIL_TEST);
    this.writeAll();
  }

  drawMirrors(result, view) {
    var board = this.board();
    result.forWall(board, this.mirrorWallsCollector.visit());
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["get"](null).inc('mirrors', this.mirrorWallsCollector.walls.length());
    this.bgl.gl.enable(WebGLRenderingContext.STENCIL_TEST);

    for (var i = 0; i < this.mirrorWallsCollector.walls.length(); i++) {
      var w = Object(_build_boardvisitor__WEBPACK_IMPORTED_MODULE_0__["unpackWallId"])(this.mirrorWallsCollector.walls.get(i));
      if (!Object(_build_utils__WEBPACK_IMPORTED_MODULE_1__["wallVisible"])(board, w, view)) continue; // draw mirror surface into stencil

      var r = this.renderables.wall(w);
      this.bgl.setViewMatrix(view.getTransformMatrix());
      this.bgl.setPosition(view.getPosition());
      this.writeStencilOnly(i + 127);
      this.bgl.draw(r);
      this.bgl.flush(); // draw reflections in stenciled area

      var w1 = board.walls[w];
      var w2 = board.walls[w1.point2];
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec2"].set(wallNormal, w2.x - w1.x, w2.y - w1.y);
      Object(_utils_vecmath__WEBPACK_IMPORTED_MODULE_7__["normal2d"])(wallNormal, wallNormal);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].set(mirrorNormal, wallNormal[0], 0, wallNormal[1]);
      var mirrorrD = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["dot2d"])(wallNormal[0], wallNormal[1], w1.x, w1.y);
      Object(_utils_vecmath__WEBPACK_IMPORTED_MODULE_7__["mirrorBasis"])(mirroredTransform, view.getTransformMatrix(), view.getPosition(), mirrorNormal, mirrorrD);
      this.bgl.setViewMatrix(mirroredTransform);
      this.bgl.setClipPlane(mirrorNormal[0], mirrorNormal[1], mirrorNormal[2], mirrorrD);
      this.bgl.gl.cullFace(WebGLRenderingContext.FRONT);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].copy(mpos, view.getPosition());
      Object(_utils_vecmath__WEBPACK_IMPORTED_MODULE_7__["reflectPoint3d"])(mpos, mirrorNormal, mirrorrD, mpos);
      mstmp.sec = view.sec;
      mstmp.x = mpos[0];
      mstmp.y = mpos[2];
      mstmp.z = mpos[1];
      this.writeStenciledOnly(i + 127);
      this.drawRooms(mirrorVis.visit(board, mstmp, view.getForward()));
      this.bgl.gl.cullFace(WebGLRenderingContext.BACK); // seal reflections by writing depth of mirror surface

      this.bgl.setViewMatrix(view.getTransformMatrix());
      this.writeDepthOnly();
      this.bgl.setClipPlane(0, 0, 0, 0);
      this.bgl.draw(r);
      this.bgl.flush();
    }

    this.bgl.gl.disable(WebGLRenderingContext.STENCIL_TEST);
    this.writeAll();
  }

  clearDrawLists() {
    this.surfaces.clear();
    this.surfacesTrans.clear();
    this.sprites.clear();
    this.spritesTrans.clear();
  }

  sectorVisitor(board, sectorId) {
    var sector = this.renderables.sector(sectorId);
    if (this.impl.rorLinks().floorLinks[sectorId] == undefined) this.surfaces.add(sector.floor);
    if (this.impl.rorLinks().ceilLinks[sectorId] == undefined) this.surfaces.add(sector.ceiling);
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["incCount"]('sectors');
  }

  wallVisitor(board, wallId, sectorId) {
    if (this.impl.isMirrorPic(board.walls[wallId].picnum)) return;
    var wall = board.walls[wallId];
    var wallr = this.renderables.wall(wallId);

    if (wall.cstat.translucent == 1 || wall.cstat.translucentReversed == 1) {
      this.surfacesTrans.add(wallr.mid);
      this.surfaces.add(wallr.bot);
      this.surfaces.add(wallr.top);
    } else if (wall.nextwall == -1) {
      this.surfaces.add(wallr.mid);
    } else {
      this.surfaces.add(wallr);
    }

    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["incCount"]('walls');
  }

  spriteVisitor(board, spriteId) {
    var spriter = this.renderables.sprite(spriteId);
    var sprite = board.sprites[spriteId];
    var trans = sprite.cstat.translucent == 1 || sprite.cstat.tranclucentReversed == 1;
    (trans ? this.spritesTrans : this.sprites).add(spriter);
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["incCount"]('sprites');
  }

  drawRooms(result) {
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["startProfile"]('processing');
    this.clearDrawLists();
    var board = this.board();
    result.forSector(board, this._sectorVisitor);
    result.forWall(board, this._wallVisitor);
    result.forSprite(board, this._spriteVisitor);
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["endProfile"]();
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["startProfile"]('draw');
    this.drawImpl();
    _utils_profiler__WEBPACK_IMPORTED_MODULE_6__["endProfile"]();
  }

  drawImpl() {
    this.bgl.draw(this.surfaces);
    this.bgl.flush();
    polyOffsetOn(this.bgl);
    this.bgl.draw(this.sprites);
    this.bgl.flush();
    polyOffsetOff(this.bgl);
    blendOn(this.bgl);
    this.bgl.draw(this.surfacesTrans);
    this.bgl.flush();
    polyOffsetOn(this.bgl);
    this.bgl.draw(this.spritesTrans);
    this.bgl.flush();
    polyOffsetOff(this.bgl);
    blendOff(this.bgl);
  }

}

/***/ }),

/***/ "./src/app/modules/view/view.ts":
/*!**************************************!*\
  !*** ./src/app/modules/view/view.ts ***!
  \**************************************/
/*! exports provided: TargetImpl, SwappableViewModule, SwappableViewConstructor, SwappableView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TargetImpl", function() { return TargetImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwappableViewModule", function() { return SwappableViewModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwappableViewConstructor", function() { return SwappableViewConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwappableView", function() { return SwappableView; });
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _edit_messages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../edit/messages */ "./src/app/edit/messages.ts");
/* harmony import */ var _view2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view2d */ "./src/app/modules/view/view2d.ts");
/* harmony import */ var _view3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./view3d */ "./src/app/modules/view/view3d.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }







class TargetImpl {
  constructor() {
    this.coords_ = [0, 0, 0];
    this.entity_ = null;
  }

  get coords() {
    return this.coords_;
  }

  get entity() {
    return this.entity_;
  }

}
var VIEW_2D = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('View 2d');
var VIEW_3D = new _utils_injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('View 3d');
function SwappableViewModule(module) {
  module.bind(VIEW_2D, _view2d__WEBPACK_IMPORTED_MODULE_4__["View2dConstructor"]);
  module.bind(VIEW_3D, _view3d__WEBPACK_IMPORTED_MODULE_5__["View3dConstructor"]);
  module.bind(_apis_app__WEBPACK_IMPORTED_MODULE_1__["VIEW"], SwappableViewConstructor);
}
function SwappableViewConstructor(_x) {
  return _SwappableViewConstructor.apply(this, arguments);
}

function _SwappableViewConstructor() {
  _SwappableViewConstructor = _asyncToGenerator(function* (injector) {
    var bus = yield injector.getInstance(_apis_handler__WEBPACK_IMPORTED_MODULE_2__["BUS"]);
    var view = yield Object(_utils_injector__WEBPACK_IMPORTED_MODULE_0__["create"])(injector, SwappableView, _apis_app__WEBPACK_IMPORTED_MODULE_1__["GRID"], VIEW_2D, VIEW_3D, _apis_app__WEBPACK_IMPORTED_MODULE_1__["STATE"]);
    bus.connect(view);
    return view;
  });
  return _SwappableViewConstructor.apply(this, arguments);
}

class SwappableView {
  constructor(gridController, view2d, view3d, state) {
    this.view = void 0;
    this.view2d = void 0;
    this.view3d = void 0;
    this.gridController = void 0;
    this.lastGridScale = void 0;
    this.gridController = gridController;
    this.lastGridScale = gridController.getGridSize();
    this.view2d = view2d;
    this.view3d = view3d;
    this.view = view2d;
    state.register('lookaim', false);
  }

  get sec() {
    return this.view.sec;
  }

  get x() {
    return this.view.x;
  }

  get y() {
    return this.view.y;
  }

  get z() {
    return this.view.z;
  }

  target() {
    return this.view.target();
  }

  snapTarget() {
    return this.view.snapTarget();
  }

  dir() {
    return this.view.dir();
  }

  drawTools(renderables) {
    this.view.drawTools(renderables);
  }

  handle(message) {
    if (message instanceof _edit_messages__WEBPACK_IMPORTED_MODULE_3__["NamedMessage"] && message.name == 'view_mode') {
      var viewPos = this.view.getViewPosition();
      this.view = this.view == this.view3d ? this.view2d : this.view3d;
      var gridScale = this.gridController.getGridSize();
      this.gridController.setGridSize(this.lastGridScale);
      this.lastGridScale = gridScale;
      this.view.activate(viewPos);
      return;
    }

    if (message instanceof _edit_messages__WEBPACK_IMPORTED_MODULE_3__["LoadBoard"]) {
      this.view2d.handle(message);
      this.view3d.handle(message);
      return;
    }

    this.view.handle(message);
  }

}

/***/ }),

/***/ "./src/app/modules/view/view2d.ts":
/*!****************************************!*\
  !*** ./src/app/modules/view/view2d.ts ***!
  \****************************************/
/*! exports provided: View2dConstructor, View2d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View2dConstructor", function() { return View2dConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View2d", function() { return View2d; });
/* harmony import */ var _build_board_distances__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/distances */ "./src/build/board/distances.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/cachedvalue */ "./src/utils/cachedvalue.ts");
/* harmony import */ var _utils_camera_controller2d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/camera/controller2d */ "./src/utils/camera/controller2d.ts");
/* harmony import */ var _utils_interpolator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utils/interpolator */ "./src/utils/interpolator.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_timed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/timed */ "./src/utils/timed.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
/* harmony import */ var _boardrenderer2d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./boardrenderer2d */ "./src/app/modules/view/boardrenderer2d.ts");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./view */ "./src/app/modules/view/view.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
















function View2dConstructor(_x) {
  return _View2dConstructor.apply(this, arguments);
}

function _View2dConstructor() {
  _View2dConstructor = _asyncToGenerator(function* (injector) {
    var [renderer, grid, bgl, board, art, state] = yield Promise.all([Object(_boardrenderer2d__WEBPACK_IMPORTED_MODULE_12__["Renderer2D"])(injector), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_9__["GRID"]), injector.getInstance(_gl_buildgl__WEBPACK_IMPORTED_MODULE_11__["BUILD_GL"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_9__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_9__["ART"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_9__["STATE"])]);
    return new View2d(renderer, grid, bgl, board, art, state);
  });
  return _View2dConstructor.apply(this, arguments);
}

class View2d extends _apis_handler__WEBPACK_IMPORTED_MODULE_10__["MessageHandlerReflective"] {
  constructor(renderer, gridController, buildgl, board, art, state) {
    super();
    this.position = void 0;
    this.control = new _utils_camera_controller2d__WEBPACK_IMPORTED_MODULE_5__["Controller2D"]();
    this.pointer = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
    this.hit = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_4__["CachedValue"](h => this.updateHitscan(h), new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Hitscan"]());
    this.snapTargetValue = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_4__["CachedValue"](t => this.updateSnapTarget(t), new _view__WEBPACK_IMPORTED_MODULE_13__["TargetImpl"]());
    this.direction = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_4__["CachedValue"](r => this.updateDir(r), new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Ray"]());
    this.upp = new _utils_timed__WEBPACK_IMPORTED_MODULE_8__["DelayedValue"](100, 1, _utils_interpolator__WEBPACK_IMPORTED_MODULE_6__["NumberInterpolator"]);
    this.renderer = renderer;
    this.gridController = gridController;
    this.buildgl = buildgl;
    this.board = board;
    this.art = art;
    this.state = state;
    state.register('zoom+', false);
    state.register('zoom-', false);
    this.loadBoard(board());
  }

  get sec() {
    return this.position.sec;
  }

  get x() {
    return this.position.x;
  }

  get y() {
    return this.position.y;
  }

  get z() {
    return this.position.z;
  }

  getProjectionMatrix() {
    return this.control.getProjectionMatrix();
  }

  getTransformMatrix() {
    return this.control.getTransformMatrix();
  }

  getPosition() {
    return this.pointer;
  }

  drawTools(renderables) {
    this.renderer.drawTools(renderables);
  }

  target() {
    return this.hit.get();
  }

  snapTarget() {
    return this.snapTargetValue.get();
  }

  dir() {
    return this.direction.get();
  }

  isWireframe() {
    return true;
  }

  getViewPosition() {
    return this.position;
  }

  activate(pos) {
    this.position = pos;
    this.control.setPosition(this.position.x, this.position.y, this.position.z);
  }

  Mouse(msg) {
    this.control.track(msg.x, msg.y, 1024 * _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"], this.state.get('lookaim'));
    var x = msg.x / this.buildgl.gl.drawingBufferWidth * 2 - 1;
    var y = msg.y / this.buildgl.gl.drawingBufferHeight * 2 - 1;
    var p = this.control.getPointerPosition(this.pointer, x, y);
    this.position.x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_7__["int"])(p[0]);
    this.position.y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_7__["int"])(p[2]);
    var board = this.board();
    if (!Object(_build_board_query__WEBPACK_IMPORTED_MODULE_14__["inSector"])(board, this.position.x, this.position.y, this.position.sec)) this.position.sec = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_14__["findSector"])(board, this.position.x, this.position.y, this.position.sec);
  }

  Frame(msg) {
    this.invalidateTarget();
    this.control.setSize(this.buildgl.gl.drawingBufferWidth, this.buildgl.gl.drawingBufferHeight);
    var max = this.control.getPointerPosition(this.pointer, 1, 1);
    var campos = this.control.getPosition();
    var dist = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_7__["len2d"])(max[0] - campos[0], max[2] - campos[2]);
    this.buildgl.newFrame();
    this.renderer.draw(this, campos, dist, this.control);
    var state = this.state;

    if (state.get('zoom+')) {
      this.upp.set(this.upp.get() / 1.3);
      this.recalcGridSize();
    }

    if (state.get('zoom-')) {
      this.upp.set(this.upp.get() * 1.3);
      this.recalcGridSize();
    }

    this.control.setUnitsPerPixel(this.upp.get());
  }

  recalcGridSize() {
    this.gridController.setGridSize((this.control.getUnitsPerPixel() + 0.5) * 32);
  }

  invalidateTarget() {
    this.snapTargetValue.invalidate();
    this.direction.invalidate();
    this.hit.invalidate();
  }

  BoardInvalidate(msg) {
    this.invalidateTarget();
  }

  LoadBoard(msg) {
    this.loadBoard(msg.board);
  }

  loadBoard(board) {
    var sprite = Object(_build_utils__WEBPACK_IMPORTED_MODULE_2__["getPlayerStart"])(board);
    this.position = {
      x: sprite.x,
      y: sprite.y,
      z: sprite.z,
      sec: sprite.sectnum
    };
    this.control.setPosition(this.position.x, this.position.y, 1024 * _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
    this.invalidateTarget();
  }

  updateHitscan(hit) {
    Object(_build_hitscan__WEBPACK_IMPORTED_MODULE_1__["hitscan"])(this.board(), this.art, this.x, this.y, this.z, this.sec, 0, 0, -1 * _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"], hit, 0);
    return hit;
  }

  updateSnapTarget(target) {
    var board = this.board();
    var d = this.gridController.getGridSize() / 2;
    var s = Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestSpriteInSector"])(board, this.sec, this.x, this.y, d);

    if (s != -1) {
      var sprite = board.sprites[s];
      target.coords_[0] = sprite.x;
      target.coords_[1] = sprite.y;
      target.coords_[2] = sprite.z;
      target.entity_ = new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Entity"](s, _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].SPRITE);
      return target;
    }

    var w = Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallPoint"])(board, this.x, this.y, d);

    if (w != -1) {
      var wall = board.walls[w];
      target.coords_[0] = wall.x;
      target.coords_[1] = wall.y;
      target.entity_ = new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Entity"](w, _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].WALL_POINT);
      return target;
    }

    var ws = Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallSegment"])(board, this.x, this.y, d);

    if (ws != -1) {
      var [x, y] = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_14__["snapWall"])(board, ws, this.x, this.y, this.gridController);
      target.coords_[0] = x;
      target.coords_[1] = y;
      target.entity_ = new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Entity"](ws, _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].MID_WALL);
      return target;
    }

    target.coords_[0] = this.gridController.snap(this.x);
    target.coords_[1] = this.gridController.snap(this.y);
    var sectorId = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_14__["findSector"])(board, this.x, this.y, this.sec);
    target.entity_ = sectorId == -1 ? null : new _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["Entity"](sectorId, _build_hitscan__WEBPACK_IMPORTED_MODULE_1__["EntityType"].FLOOR);
    return target;
  }

  updateDir(ray) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].set(ray.start, this.x, this.y, this.z);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_3__["vec3"].set(ray.dir, 0, 0, -1 * _build_utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
    return ray;
  }

}

/***/ }),

/***/ "./src/app/modules/view/view3d.ts":
/*!****************************************!*\
  !*** ./src/app/modules/view/view3d.ts ***!
  \****************************************/
/*! exports provided: View3dConstructor, View3d */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View3dConstructor", function() { return View3dConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View3d", function() { return View3d; });
/* harmony import */ var _build_board_distances__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/board/distances */ "./src/build/board/distances.ts");
/* harmony import */ var _build_board_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../build/board/query */ "./src/build/board/query.ts");
/* harmony import */ var _build_hitscan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../build/hitscan */ "./src/build/hitscan.ts");
/* harmony import */ var _build_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../build/utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/cachedvalue */ "./src/utils/cachedvalue.ts");
/* harmony import */ var _utils_camera_controller3d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utils/camera/controller3d */ "./src/utils/camera/controller3d.ts");
/* harmony import */ var _utils_interpolator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/interpolator */ "./src/utils/interpolator.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_timed__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utils/timed */ "./src/utils/timed.ts");
/* harmony import */ var _apis_app__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../apis/app */ "./src/app/apis/app.ts");
/* harmony import */ var _apis_handler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../apis/handler */ "./src/app/apis/handler.ts");
/* harmony import */ var _gl_buildgl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../gl/buildgl */ "./src/app/modules/gl/buildgl.ts");
/* harmony import */ var _boardrenderer3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./boardrenderer3d */ "./src/app/modules/view/boardrenderer3d.ts");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./view */ "./src/app/modules/view/view.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
















function View3dConstructor(_x) {
  return _View3dConstructor.apply(this, arguments);
}

function _View3dConstructor() {
  _View3dConstructor = _asyncToGenerator(function* (injector) {
    var [renderer, buildgl, board, state, grid, art] = yield Promise.all([Object(_boardrenderer3d__WEBPACK_IMPORTED_MODULE_13__["Renderer3D"])(injector), injector.getInstance(_gl_buildgl__WEBPACK_IMPORTED_MODULE_12__["BUILD_GL"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["BOARD"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["STATE"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["GRID"]), injector.getInstance(_apis_app__WEBPACK_IMPORTED_MODULE_10__["ART"])]);
    return new View3d(renderer, buildgl, board, state, grid, art);
  });
  return _View3dConstructor.apply(this, arguments);
}

class View3d extends _apis_handler__WEBPACK_IMPORTED_MODULE_11__["MessageHandlerReflective"] {
  constructor(renderer, buildgl, board, state, gridController, art) {
    super();
    this.position = void 0;
    this.aspect = void 0;
    this.control = new _utils_camera_controller3d__WEBPACK_IMPORTED_MODULE_6__["Controller3D"]();
    this.mouseX = 0;
    this.mouseY = 0;
    this.hit = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_5__["CachedValue"](h => this.updateHitscan(h), new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Hitscan"]());
    this.snapTargetValue = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_5__["CachedValue"](t => this.updateSnapTarget(t), new _view__WEBPACK_IMPORTED_MODULE_14__["TargetImpl"]());
    this.direction = new _utils_cachedvalue__WEBPACK_IMPORTED_MODULE_5__["CachedValue"](r => this.updateDir(r), new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Ray"]());
    this.cursor = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
    this.forwardDamper = new _utils_timed__WEBPACK_IMPORTED_MODULE_9__["DelayedValue"](100, 0, _utils_interpolator__WEBPACK_IMPORTED_MODULE_7__["NumberInterpolator"]);
    this.sideDamper = new _utils_timed__WEBPACK_IMPORTED_MODULE_9__["DelayedValue"](100, 0, _utils_interpolator__WEBPACK_IMPORTED_MODULE_7__["NumberInterpolator"]);
    this.renderer = renderer;
    this.buildgl = buildgl;
    this.board = board;
    this.state = state;
    this.gridController = gridController;
    this.art = art;
    this.aspect = this.buildgl.gl.drawingBufferWidth / this.buildgl.gl.drawingBufferHeight;
    this.control.setFov(90);
    state.register('forward', false);
    state.register('backward', false);
    state.register('strafe_left', false);
    state.register('strafe_right', false);
    state.register('camera_speed', 8000);
    this.loadBoard(board());
  }

  get sec() {
    return this.position.sec;
  }

  get x() {
    return this.position.x;
  }

  get y() {
    return this.position.y;
  }

  get z() {
    return this.position.z;
  }

  getProjectionMatrix() {
    return this.control.getProjectionMatrix(this.aspect);
  }

  getTransformMatrix() {
    return this.control.getTransformMatrix();
  }

  getPosition() {
    return this.control.getPosition();
  }

  getForward() {
    return this.control.getForward();
  }

  drawTools(renderables) {
    this.renderer.drawTools(renderables);
  }

  target() {
    return this.hit.get();
  }

  snapTarget() {
    return this.snapTargetValue.get();
  }

  dir() {
    return this.direction.get();
  }

  getViewPosition() {
    return this.position;
  }

  activate(pos) {
    this.position = pos;
    this.control.setPosition(this.position.x, this.position.z / _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"] + 1024, this.position.y);
  }

  Mouse(msg) {
    this.mouseX = msg.x;
    this.mouseY = msg.y;
    this.control.track(msg.x, msg.y, this.state.get('lookaim'));
  }

  Frame(msg) {
    this.invalidateTarget();
    Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["build2gl"])(this.cursor, this.snapTarget().coords);
    this.aspect = this.buildgl.gl.drawingBufferWidth / this.buildgl.gl.drawingBufferHeight;
    this.buildgl.setCursorPosiotion(this.cursor[0], this.cursor[1], this.cursor[2]);
    this.buildgl.newFrame();
    this.renderer.draw(this);
    this.move(msg.dt);
  }

  move(dt) {
    var state = this.state;
    var cameraSpeed = state.get('camera_speed');
    this.forwardDamper.set(0);
    this.sideDamper.set(0);
    if (state.get('forward')) this.forwardDamper.set(1);
    if (state.get('backward')) this.forwardDamper.set(-1);
    if (state.get('strafe_left')) this.sideDamper.set(-1);
    if (state.get('strafe_right')) this.sideDamper.set(1);
    this.control.moveForward(dt * cameraSpeed * this.forwardDamper.get());
    this.control.moveSideway(dt * cameraSpeed * this.sideDamper.get());
    var board = this.board();
    var p = this.control.getPosition();
    this.position.x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["int"])(p[0]);
    this.position.y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["int"])(p[2]);
    this.position.z = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["int"])(p[1] * _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"]);
    if (!Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["inSector"])(board, this.position.x, this.position.y, this.position.sec)) this.position.sec = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["findSector"])(board, this.position.x, this.position.y, this.position.sec);
  }

  NamedMessage(msg) {
    if (msg.name == 'print_info') this.buildgl.printInfo();
  }

  BoardInvalidate(msg) {
    this.invalidateTarget();
  }

  LoadBoard(msg) {
    this.loadBoard(msg.board);
  }

  loadBoard(board) {
    var sprite = Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["getPlayerStart"])(board);
    this.position = {
      x: sprite.x,
      y: sprite.y,
      z: sprite.z,
      sec: sprite.sectnum
    };
    this.control.setPosition(this.position.x, this.position.z / _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"] + 1024, this.position.y);
    this.invalidateTarget();
  }

  invalidateTarget() {
    this.snapTargetValue.invalidate();
    this.direction.invalidate();
    this.hit.invalidate();
  }

  updateHitscan(hit) {
    var {
      start,
      dir
    } = this.dir();
    Object(_build_hitscan__WEBPACK_IMPORTED_MODULE_2__["hitscan"])(this.board(), this.art, start[0], start[1], start[2], this.sec, dir[0], dir[1], dir[2], hit, 0);
    return hit;
  }

  getClosestWall(target, d) {
    var [x, y] = target.coords;
    var board = this.board();
    if (target.entity.isWall()) return Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallInSector"])(board, Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["sectorOfWall"])(board, target.entity.id), x, y, d);else if (target.entity.isSector()) return Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallInSector"])(board, target.entity.id, x, y, d);
    return -1;
  }

  snapGrid(target, t) {
    t.coords_[0] = this.gridController.snap(target.coords[0]);
    t.coords_[1] = this.gridController.snap(target.coords[1]);
    t.coords_[2] = this.gridController.snap(target.coords[2]);
    t.entity_ = target.entity.clone();
    return t;
  }

  snapWall(target, wallId, t) {
    var [x, y] = Object(_build_board_query__WEBPACK_IMPORTED_MODULE_1__["snapWall"])(this.board(), wallId, target.coords[0], target.coords[1], this.gridController);
    t.coords_[0] = x;
    t.coords_[1] = y;
    t.coords_[2] = this.gridController.snap(target.coords[2] / _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"]) * _build_utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"];
    t.entity_ = new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].MID_WALL);
    return t;
  }

  snapWallPoint(target, wallId, t) {
    var wall = this.board().walls[wallId];
    t.coords_[0] = wall.x;
    t.coords_[1] = wall.y;
    t.coords_[2] = target.coords[2];
    t.entity_ = new _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["Entity"](wallId, _build_hitscan__WEBPACK_IMPORTED_MODULE_2__["EntityType"].WALL_POINT);
    return t;
  }

  snapSprite(target, t) {
    var sprite = this.board().sprites[target.entity.id];
    t.coords_[0] = sprite.x;
    t.coords_[1] = sprite.y;
    t.coords_[2] = sprite.z;
    t.entity_ = target.entity.clone();
    return t;
  }

  copyTarget(target, t) {
    t.coords_[0] = target.coords[0];
    t.coords_[1] = target.coords[1];
    t.coords_[2] = target.coords[2];
    t.entity_ = null;
    return t;
  }

  minScale(x) {
    var scale = 1;
    x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_8__["int"])(x);

    while ((x & 1) == 0 && scale <= 1024) {
      x >>= 1;
      scale <<= 1;
    }

    return scale;
  }

  updateGridSize() {
    if (this.state.get('move')) return;
    var target = this.target();
    if (target.entity == null) return;
    var board = this.board();
    var d = 64;
    var w = this.getClosestWall(target, d);

    if (w != -1) {
      var wall = board.walls[w];
      var scale = Math.min(this.minScale(wall.x), this.minScale(wall.y), this.gridController.getGridSize());
      this.gridController.setGridSize(scale);
    } else if (target.entity.isSprite()) {
      var sprite = board.sprites[target.entity.id];

      var _scale = Math.min(this.minScale(sprite.x), this.minScale(sprite.y), this.gridController.getGridSize());

      this.gridController.setGridSize(_scale); // } else if (target.entity.isWall()) {
      //   const [x, y] = snapWall(target.entity.id, target.coords[0], target.coords[1], board, this.gridController);
      //   const scale = Math.min(this.minScale(x), this.minScale(y), this.gridController.getGridSize());
      //   this.gridController.setGridSize(scale);
    }
    /*else if (target.entity.isSector()) {
    this.gridController.setGridSize(512)
    }*/

  }

  updateSnapTarget(t) {
    var target = this.target();
    if (target.entity == null) return this.copyTarget(target, t); // this.updateGridSize();

    var d = 32; //this.gridController.getGridSize() / 2;

    var w = this.getClosestWall(target, d);

    if (w != -1) {
      return this.snapWallPoint(target, w, t);
    } else if (target.entity.isSector()) {
      var _w = Object(_build_board_distances__WEBPACK_IMPORTED_MODULE_0__["closestWallSegmentInSector"])(this.board(), target.entity.id, target.coords[0], target.coords[1], d);

      return _w == -1 ? this.snapGrid(target, t) : this.snapWall(target, _w, t);
    } else if (target.entity.isSprite()) {
      return this.snapSprite(target, t);
    } else if (target.entity.isWall()) {
      return this.snapWall(target, target.entity.id, t);
    }
  }

  updateDir(r) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(r.start, this.x, this.y, this.z);
    var x = this.mouseX / this.buildgl.gl.drawingBufferWidth * 2 - 1;
    var y = this.mouseY / this.buildgl.gl.drawingBufferHeight * 2 - 1;
    Object(_build_utils__WEBPACK_IMPORTED_MODULE_3__["gl2build"])(r.dir, this.control.getForwardUnprojected(this.aspect, x, y));
    return r;
  }

}

/***/ }),

/***/ "./src/build/artpixelprovider.ts":
/*!***************************************!*\
  !*** ./src/build/artpixelprovider.ts ***!
  \***************************************/
/*! exports provided: ArtPixelProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtPixelProvider", function() { return ArtPixelProvider; });
/* harmony import */ var _utils_pixelprovider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/pixelprovider */ "./src/utils/pixelprovider.ts");

class ArtPixelProvider extends _utils_pixelprovider__WEBPACK_IMPORTED_MODULE_0__["AbstractPixelProvider"] {
  constructor(info, pal, plu) {
    if (plu === void 0) {
      plu = x => x;
    }

    super(info.w, info.h);
    this.palTmp = new Uint8Array([0, 0, 0, 255]);
    this.trans = new Uint8Array([0, 0, 0, 255]);
    this.info = info;
    this.pal = pal;
    this.plu = plu;
  }

  putToDst(x, y, dst, dstoff, blend) {
    var img = this.info.img;
    var idx = this.plu(img[y + x * this.info.h]);

    if (idx == 255) {
      blend(dst, dstoff, this.trans, 0);
      return;
    }

    var paloff = idx * 3;
    this.palTmp[0] = this.pal[paloff];
    this.palTmp[1] = this.pal[paloff + 1];
    this.palTmp[2] = this.pal[paloff + 2];
    blend(dst, dstoff, this.palTmp, 0);
  }

}

/***/ }),

/***/ "./src/build/board/distances.ts":
/*!**************************************!*\
  !*** ./src/build/board/distances.ts ***!
  \**************************************/
/*! exports provided: distanceToWallSegment, distanceToWallPoint, closestWallPointDist, closestWallInSectorDist, closestWallSegmentInSectorDist, closestSpriteInSectorDist, closestWallSegmentDist, closestWallPoint, closestWallInSector, closestWallSegmentInSector, closestSpriteInSector, closestWallSegment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceToWallSegment", function() { return distanceToWallSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceToWallPoint", function() { return distanceToWallPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallPointDist", function() { return closestWallPointDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallInSectorDist", function() { return closestWallInSectorDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallSegmentInSectorDist", function() { return closestWallSegmentInSectorDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSpriteInSectorDist", function() { return closestSpriteInSectorDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallSegmentDist", function() { return closestWallSegmentDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallPoint", function() { return closestWallPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallInSector", function() { return closestWallInSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallSegmentInSector", function() { return closestWallSegmentInSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSpriteInSector", function() { return closestSpriteInSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestWallSegment", function() { return closestWallSegment; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loops */ "./src/build/board/loops.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query */ "./src/build/board/query.ts");





function distanceToWallSegment(board, wallId, x, y) {
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lenPointToLine"])(x, y, wall.x, wall.y, wall2.x, wall2.y);
}
function distanceToWallPoint(board, wallId, x, y) {
  var wall = board.walls[wallId];
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["len2d"])(x - wall.x, y - wall.y);
}

function distance(ids, distf) {
  var id = -1;
  var mindist = Number.MAX_VALUE;

  for (var i of ids) {
    var dist = distf(i);

    if (dist < mindist) {
      id = i;
      mindist = dist;
    }
  }

  return [id, mindist];
}

function closestWallPointDist(board, x, y) {
  return distance(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, board.numwalls), w => distanceToWallPoint(board, w, x, y));
}
function closestWallInSectorDist(board, sectorId, x, y) {
  return distance(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["sectorWalls"])(board, sectorId), w => distanceToWallPoint(board, w, x, y));
}
function closestWallSegmentInSectorDist(board, sectorId, x, y) {
  return distance(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["sectorWalls"])(board, sectorId), w => distanceToWallSegment(board, w, x, y));
}
function closestSpriteInSectorDist(board, secId, x, y) {
  var sprites = board.sprites;
  return distance(Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, board.numsprites)).filter(s => sprites[s].sectnum == secId), s => Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["len2d"])(sprites[s].x - x, sprites[s].y - y));
}
function closestWallSegmentDist(board, x, y) {
  var sectorId = Object(_query__WEBPACK_IMPORTED_MODULE_4__["findSector"])(board, x, y);
  return sectorId == -1 ? distance(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, board.numwalls), w => distanceToWallSegment(board, w, x, y)) : closestWallSegmentInSectorDist(board, sectorId, x, y);
}
function closestWallPoint(board, x, y, d) {
  var [w, dist] = closestWallPointDist(board, x, y);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lse"])(dist, d) ? w : -1;
}
function closestWallInSector(board, sectorId, x, y, d) {
  var [w, dist] = closestWallInSectorDist(board, sectorId, x, y);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lse"])(dist, d) ? w : -1;
}
function closestWallSegmentInSector(board, sectorId, x, y, d) {
  var [w, dist] = closestWallSegmentInSectorDist(board, sectorId, x, y);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lse"])(dist, d) ? w : -1;
}
function closestSpriteInSector(board, secId, x, y, d) {
  var [s, dist] = closestSpriteInSectorDist(board, secId, x, y);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lse"])(dist, d) ? s : -1;
}
function closestWallSegment(board, x, y, d) {
  var [w, dist] = closestWallSegmentDist(board, x, y);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["lse"])(dist, d) ? w : -1;
}

/***/ }),

/***/ "./src/build/board/loops.ts":
/*!**********************************!*\
  !*** ./src/build/board/loops.ts ***!
  \**********************************/
/*! exports provided: sectorWalls, loopPoints, loopWalls, loopStart, wallsBetween, innerSectorsOfLoop, innerSectors, innerWalls, isOuterLoop, canonicalWall, connectedWalls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorWalls", function() { return sectorWalls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loopPoints", function() { return loopPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loopWalls", function() { return loopWalls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loopStart", function() { return loopStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wallsBetween", function() { return wallsBetween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "innerSectorsOfLoop", function() { return innerSectorsOfLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "innerSectors", function() { return innerSectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "innerWalls", function() { return innerWalls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOuterLoop", function() { return isOuterLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canonicalWall", function() { return canonicalWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectedWalls", function() { return connectedWalls; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/build/utils.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query */ "./src/build/board/query.ts");




function* sectorWalls(board, sectorId) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_3__["isValidSectorId"])(board, sectorId)) throw new Error("Invalid sectorId: " + sectorId);
  var sector = board.sectors[sectorId];
  var end = sector.wallnum + sector.wallptr;

  for (var w = sector.wallptr; w < end; w++) {
    yield w;
  }
}
function* loopPoints(board, sectorId) {
  for (var w of sectorWalls(board, sectorId)) {
    var wall = board.walls[w];
    if (w > wall.point2) yield w;
  }
}
function* loopWalls(board, wallId) {
  var start = loopStart(board, wallId);
  yield start;

  for (var w = board.walls[start].point2; w != start; w = board.walls[w].point2) {
    yield w;
  }
}
function loopStart(board, wallId) {
  if (wallId < 0 || wallId >= board.numwalls) throw new Error("Invalid wallId: " + wallId);
  if (wallId > board.walls[wallId].point2) return board.walls[wallId].point2;

  for (var w = board.walls[wallId].point2; w != wallId; w = board.walls[w].point2) {
    var wall = board.walls[w];
    if (w > wall.point2) return wall.point2;
  }

  throw new Error("Corrupted Board");
}
function* wallsBetween(board, from, to) {
  if (loopStart(board, from) != loopStart(board, to)) throw new Error("Walls " + from + " and " + to + " not from one loop");

  for (var w = from; w != to; w = board.walls[w].point2) {
    yield w;
  }
}
function innerSectorsOfLoop(board, wallId, sectors) {
  if (sectors === void 0) {
    sectors = new Set();
  }

  if (isOuterLoop(board, wallId)) return sectors;

  for (var w of loopWalls(board, wallId)) {
    var wall = board.walls[w];
    var nextsector = wall.nextsector;
    if (nextsector == -1 || sectors.has(nextsector)) continue;
    sectors.add(nextsector);
    innerSectors(board, nextsector, sectors);
  }

  return sectors;
}
function innerSectors(board, sectorId, sectors) {
  if (sectors === void 0) {
    sectors = new Set();
  }

  for (var loopoint of loopPoints(board, sectorId)) {
    innerSectorsOfLoop(board, loopoint, sectors);
  }

  return sectors;
}
function innerWalls(board, wallId) {
  var loop = new Set(loopWalls(board, wallId));

  for (var isec of innerSectorsOfLoop(board, wallId)) {
    for (var w of sectorWalls(board, isec)) {
      loop.add(w);
    }
  }

  return loop;
}
function isOuterLoop(board, wallId) {
  var WALL_MAPPER = w => [board.walls[w].x, board.walls[w].y];

  return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["clockwise"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["map"])(loopWalls(board, wallId), WALL_MAPPER));
}
function canonicalWall(board, wallId) {
  var canonical = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_1__["minValue"])(wallId);
  var w = wallId;

  do {
    var wall = board.walls[w];

    if (wall.nextwall != -1) {
      w = Object(_query__WEBPACK_IMPORTED_MODULE_3__["nextwall"])(board, wall.nextwall);
      canonical.set(w);
    } else {
      w = wallId;

      do {
        var _wall = board.walls[Object(_query__WEBPACK_IMPORTED_MODULE_3__["lastwall"])(board, w)];

        if (_wall.nextwall != -1) {
          w = _wall.nextwall;
          canonical.set(w);
        } else break;
      } while (w != wallId);
    }
  } while (w != wallId);

  return canonical.get();
}
function connectedWalls(board, wallId, result) {
  if (result === void 0) {
    result = new Set();
  }

  var walls = board.walls;
  var counter = 0;
  var w = wallId;
  result.add(w);

  do {
    var wall = walls[w];

    if (wall.nextwall != -1) {
      w = Object(_query__WEBPACK_IMPORTED_MODULE_3__["nextwall"])(board, wall.nextwall);
      result.add(w);
    } else {
      w = wallId;

      do {
        var last = Object(_query__WEBPACK_IMPORTED_MODULE_3__["lastwall"])(board, w);
        var _wall2 = walls[last];

        if (_wall2.nextwall != -1) {
          w = _wall2.nextwall;
          result.add(w);
        } else break;
      } while (w != wallId);
    }

    counter++;
    if (counter > board.numwalls) throw new Error('Cycled connected walls');
  } while (w != wallId);

  return result;
}

/***/ }),

/***/ "./src/build/board/mutations/ceatesector.ts":
/*!**************************************************!*\
  !*** ./src/build/board/mutations/ceatesector.ts ***!
  \**************************************************/
/*! exports provided: createNewSector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNewSector", function() { return createNewSector; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");
/* harmony import */ var _sectorbuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sectorbuilder */ "./src/build/board/mutations/sectorbuilder.ts");
/* harmony import */ var _walls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./walls */ "./src/build/board/mutations/walls.ts");







function searchMatchWall(board, p1, p2) {
  for (var s = 0; s < board.numsectors; s++) {
    var sec = board.sectors[s];
    var end = sec.wallptr + sec.wallnum;

    for (var _w = sec.wallptr; _w < end; _w++) {
      var wall1 = board.walls[_w];
      if (wall1 == null || wall1.nextwall != -1) continue;
      var wall2 = board.walls[wall1.point2];

      if (wall1.x == p2[0] && wall1.y == p2[1] && wall2.x == p1[0] && wall2.y == p1[1]) {
        return [s, _w];
      }
    }
  }

  return null;
}

function matchWalls(board, points) {
  return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["loopPairs"])(points)).map((_ref) => {
    var [p1, p2] = _ref;
    return searchMatchWall(board, p1, p2);
  }).collect();
}

function commonSectorWall(board, matched, api) {
  for (var m of matched) {
    if (m != null) return [board.sectors[m[0]], board.walls[m[1]]];
  }

  return [api.newSector(), api.newWall()];
}

function* createNewWalls(points, matchedWalls, commonWall, board, cloneWall) {
  for (var [[x, y], i] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["enumerate"])(points)) {
    var matchedWall = matchedWalls[i];
    var baseWall = matchedWall == null ? commonWall : board.walls[matchedWall[1]];
    var wall = cloneWall(baseWall);
    wall.x = x;
    wall.y = y;

    if (matchedWall != null) {
      wall.nextwall = matchedWall[1];
      wall.nextsector = matchedWall[0];
    } else {
      wall.nextwall = -1;
      wall.nextsector = -1;
    }

    yield wall;
  }
}

function createNewSector(board, points, refs, api) {
  points = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["wrap"])([...Object(_utils__WEBPACK_IMPORTED_MODULE_2__["order"])(points)]);
  var mwalls = matchWalls(board, points);
  var [commonSector, commonWall] = commonSectorWall(board, mwalls, api);
  var sector = api.cloneSector(commonSector);
  var sectorId = Object(_internal__WEBPACK_IMPORTED_MODULE_3__["addSector"])(board, sector);
  var walls = createNewWalls(points, mwalls, commonWall, board, api.cloneWall);
  new _sectorbuilder__WEBPACK_IMPORTED_MODULE_4__["SectorBuilder"]().addLoop(walls).build(board, sectorId, refs);

  for (var _w2 = sector.wallptr; _w2 < sector.wallptr + sector.wallnum; _w2++) {
    Object(_walls__WEBPACK_IMPORTED_MODULE_5__["fixxrepeat"])(board, _w2);
  }

  return sectorId;
}

/***/ }),

/***/ "./src/build/board/mutations/drawwall.ts":
/*!***********************************************!*\
  !*** ./src/build/board/mutations/drawwall.ts ***!
  \***********************************************/
/*! exports provided: Point, PortalType, buildHull, drawWall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortalType", function() { return PortalType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildHull", function() { return buildHull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawWall", function() { return drawWall; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _mutations_sectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../mutations/sectors */ "./src/build/board/mutations/sectors.ts");
/* harmony import */ var _ceatesector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ceatesector */ "./src/build/board/mutations/ceatesector.ts");
/* harmony import */ var _walls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./walls */ "./src/build/board/mutations/walls.ts");
/* harmony import */ var _mutations_splitsector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../mutations/splitsector */ "./src/build/board/mutations/splitsector.ts");
/* harmony import */ var _distances__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../distances */ "./src/build/board/distances.ts");











class Point {
  constructor(off, x, y, zup, zdown, zupoff, zdownoff) {
    if (zupoff === void 0) {
      zupoff = 0;
    }

    if (zdownoff === void 0) {
      zdownoff = 0;
    }

    this.off = off;
    this.x = x;
    this.y = y;
    this.zup = zup;
    this.zdown = zdown;
    this.zupoff = zupoff;
    this.zdownoff = zdownoff;
  }

}
var PortalType;

(function (PortalType) {
  PortalType[PortalType["UP"] = 0] = "UP";
  PortalType[PortalType["DOWN"] = 1] = "DOWN";
  PortalType[PortalType["MID"] = 2] = "MID";
})(PortalType || (PortalType = {}));

;

function findIndex(points, off) {
  for (var i = 0; i < points.length; i++) {
    if (points[i].off >= off) return i;
  }

  return points.length;
}

function convert(hull) {
  var newHull = [];
  var lastUp = 0,
      lastDown = 0;

  for (var i = 0; i < hull.length; i++) {
    var p = hull[i];

    if (i == 0) {
      newHull.push(new Point(p.off, Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.x), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.y), p.upline[0], p.downline[0]));
    } else if (i == hull.length - 1) {
      newHull.push(new Point(p.off, Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.x), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.y), lastUp, lastDown));
    } else {
      var upoff = p.upline[0] - lastUp;
      var downoff = p.downline[0] - lastDown;
      newHull.push(new Point(p.off, Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.x), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p.y), lastUp, lastDown, upoff, downoff));
    }

    lastUp = p.upline[1];
    lastDown = p.downline[1];
  }

  return newHull;
}

function buildHull(points, proj) {
  var hull = [];

  for (var [_x, _y, _] of points) {
    var [xp, yp, _off] = proj(_x, _y);
    var idx = findIndex(hull, _off);
    if (idx == hull.length || hull[idx].off != _off) hull.splice(idx, 0, new HullPoint(_off, xp, yp));
  }

  for (var i = 0; i < points.length; i++) {
    var p1 = points[i];
    var p2 = points[Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["cyclic"])(i + 1, points.length)];
    var vertical = p1[0] == p2[0] && p1[1] == p2[1];

    if (!vertical) {
      var pp1 = proj(p1[0], p1[1]);
      var pp2 = proj(p2[0], p2[1]);
      var [start, end, dz, startz] = pp1[2] > pp2[2] ? [pp2[2], pp1[2], p1[2] - p2[2], p2[2]] : [pp1[2], pp2[2], p2[2] - p1[2], p1[2]];

      var _idx = findIndex(hull, start);

      while (hull[_idx].off != end) {
        var doff1 = (hull[_idx].off - start) / (end - start);
        var doff2 = (hull[_idx + 1].off - start) / (end - start);

        hull[_idx].addLine(startz + doff1 * dz, startz + doff2 * dz);

        _idx++;
      }
    }
  }

  return convert(hull);
}

class HullPoint {
  constructor(off, x, y) {
    this.upline = [-Number.MAX_VALUE, -Number.MAX_VALUE];
    this.downline = [Number.MAX_VALUE, Number.MAX_VALUE];
    this.off = off;
    this.x = x;
    this.y = y;
  }

  addLine(z1, z2) {
    if (z1 == Number.MAX_VALUE || z1 == -Number.MAX_VALUE) return;

    if (z1 > this.upline[0] || z1 == this.upline[0] && z2 > this.upline[1]) {
      var [lastup0, lastup1] = this.upline;
      this.upline[0] = z1;
      this.upline[1] = z2;
      this.addLine(lastup0, lastup1);
    } else if (z1 < this.downline[0] || z1 == this.downline[0] && z2 < this.downline[1]) {
      var [lastdown0, lastdown1] = this.downline;
      this.downline[0] = z1;
      this.downline[1] = z2;
      this.addLine(lastdown0, lastdown1);
    }
  }

}

function drawWall(board, wallId, type, hull, art, refs, api, dist) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_4__["isValidWallId"])(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  var wall = board.walls[wallId];
  if (wall.nextsector == -1 && dist > 0) throw new Error();
  var [nx,, ny] = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["wallNormal"])(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), board, wallId);
  var sectorId = Object(_query__WEBPACK_IMPORTED_MODULE_4__["sectorOfWall"])(board, wallId);

  for (var p of hull) {
    Object(_walls__WEBPACK_IMPORTED_MODULE_8__["splitWall"])(board, Object(_distances__WEBPACK_IMPORTED_MODULE_10__["closestWallSegmentInSector"])(board, sectorId, p.x, p.y, 0), p.x, p.y, art, refs, api.cloneWall);
  }

  if (type == PortalType.MID) mid(dist, hull, nx, ny, sectorId, board, refs, api);else if (type == PortalType.DOWN) nonMid(dist, hull, nx, ny, sectorId, board, refs, api, true);else if (type == PortalType.UP) nonMid(dist, hull, nx, ny, sectorId, board, refs, api, false);
}

function nonMid(dist, hull, nx, ny, sectorId, board, refs, api, down) {
  for (var i = 0; i < hull.length - 1; i++) {
    var p1 = hull[i];
    var p2 = hull[i + 1];
    var points = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    if (i == 0) points.push([p1.x, p1.y]);
    points.push([Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p1.x + nx * dist), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p1.y + ny * dist)]).push([Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p2.x + nx * dist), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p2.y + ny * dist)]).push([p2.x, p2.y]);
    var sec = Object(_mutations_splitsector__WEBPACK_IMPORTED_MODULE_9__["splitSector"])(board, sectorId, points, refs, api);
    var sector = board.sectors[sec];
    var firsWall = Object(_query__WEBPACK_IMPORTED_MODULE_4__["lastwall"])(board, Object(_query__WEBPACK_IMPORTED_MODULE_4__["wallInSector"])(board, sec, p1.x, p1.y));
    Object(_mutations_sectors__WEBPACK_IMPORTED_MODULE_6__["setFirstWall"])(board, sec, firsWall, refs);
    var doff = p2.off - p1.off;
    var z = down ? p1.zup + p1.zupoff : p1.zdown + p1.zdownoff;
    var k = (down ? p2.zup - z : p2.zdown - z) / doff;

    if (down) {
      sector.floorz = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(z * _utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
      sector.floorheinum = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(k / _utils__WEBPACK_IMPORTED_MODULE_2__["ANGSCALE"]);
    } else {
      sector.ceilingz = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(z * _utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
      sector.ceilingheinum = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(k / _utils__WEBPACK_IMPORTED_MODULE_2__["ANGSCALE"]);
    }
  }
}

function findPortalWall(board, fromSectorId, toSectorId) {
  for (var w of Object(_loops__WEBPACK_IMPORTED_MODULE_3__["sectorWalls"])(board, fromSectorId)) {
    if (board.walls[w].nextsector == toSectorId) return board.walls[w].nextwall;
  }

  return -1;
}

function mid(dist, hull, nx, ny, sectorId, board, refs, api) {
  for (var i = 0; i < hull.length - 1; i++) {
    var p1 = hull[i];
    var p2 = hull[i + 1];
    var points = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]().push([p1.x, p1.y]).push([p2.x, p2.y]).push([Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p2.x + nx * dist), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p2.y + ny * dist)]).push([Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p1.x + nx * dist), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(p1.y + ny * dist)]);
    var newSectorId = Object(_ceatesector__WEBPACK_IMPORTED_MODULE_7__["createNewSector"])(board, points, refs, api);
    var sector = board.sectors[newSectorId];
    var firsWall = Object(_query__WEBPACK_IMPORTED_MODULE_4__["wallInSector"])(board, newSectorId, p1.x, p1.y);
    Object(_mutations_sectors__WEBPACK_IMPORTED_MODULE_6__["setFirstWall"])(board, newSectorId, firsWall, refs);
    var doff = p2.off - p1.off;
    var floorz = p1.zdown + p1.zdownoff;
    var ceilingz = p1.zup + p1.zupoff;
    var floork = (p2.zdown - floorz) / doff;
    var ceilingk = (p2.zup - ceilingz) / doff;
    sector.floorz = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(floorz * _utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
    sector.ceilingz = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(ceilingz * _utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"]);
    sector.floorheinum = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(floork / _utils__WEBPACK_IMPORTED_MODULE_2__["ANGSCALE"]);
    sector.ceilingheinum = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_5__["int"])(ceilingk / _utils__WEBPACK_IMPORTED_MODULE_2__["ANGSCALE"]);
    var pwall = findPortalWall(board, newSectorId, sectorId);
    board.walls[pwall].cstat.alignBottom = 1;
  }
}

/***/ }),

/***/ "./src/build/board/mutations/internal.ts":
/*!***********************************************!*\
  !*** ./src/build/board/mutations/internal.ts ***!
  \***********************************************/
/*! exports provided: DEFAULT_REPEAT_RATE, addSprite, deleteSprite, addSector, deleteSector, moveWalls, resizeWalls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_REPEAT_RATE", function() { return DEFAULT_REPEAT_RATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSprite", function() { return addSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteSprite", function() { return deleteSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSector", function() { return addSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteSector", function() { return deleteSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveWalls", function() { return moveWalls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeWalls", function() { return resizeWalls; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");



var DEFAULT_REPEAT_RATE = 128;
function addSprite(board, sprite) {
  var newSpriteId = board.numsprites;
  board.sprites[newSpriteId] = sprite;
  board.numsprites++;
  return newSpriteId;
}
function deleteSprite(board, spriteId) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_2__["isValidSpriteId"])(board, spriteId)) throw new Error("Invalid spriteId: " + spriteId);

  for (var i = spriteId; i < board.numsprites; i++) {
    board.sprites[i] = board.sprites[i + 1];
  }

  board.sprites[board.numsprites - 1] = null;
  board.numsprites--;
}
function addSector(board, sector) {
  var newSectorIdx = board.numsectors;
  board.sectors[newSectorIdx] = sector;
  sector.wallptr = board.numwalls;
  sector.wallnum = 0;
  board.numsectors++;
  return newSectorIdx;
}
function deleteSector(board, sectorId, refs) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_2__["isValidSectorId"])(board, sectorId)) throw new Error("Invalid sectorId: " + sectorId);
  var sector = board.sectors[sectorId];
  var wallsend = sector.wallptr + sector.wallnum;

  for (var w = sector.wallptr; w < wallsend; w++) {
    var wall = board.walls[w];

    if (wall.nextwall != -1) {
      var nextwall = board.walls[wall.nextwall];
      nextwall.nextsector = -1;
      nextwall.nextwall = -1;
    }
  }

  updateSpriteSector(board, sectorId);
  resizeWalls(board, sectorId, 0, refs);
  deleteSectorImpl(board, sectorId, refs);
}

function updateSpriteSector(board, fromSector) {
  Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, board.numsprites)).map(s => board.sprites[s]).filter(s => s.sectnum == fromSector).forEach(s => s.sectnum = -1);
}

function deleteSectorImpl(board, sectorId, refs) {
  if (board.sectors[sectorId].wallnum != 0) throw new Error("Error while deleting sector #" + sectorId + ". wallnum != 0");

  for (var w = 0; w < board.numwalls; w++) {
    var wall = board.walls[w];
    if (wall.nextsector == sectorId) throw new Error("Error while deleting sector #" + sectorId + ". Wall #" + w + " referencing sector");
    if (wall.nextsector > sectorId) wall.nextsector--;
  }

  for (var s = 0; s < board.numsprites; s++) {
    var spr = board.sprites[s];
    if (spr.sectnum == sectorId) throw new Error("Error while deleting sector #" + sectorId + ". Sprite #" + s + " referencing sector");
    if (spr.sectnum > sectorId) spr.sectnum--;
  }

  for (var _s = sectorId; _s < board.numsectors - 1; _s++) {
    board.sectors[_s] = board.sectors[_s + 1];
  }

  refs.sectors.update(s => s == sectorId ? -1 : s > sectorId ? s - 1 : s);
  board.sectors[board.numsectors - 1] = null;
  board.numsectors--;
}

function updateWallIds(afterWallId, size) {
  return w => {
    if (size < 0 && w >= afterWallId && w < afterWallId - size) return -1;else if (w > afterWallId) return w + size;
    return w;
  };
}

function moveWalls(board, secId, afterWallId, size, refs) {
  if (size == 0) return;
  if (size < 0) Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["forEach"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(afterWallId, afterWallId - size), w => board.walls[w] = null);

  for (var w = 0; w < board.numwalls; w++) {
    var wall = board.walls[w];
    if (wall == null) continue;
    if (wall.point2 > afterWallId) wall.point2 += size;
    if (wall.nextwall > afterWallId) wall.nextwall += size;
  }

  refs.walls.update(updateWallIds(afterWallId, size));

  if (size > 0) {
    var end = board.numwalls - 1;

    for (var i = end; i > afterWallId; i--) {
      board.walls[i + size] = board.walls[i];
    }

    for (var _i = 0; _i < size; _i++) {
      board.walls[_i + afterWallId + 1] = null;
    }
  } else {
    var _end = board.numwalls + size;

    for (var _i2 = afterWallId; _i2 < _end; _i2++) {
      board.walls[_i2] = board.walls[_i2 - size];
    }

    for (var _i3 = 0; _i3 < -size; _i3++) {
      board.walls[_end + _i3] = null;
    }
  }

  board.numwalls += size;
  board.sectors[secId].wallnum += size;

  for (var _i4 = 0; _i4 < board.numsectors; _i4++) {
    var sec = board.sectors[_i4];
    if (sec.wallptr >= afterWallId + 1 && _i4 != secId) sec.wallptr += size;
  }
}
function resizeWalls(board, sectorId, newSize, refs) {
  var sec = board.sectors[sectorId];
  var dw = newSize - sec.wallnum;
  if (dw == 0) return;

  if (dw > 0) {
    moveWalls(board, sectorId, sec.wallptr + sec.wallnum - 1, dw, refs);
  } else {
    moveWalls(board, sectorId, sec.wallptr + newSize, dw, refs);
  }
}

/***/ }),

/***/ "./src/build/board/mutations/joinsectors.ts":
/*!**************************************************!*\
  !*** ./src/build/board/mutations/joinsectors.ts ***!
  \**************************************************/
/*! exports provided: joinSectors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinSectors", function() { return joinSectors; });
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _mutations_sectorbuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mutations/sectorbuilder */ "./src/build/board/mutations/sectorbuilder.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");





function fillSectorWalls(board, s, set) {
  for (var w of Object(_loops__WEBPACK_IMPORTED_MODULE_0__["sectorWalls"])(board, s)) {
    set.add(w);
  }
}

var _wallset = new Set();

function fillWallSet(board, s1, s2) {
  _wallset.clear();

  fillSectorWalls(board, s1, _wallset);
  fillSectorWalls(board, s2, _wallset);
  return _wallset;
}

function getJoinedWallsLoops(board, s1, s2) {
  var builder = new _mutations_sectorbuilder__WEBPACK_IMPORTED_MODULE_1__["SectorBuilder"]();
  var wallset = fillWallSet(board, s1, s2);
  var values = wallset.values();

  for (var it = values.next(); !it.done; it = values.next()) {
    var w = it.value;
    var loopstart = w;

    for (;;) {
      wallset.delete(w);
      var wall = board.walls[w];

      if (wall.nextsector == s1 || wall.nextsector == s2) {
        wallset.delete(wall.nextwall);
        w = board.walls[wall.nextwall].point2;
      } else {
        builder.addWall(wall);
        w = wall.point2;
      }

      if (w == loopstart) {
        builder.loop();
        break;
      }
    }
  }

  return builder;
}

function joinSectors(board, s1, s2, refs) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_2__["isJoinedSectors"])(board, s1, s2)) return -1;
  getJoinedWallsLoops(board, s1, s2).build(board, s1, refs);
  Object(_internal__WEBPACK_IMPORTED_MODULE_3__["deleteSector"])(board, s2, refs);
  return 0;
}

/***/ }),

/***/ "./src/build/board/mutations/sectorbuilder.ts":
/*!****************************************************!*\
  !*** ./src/build/board/mutations/sectorbuilder.ts ***!
  \****************************************************/
/*! exports provided: SectorBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorBuilder", function() { return SectorBuilder; });
/* harmony import */ var _app_apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../app/apis/referencetracker */ "./src/app/apis/referencetracker.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");



class SectorBuilder {
  constructor() {
    this.walls = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.looppoints = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
  }

  addWall(wall) {
    this.walls.push(wall);
    return this;
  }

  addWalls(walls) {
    this.walls.pushAll(walls);
    return this;
  }

  addLoop(walls) {
    return this.addWalls(walls).loop();
  }

  getWalls() {
    return this.walls;
  }

  loop() {
    if (this.walls.length() == 0 || this.looppoints.top() == this.walls.length()) return this;
    this.looppoints.push(this.walls.length());
    return this;
  }

  build(board, sectorId, refs) {
    Object(_app_apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__["track"])(refs.walls, wallRefs => {
      var nextWallPtrs = [...Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["map"])(this.walls, w => wallRefs.ref(w.nextwall))];
      Object(_internal__WEBPACK_IMPORTED_MODULE_2__["resizeWalls"])(board, sectorId, this.walls.length(), refs);
      Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["forEach"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["enumerate"])(this.walls), (_ref) => {
        var [w, i] = _ref;
        return w.nextwall = wallRefs.val(nextWallPtrs[i]);
      });
    });
    var sec = board.sectors[sectorId];
    var loopIter = this.looppoints[Symbol.iterator]();
    var loopStart = sec.wallptr;
    var loopEnd = loopIter.next().value;

    for (var [wall, i] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["enumerate"])(this.walls)) {
      var w = i + sec.wallptr;
      board.walls[w] = wall;

      if (loopEnd == i + 1) {
        wall.point2 = loopStart;
        loopStart = w + 1;
        loopEnd = loopIter.next().value;
      } else {
        wall.point2 = w + 1;
      }

      if (wall.nextwall != -1) {
        var nextwall = board.walls[wall.nextwall];
        nextwall.nextsector = sectorId;
        nextwall.nextwall = w;
      }
    }
  }

}

/***/ }),

/***/ "./src/build/board/mutations/sectors.ts":
/*!**********************************************!*\
  !*** ./src/build/board/mutations/sectors.ts ***!
  \**********************************************/
/*! exports provided: fillInnerLoop, createInnerLoop, setFirstWall, deleteLoop, deleteSectorFull, deleteLoopFull */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillInnerLoop", function() { return fillInnerLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInnerLoop", function() { return createInnerLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFirstWall", function() { return setFirstWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteLoop", function() { return deleteLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteSectorFull", function() { return deleteSectorFull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteLoopFull", function() { return deleteLoopFull; });
/* harmony import */ var _app_apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../app/apis/referencetracker */ "./src/app/apis/referencetracker.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");
/* harmony import */ var _ceatesector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ceatesector */ "./src/build/board/mutations/ceatesector.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");
/* harmony import */ var _sectorbuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sectorbuilder */ "./src/build/board/mutations/sectorbuilder.ts");
/* harmony import */ var _walls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./walls */ "./src/build/board/mutations/walls.ts");









function fillInnerLoop(board, wallId, refs, api) {
  if (Object(_loops__WEBPACK_IMPORTED_MODULE_3__["isOuterLoop"])(board, wallId)) throw new Error('Only inner loops can be filled');
  if (Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["any"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopWalls"])(board, wallId), w => board.walls[w].nextsector != -1)) throw new Error("Already filled");

  var WALL_MAPPER = w => [board.walls[w].x, board.walls[w].y];

  var points = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["wrap"])([...Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["map"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopWalls"])(board, wallId), WALL_MAPPER)]);
  Object(_ceatesector__WEBPACK_IMPORTED_MODULE_5__["createNewSector"])(board, points, refs, api);
}
function createInnerLoop(board, sectorId, points, refs, api) {
  var sector = board.sectors[sectorId];
  var pointsLength = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["length"])(points);
  Object(_internal__WEBPACK_IMPORTED_MODULE_6__["resizeWalls"])(board, sectorId, sector.wallnum + pointsLength, refs);
  var wallPtr = sector.wallptr + sector.wallnum - pointsLength;
  var firstWall = board.walls[sector.wallptr];
  points = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["order"])(points, false);

  for (var [[x, y], i] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["enumerate"])(points)) {
    var wall = api.cloneWall(firstWall);
    wall.x = x;
    wall.y = y;
    wall.point2 = i == pointsLength - 1 ? wallPtr : wallPtr + i + 1;
    wall.nextsector = wall.nextwall = -1;
    board.walls[wallPtr + i] = wall;
  }

  for (var w = wallPtr; w < sector.wallptr + sector.wallnum; w++) {
    Object(_walls__WEBPACK_IMPORTED_MODULE_8__["fixxrepeat"])(board, w);
  }
}
function setFirstWall(board, sectorId, newFirstWall, refs) {
  var sector = board.sectors[sectorId];
  if (sector.wallptr == newFirstWall) return;
  var end = sector.wallptr + sector.wallnum;
  if (newFirstWall < sector.wallptr || newFirstWall >= end) throw new Error("Wall " + newFirstWall + " not in sector " + sectorId);
  var loops = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
  var newFirstWallLoop = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
  var currentLoop = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
  var firstWallLoopPos = -1;

  for (var w = sector.wallptr; w < end; w++) {
    if (w == newFirstWall) firstWallLoopPos = currentLoop.length();
    var wall = board.walls[w];
    currentLoop.push(wall);

    if (wall.point2 < w) {
      if (firstWallLoopPos != -1) {
        for (var i of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["cyclicRange"])(firstWallLoopPos, currentLoop.length())) {
          newFirstWallLoop.push(currentLoop.get(i));
        }

        firstWallLoopPos = -1;
      } else {
        loops.push(currentLoop);
      }

      currentLoop = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    }
  }

  var builder = new _sectorbuilder__WEBPACK_IMPORTED_MODULE_7__["SectorBuilder"]().addLoop(newFirstWallLoop);

  for (var loop of loops) {
    builder.addLoop(loop);
  }

  builder.build(board, sectorId, refs);
}
function deleteLoop(board, wallId, refs) {
  if (Object(_loops__WEBPACK_IMPORTED_MODULE_3__["isOuterLoop"])(board, wallId)) throw new Error('Cannot delete outer loops');
  var loop = [...Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopWalls"])(board, wallId)];
  if (Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["any"])(loop, w => board.walls[w].nextsector != -1)) throw new Error('Cannot delete filled loop');
  var sectorId = Object(_query__WEBPACK_IMPORTED_MODULE_4__["sectorOfWall"])(board, wallId);
  Object(_internal__WEBPACK_IMPORTED_MODULE_6__["moveWalls"])(board, sectorId, loop[0], -loop.length, refs);
}

function deleteSectors(board, sectors, refs) {
  Object(_app_apis_referencetracker__WEBPACK_IMPORTED_MODULE_0__["track"])(refs.sectors, sectorRefs => {
    var secs = [...Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["map"])(sectors, s => sectorRefs.ref(s))];

    for (var s of secs) {
      Object(_internal__WEBPACK_IMPORTED_MODULE_6__["deleteSector"])(board, sectorRefs.val(s), refs);
    }
  });
}

function deleteSectorFull(board, sectorId, refs) {
  deleteSectors(board, Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["chain"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["innerSectors"])(board, sectorId), [sectorId]), refs);
}
function deleteLoopFull(board, wallId, refs) {
  deleteSectors(board, Object(_loops__WEBPACK_IMPORTED_MODULE_3__["innerSectorsOfLoop"])(board, wallId), refs);
}

/***/ }),

/***/ "./src/build/board/mutations/splitsector.ts":
/*!**************************************************!*\
  !*** ./src/build/board/mutations/splitsector.ts ***!
  \**************************************************/
/*! exports provided: splitSector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitSector", function() { return splitSector; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _sectorbuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sectorbuilder */ "./src/build/board/mutations/sectorbuilder.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");








function* createNewWalls(points, matchWalls, commonWall, board, cloneWall) {
  for (var [p, i] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["enumerate"])(points)) {
    var matchWall = matchWalls[i];
    var baseWall = matchWall == null ? commonWall : board.walls[matchWall[1]];
    var wall = cloneWall(baseWall);
    wall.x = p[0];
    wall.y = p[1];

    if (matchWall != null) {
      wall.nextwall = matchWall[1];
      wall.nextsector = matchWall[0];
    } else {
      wall.nextwall = -1;
      wall.nextsector = -1;
    }

    yield wall;
  }
}

function loopInPolygon(board, loopId, polygon) {
  return Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["all"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopWalls"])(board, loopId), w => Object(_utils__WEBPACK_IMPORTED_MODULE_2__["inPolygon"])(board.walls[w].x, board.walls[w].y, polygon));
}

function checkSplitSector(board, sectorId, points) {
  var [fx, fy] = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["first"])(points);
  var [lx, ly] = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["last"])(points);
  var firstWall = Object(_query__WEBPACK_IMPORTED_MODULE_5__["wallInSector"])(board, sectorId, fx, fy);
  var lastWall = Object(_query__WEBPACK_IMPORTED_MODULE_5__["wallInSector"])(board, sectorId, lx, ly);
  if (firstWall == -1 || lastWall == -1) throw new Error("Terminal points [" + fx + ", " + fy + "], [" + lx + ", " + ly + "] dont touch sector " + sectorId + " walls");
  var start = Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopStart"])(board, firstWall);
  if (start != Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopStart"])(board, lastWall)) throw new Error("Start " + firstWall + " and end " + lastWall + " walls in different loops");
  return [firstWall, lastWall, start];
}

function splitSectorImpl(board, sectorId, firstWall, lastWall, start, points, refs, api) {
  var WALL_MAPPER = w => board.walls[w];

  var refWall = board.walls[firstWall];
  var lengthWoLast = points.length() - 1;
  var [newWalls, existedWalls, loopPoly] = getSplitLoop(board, firstWall, lastWall, points, api.cloneWall);
  var oldSectorBuilder = new _sectorbuilder__WEBPACK_IMPORTED_MODULE_4__["SectorBuilder"]();
  var newSectorBuilder = new _sectorbuilder__WEBPACK_IMPORTED_MODULE_4__["SectorBuilder"]().addWalls(existedWalls).addWalls(createNewWalls(newWalls, [], refWall, board, api.cloneWall)).loop();
  var firstLoopLength = newSectorBuilder.getWalls().length();

  for (var lid of Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopPoints"])(board, sectorId)) {
    if (Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopStart"])(board, lid) == start) continue;else (loopInPolygon(board, lid, loopPoly) ? newSectorBuilder : oldSectorBuilder).addLoop(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["map"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["loopWalls"])(board, lid), WALL_MAPPER));
  }

  var newSectorId = Object(_internal__WEBPACK_IMPORTED_MODULE_6__["addSector"])(board, api.cloneSector(board.sectors[sectorId]));
  newSectorBuilder.build(board, newSectorId, refs);
  var newSector = board.sectors[newSectorId];
  var wallEnd = newSector.wallptr + firstLoopLength - 1;
  var mwalls = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(wallEnd, wallEnd - lengthWoLast)).map(w => [newSectorId, w]).collect();
  var reversedWoLast = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["reversed"])(points)).take(lengthWoLast);
  oldSectorBuilder.addWalls(createNewWalls(reversedWoLast, mwalls, refWall, board, api.cloneWall)).addWalls(Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["wallsBetween"])(board, firstWall, lastWall)).map(w => board.walls[w])).loop(); // const usedWalls = iter(sectorWalls(board, newSectorId)).map(WALL_MAPPER).collect();
  // iter(sectorWalls(board, sectorId))
  //   .filter(w => usedWalls.includes(board.walls[w]))
  //   .forEach(w => board.walls[w] = null);

  oldSectorBuilder.build(board, sectorId, refs);
  return newSectorId;
}

var POINT_MAPPER = w => [w.x, w.y];

function getSplitLoop(board, firstWall, lastWall, points, cloneWall) {
  var newWalls = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(points).butLast().collect();
  var existedWalls = [...Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_loops__WEBPACK_IMPORTED_MODULE_3__["wallsBetween"])(board, lastWall, firstWall)).map(w => cloneWall(board.walls[w]))];
  var loopPoly = Object(_utils_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["map"])(existedWalls, POINT_MAPPER)).chain(newWalls).collect();
  return [newWalls, existedWalls, loopPoly];
}

function checkPointsOrder(board, firstWall, lastWall, points, cloneWall) {
  var [,, loop] = getSplitLoop(board, firstWall, lastWall, points, cloneWall);
  return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["clockwise"])(loop);
}

function splitSector(board, sectorId, points, refs, api) {
  var [firstWall, lastWall, loop] = checkSplitSector(board, sectorId, points);
  if (checkPointsOrder(board, firstWall, lastWall, points, api.cloneWall)) return splitSectorImpl(board, sectorId, firstWall, lastWall, loop, points, refs, api);else return splitSectorImpl(board, sectorId, lastWall, firstWall, loop, Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["wrap"])([...Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["reversed"])(points)]), refs, api);
}

/***/ }),

/***/ "./src/build/board/mutations/sprites.ts":
/*!**********************************************!*\
  !*** ./src/build/board/mutations/sprites.ts ***!
  \**********************************************/
/*! exports provided: moveSprite, moveSpriteX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveSprite", function() { return moveSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveSpriteX", function() { return moveSpriteX; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _distances__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../distances */ "./src/build/board/distances.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");







function moveSprite(board, sprId, x, y, z) {
  var spr = board.sprites[sprId];
  if (spr.x == x && spr.y == y && spr.z == z) return false;
  spr.x = x;
  spr.y = y;
  spr.z = z;
  spr.sectnum = Object(_query__WEBPACK_IMPORTED_MODULE_6__["findSector"])(board, x, y, spr.sectnum);
  return true;
}

function ornamentWall(board, wallId, x, y, grid) {
  var n = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["wallNormal"])(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), board, wallId);
  var [nx, ny] = Object(_query__WEBPACK_IMPORTED_MODULE_6__["snapWall"])(board, wallId, x, y, grid);
  return [Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(nx + n[0] * 4), Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(ny + n[2] * 4)];
}

function selectOrnamentWall(board, sectorId, wallId, x, y, z) {
  var sector = board.sectors[sectorId];
  var wall = board.walls[wallId];

  if (wall.nextwall != -1) {
    var nextSectorId = wall.nextsector;
    var nextSector = board.sectors[nextSectorId];
    var f1z = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, sectorId, x, y, sector.floorheinum) + sector.floorz;
    var c1z = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, sectorId, x, y, sector.ceilingheinum) + sector.ceilingz;
    var f2z = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, nextSectorId, x, y, nextSector.floorheinum) + nextSector.floorz;
    var c2z = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, nextSectorId, x, y, nextSector.ceilingheinum) + nextSector.ceilingz;
    if ((z > f1z || z < c1z) && z <= f2z && z >= c2z) return [wall.nextwall, wall.nextsector];
    if ((z > f2z || z < c2z) && z <= f1z && z >= c1z) return [wallId, sectorId];
    return [-1, -1];
  }

  return [wallId, sectorId];
}

function tryMoveSprite(sprite, x, y, z, sectorId) {
  if (sprite.x == x && sprite.y == y && sprite.z == z && sprite.sectnum == sectorId) return false;
  sprite.x = x;
  sprite.y = y;
  sprite.z = z;
  sprite.sectnum = sectorId;
  return true;
}

function moveSpriteX(board, spriteId, x, y, z, grid) {
  var sprite = board.sprites[spriteId];
  if (sprite.x == x && sprite.y == y && sprite.z == z) return false;
  var tsectorId = Object(_query__WEBPACK_IMPORTED_MODULE_6__["findSector"])(board, x, y, sprite.sectnum);
  var newSectorId = tsectorId == -1 ? sprite.sectnum : tsectorId;
  var d = grid.getGridSize();
  var w = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["findFirst"])(Object(_loops__WEBPACK_IMPORTED_MODULE_5__["sectorWalls"])(board, newSectorId), w => Object(_distances__WEBPACK_IMPORTED_MODULE_4__["distanceToWallSegment"])(board, w, x, y) <= d, -1);

  if (w != -1) {
    var ow = selectOrnamentWall(board, newSectorId, w, x, y, sprite.z);

    if (ow[0] == -1) {
      return tryMoveSprite(sprite, x, y, z, newSectorId);
    } else {
      var [nx, ny] = ornamentWall(board, ow[0], x, y, grid);
      return tryMoveSprite(sprite, nx, ny, z, ow[1]);
    }
  } else {
    if (tsectorId == -1) return false;
    return tryMoveSprite(sprite, x, y, z, newSectorId);
  }
}

/***/ }),

/***/ "./src/build/board/mutations/walls.ts":
/*!********************************************!*\
  !*** ./src/build/board/mutations/walls.ts ***!
  \********************************************/
/*! exports provided: fixxrepeat, splitWall, moveWall, pushWall, deleteWall, mergePoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixxrepeat", function() { return fixxrepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitWall", function() { return splitWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveWall", function() { return moveWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushWall", function() { return pushWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteWall", function() { return deleteWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergePoints", function() { return mergePoints; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./src/build/utils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loops */ "./src/build/board/loops.ts");
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../query */ "./src/build/board/query.ts");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal */ "./src/build/board/mutations/internal.ts");







function fixxrepeat(board, wallId, reprate) {
  if (reprate === void 0) {
    reprate = _internal__WEBPACK_IMPORTED_MODULE_6__["DEFAULT_REPEAT_RATE"];
  }

  var wall = board.walls[wallId];
  wall.xrepeat = Math.min(255, Math.max(1, Math.round((Object(_query__WEBPACK_IMPORTED_MODULE_5__["walllen"])(board, wallId) + 0.5) / reprate)));
}

function fixpoint2xpan(board, wallId, art) {
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  wall2.xpanning = (wall.xpanning + (wall.xrepeat << 3)) % art.getInfo(wall.picnum).w & 0xff;
}

function insertWall(board, wallId, x, y, art, refs, cloneWall) {
  var secId = Object(_query__WEBPACK_IMPORTED_MODULE_5__["sectorOfWall"])(board, wallId);
  var wall = board.walls[wallId];
  var lenperrep = Object(_query__WEBPACK_IMPORTED_MODULE_5__["walllen"])(board, wallId) / Math.max(wall.xrepeat, 1);
  Object(_internal__WEBPACK_IMPORTED_MODULE_6__["moveWalls"])(board, secId, wallId, 1, refs);
  var nwall = cloneWall(wall);
  nwall.x = x;
  nwall.y = y;
  board.walls[wallId + 1] = nwall;
  wall.point2 = wallId + 1;
  fixxrepeat(board, wallId, lenperrep);
  fixpoint2xpan(board, wallId, art);
  fixxrepeat(board, wallId + 1, lenperrep);
}

function splitWall(board, wallId, x, y, art, refs, cloneWall) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_5__["isValidWallId"])(board, wallId)) throw new Error('Invalid wall: ' + wallId);
  var wall = board.walls[wallId];
  insertWall(board, wallId, x, y, art, refs, cloneWall);

  if (wall.nextwall != -1) {
    var nextwallId = wall.nextwall;
    insertWall(board, nextwallId, x, y, art, refs, cloneWall);
    var _wallId = board.walls[nextwallId].nextwall;
    board.walls[_wallId].nextwall = nextwallId + 1;
    board.walls[_wallId + 1].nextwall = nextwallId;
    board.walls[nextwallId].nextwall = _wallId + 1;
    board.walls[nextwallId + 1].nextwall = _wallId;
    return _wallId;
  }

  return wallId;
}

function doMoveWall(board, w, x, y) {
  board.walls[w].x = x;
  board.walls[w].y = y;
  fixxrepeat(board, w);
  fixxrepeat(board, Object(_query__WEBPACK_IMPORTED_MODULE_5__["lastwall"])(board, w));
}

function moveWall(board, wallId, x, y) {
  var wall = board.walls[wallId];
  if (wall.x == x && wall.y == y) return false;
  Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["forEach"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["connectedWalls"])(board, wallId), w => doMoveWall(board, w, x, y));
  return true;
}

var _wallNormal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();

function pushWall(board, wallId, len, art, alwaysNewPoints, refs, api) {
  if (alwaysNewPoints === void 0) {
    alwaysNewPoints = false;
  }

  if (len == 0) return wallId;
  var w1 = wallId;
  var wall1 = board.walls[w1];
  var w2 = wall1.point2;
  var wall2 = board.walls[w2];
  var p1 = Object(_query__WEBPACK_IMPORTED_MODULE_5__["lastwall"])(board, w1);
  var prev1 = board.walls[p1];
  var n2 = wall2.point2;
  var next2 = board.walls[n2];
  var normal = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["wallNormal"])(_wallNormal, board, wallId);
  var [nx, _, ny] = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(normal, normal, len);
  var x1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(wall1.x + nx);
  var y1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(wall1.y + ny);
  var x2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(wall2.x + nx);
  var y2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(wall2.y + ny);

  if (alwaysNewPoints) {
    w1 = splitWall(board, w1, x1, y1, art, refs, api.cloneWall);
    w2 = Object(_query__WEBPACK_IMPORTED_MODULE_5__["nextwall"])(board, w1);
    splitWall(board, w2, x2, y2, art, refs, api.cloneWall);
  }

  var extent1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x1 - prev1.x, y1 - prev1.y, wall1.x - prev1.x, wall1.y - prev1.y) == 0;
  var extent2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x2 - next2.x, y2 - next2.y, wall2.x - next2.x, wall2.y - next2.y) == 0;

  if (extent1 && extent2) {
    moveWall(board, w1, x1, y1);
    moveWall(board, w2, x2, y2);
  } else if (extent1 && !extent2) {
    moveWall(board, w1, x1, y1);
    splitWall(board, w1, x2, y2, art, refs, api.cloneWall);
  } else if (!extent1 && extent2) {
    w1 = splitWall(board, w1, x1, y1, art, refs, api.cloneWall);
    w2 = Object(_query__WEBPACK_IMPORTED_MODULE_5__["nextwall"])(board, Object(_query__WEBPACK_IMPORTED_MODULE_5__["nextwall"])(board, w1));
    moveWall(board, w2, x2, y2);
  } else if (!extent1 && !extent2) {
    w1 = splitWall(board, w1, x1, y1, art, refs, api.cloneWall);
    w2 = Object(_query__WEBPACK_IMPORTED_MODULE_5__["nextwall"])(board, w1);
    splitWall(board, w2, x2, y2, art, refs, api.cloneWall);
  }
}
function deleteWall(board, wallId, refs) {
  if (!Object(_query__WEBPACK_IMPORTED_MODULE_5__["isValidWallId"])(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  if (Object(_query__WEBPACK_IMPORTED_MODULE_5__["isTJunction"])(board, wallId)) throw new Error("Wall " + wallId + " is sector T junction");
  if (Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["length"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["loopWalls"])(board, wallId)) < 4) throw new Error("Loop of Wall " + wallId + " need to have 3 walls at minimum");
  var sectorId = Object(_query__WEBPACK_IMPORTED_MODULE_5__["sectorOfWall"])(board, wallId);
  var wall = board.walls[wallId];

  if (wall.nextsector != -1) {
    if (Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["length"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["loopWalls"])(board, wall.nextwall)) < 4) throw new Error("Loop of Wall " + wall.nextwall + " need to have 3 walls minimum");
    var wall2Id = board.walls[wall.nextwall].point2;
    var lastWallId = Object(_query__WEBPACK_IMPORTED_MODULE_5__["lastwall"])(board, wallId);
    board.walls[lastWallId].nextwall = wall.nextwall;
    board.walls[wall.nextwall].nextwall = lastWallId;
    wall.nextwall = -1;
    wall.nextsector = -1;
    Object(_internal__WEBPACK_IMPORTED_MODULE_6__["moveWalls"])(board, wall.nextsector, wall2Id, -1, refs);
    wallId += wallId > wall2Id ? -1 : 0;
  }

  Object(_internal__WEBPACK_IMPORTED_MODULE_6__["moveWalls"])(board, sectorId, wallId, -1, refs);
}
function mergePoints(board, wallId, refs) {
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  if (wall.x == wall2.x && wall.y == wall2.y) deleteWall(board, wallId, refs);
}

/***/ }),

/***/ "./src/build/board/query.ts":
/*!**********************************!*\
  !*** ./src/build/board/query.ts ***!
  \**********************************/
/*! exports provided: isValidWallId, isValidSectorId, isValidSpriteId, wallInSector, walllen, lastwall, nextwall, isJoinedSectors, isTJunction, findSectorsAtPoint, findContainingSector, findContainingSectorMidPoints, inSector, sectorOfWall, findSector, snapWall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidWallId", function() { return isValidWallId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidSectorId", function() { return isValidSectorId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidSpriteId", function() { return isValidSpriteId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wallInSector", function() { return wallInSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "walllen", function() { return walllen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastwall", function() { return lastwall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextwall", function() { return nextwall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isJoinedSectors", function() { return isJoinedSectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTJunction", function() { return isTJunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findSectorsAtPoint", function() { return findSectorsAtPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findContainingSector", function() { return findContainingSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findContainingSectorMidPoints", function() { return findContainingSectorMidPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inSector", function() { return inSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorOfWall", function() { return sectorOfWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findSector", function() { return findSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snapWall", function() { return snapWall; });
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_interpolator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/interpolator */ "./src/utils/interpolator.ts");
/* harmony import */ var _utils_iter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/iter */ "./src/utils/iter.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _loops__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loops */ "./src/build/board/loops.ts");
/* harmony import */ var _mutations_internal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mutations/internal */ "./src/build/board/mutations/internal.ts");






function isValidWallId(board, wallId) {
  return wallId >= 0 && wallId < board.numwalls;
}
function isValidSectorId(board, sectorId) {
  return sectorId >= 0 && sectorId < board.numsectors;
}
function isValidSpriteId(board, spriteId) {
  return spriteId >= 0 && spriteId < board.numsprites;
}
function wallInSector(board, sectorId, x, y) {
  return Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["findFirst"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["sectorWalls"])(board, sectorId), w => board.walls[w].x == x && board.walls[w].y == y, -1);
}
function walllen(board, wallId) {
  if (!isValidWallId(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  var dx = wall2.x - wall.x;
  var dy = wall2.y - wall.y;
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["len2d"])(dx, dy);
}
function lastwall(board, wallId) {
  if (!isValidWallId(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  if (wallId > 0 && board.walls[wallId - 1].point2 == wallId) return wallId - 1;

  for (var w = wallId;; w = board.walls[w].point2) {
    if (board.walls[w].point2 == wallId) return w;
  }
}
function nextwall(board, wallId) {
  if (!isValidWallId(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  return board.walls[wallId].point2;
}
function isJoinedSectors(board, sectorId1, sectorId2) {
  return Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["sectorWalls"])(board, sectorId1), w => board.walls[w].nextsector == sectorId2);
}
function isTJunction(board, wallId) {
  if (!isValidWallId(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  var wall = board.walls[wallId];
  var lwall = board.walls[lastwall(board, wallId)];
  return wall.nextsector != lwall.nextsector;
}
var NULL_SECTOR_SET = new Set([-1]);
function findSectorsAtPoint(board, x, y) {
  var sectorId = findSector(board, x, y);
  if (sectorId == -1) return NULL_SECTOR_SET;
  var wallId = wallInSector(board, sectorId, x, y);
  if (wallId == -1) return new Set([sectorId]);
  return new Set(Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(Object(_loops__WEBPACK_IMPORTED_MODULE_4__["connectedWalls"])(board, wallId)).map(w => sectorOfWall(board, w)));
}
function findContainingSector(board, points) {
  return Object(_utils_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(points).map(p => findSectorsAtPoint(board, p[0], p[1])).reduce((lh, rh) => {
    return lh == null ? rh : Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["intersect"])(lh, rh);
  }, null);
}

function pointInterpolator(lh, rh, t) {
  return [Object(_utils_interpolator__WEBPACK_IMPORTED_MODULE_1__["NumberInterpolator"])(lh[0], rh[0], t), Object(_utils_interpolator__WEBPACK_IMPORTED_MODULE_1__["NumberInterpolator"])(lh[1], rh[1], t)];
}

function findContainingSectorMidPoints(board, points) {
  var interpolated = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["interpolate"])(points, pointInterpolator);
  return findContainingSector(board, interpolated);
}
function inSector(board, x, y, sectorId) {
  if (sectorId < 0 || sectorId >= board.numsectors) return false;
  x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(x);
  y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(y);
  var inter = 0;

  for (var w of Object(_loops__WEBPACK_IMPORTED_MODULE_4__["sectorWalls"])(board, sectorId)) {
    var wall = board.walls[w];
    var wall2 = board.walls[wall.point2];
    var dy1 = wall.y - y;
    var dy2 = wall2.y - y;
    var dx1 = wall.x - x;
    var dx2 = wall2.x - x;
    if (dx1 == 0 && dx2 == 0 && (dy1 == 0 || dy2 == 0 || (dy1 ^ dy2) < 0)) return true;
    if (dy1 == 0 && dy2 == 0 && (dx1 == 0 || dx2 == 0 || (dx1 ^ dx2) < 0)) return true;

    if ((dy1 ^ dy2) < 0) {
      if ((dx1 ^ dx2) >= 0) inter ^= dx1;else inter ^= Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["cross2d"])(dx1, dy1, dx2, dy2) ^ dy2;
    }
  }

  return inter >>> 31 == 1;
}
function sectorOfWall(board, wallId) {
  if (wallId < 0 || wallId >= board.numwalls) return -1;
  var wall = board.walls[wallId];
  if (wall.nextwall != -1) return board.walls[wall.nextwall].nextsector;
  var start = 0;
  var end = board.numsectors - 1;

  while (end - start >= 0) {
    var pivot = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(start + (end - start) / 2);
    var sec = board.sectors[pivot];
    if (sec.wallptr <= wallId && sec.wallptr + sec.wallnum - 1 >= wallId) return pivot;
    if (sec.wallptr > wallId) end = pivot - 1;else start = pivot + 1;
  }
}
function findSector(board, x, y, sectorId) {
  if (sectorId === void 0) {
    sectorId = -1;
  }

  if (!isValidSectorId(board, sectorId)) return findSectorAll(board, x, y);
  var secs = [sectorId];

  for (var i = 0; i < secs.length; i++) {
    sectorId = secs[i];
    var sec = board.sectors[sectorId];
    if (inSector(board, x, y, sectorId)) return sectorId;

    for (var w = 0; w < sec.wallnum; w++) {
      var wallidx = w + sec.wallptr;
      var wall = board.walls[wallidx];

      if (wall.nextsector != -1) {
        var nextsector = wall.nextsector;
        if (secs.indexOf(nextsector) == -1) secs.push(nextsector);
      }
    }
  }

  return -1;
}

function findSectorAll(board, x, y) {
  return Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["findFirst"])(Object(_utils_collections__WEBPACK_IMPORTED_MODULE_0__["range"])(0, board.numsectors), s => inSector(board, x, y, s), -1);
}

function snapWall(board, wallId, x, y, grid) {
  if (!isValidWallId(board, wallId)) throw new Error("Invalid wallId: " + wallId);
  var wall = board.walls[wallId];
  var w1 = nextwall(board, wallId);
  var wall1 = board.walls[w1];
  var dx = wall1.x - wall.x;
  var dy = wall1.y - wall.y;
  var repeat = _mutations_internal__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_REPEAT_RATE"] * wall.xrepeat;
  var dxt = x - wall.x;
  var dyt = y - wall.y;
  var dt = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["len2d"])(dxt, dyt) / Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["len2d"])(dx, dy);
  var t = grid.snap(dt * repeat) / repeat;
  var xs = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(wall.x + t * dx);
  var ys = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(wall.y + t * dy);
  return [xs, ys];
}

/***/ }),

/***/ "./src/build/board/structs.ts":
/*!************************************!*\
  !*** ./src/build/board/structs.ts ***!
  \************************************/
/*! exports provided: SectorStats, Sector, WallStats, Wall, FACE_SPRITE, WALL_SPRITE, FLOOR_SPRITE, SpriteStats, Sprite, Board, Header1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorStats", function() { return SectorStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sector", function() { return Sector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallStats", function() { return WallStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wall", function() { return Wall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACE_SPRITE", function() { return FACE_SPRITE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WALL_SPRITE", function() { return WALL_SPRITE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOOR_SPRITE", function() { return FLOOR_SPRITE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteStats", function() { return SpriteStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Board", function() { return Board; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Header1", function() { return Header1; });
//  wallptr - index to first wall of sector
//  wallnum - number of walls in sector
//  z's - z coordinate (height) of ceiling / floor at first point of sector
//  stat's
//  bit 0: 1 = parallaxing, 0 = not                                 "P"
//  bit 1: 1 = sloped, 0 = not
//  bit 2: 1 = swap x&y, 0 = not                                    "F"
//  bit 3: 1 = double smooshiness                                   "E"
//  bit 4: 1 = x-flip                                               "F"
//  bit 5: 1 = y-flip                                               "F"
//  bit 6: 1 = Align texture to first wall of sector                "R"
//  bits 7-15: reserved
//  picnum's - texture index into art file
//  heinum's - slope value (rise/run) (0-parallel to floor, 4096-45 degrees)
//  shade's - shade offset of ceiling/floor
//  pal's - palette lookup table number (0 - use standard colors)
//  panning's - used to align textures or to do texture panning
//  visibility - determines how fast an area changes shade relative to distance
//  filler - useless byte to make structure aligned
//  lotag, hitag, extra - These variables used by the game programmer only
class SectorStats {
  constructor() {
    this.parallaxing = void 0;
    this.slopped = void 0;
    this.swapXY = void 0;
    this.doubleSmooshiness = void 0;
    this.xflip = void 0;
    this.yflip = void 0;
    this.alignToFirstWall = void 0;
    this.unk = void 0;
  }

}
class Sector {
  constructor() {
    this.wallptr = void 0;
    this.wallnum = void 0;
    this.ceilingz = void 0;
    this.floorz = void 0;
    this.ceilingstat = void 0;
    this.floorstat = void 0;
    this.ceilingpicnum = void 0;
    this.ceilingheinum = void 0;
    this.ceilingshade = void 0;
    this.ceilingpal = void 0;
    this.ceilingxpanning = void 0;
    this.ceilingypanning = void 0;
    this.floorpicnum = void 0;
    this.floorheinum = void 0;
    this.floorshade = void 0;
    this.floorpal = void 0;
    this.floorxpanning = void 0;
    this.floorypanning = void 0;
    this.visibility = void 0;
    this.filler = void 0;
    this.lotag = void 0;
    this.hitag = void 0;
    this.extra = void 0;
  }

} //  x, y: Coordinate of left side of wall, get right side from next wall's left side
//  point2: Index to next wall on the right (always in the same sector)
//  nextwall: Index to wall on other side of wall (-1 if there is no sector)
//  nextsector: Index to sector on other side of wall (-1 if there is no sector)
//  cstat:
//    bit 0: 1 = Blocking wall (use with clipmove, getzrange)         "B"
//  bit 1: 1 = bottoms of invisible walls swapped, 0 = not          "2"
//  bit 2: 1 = align picture on bottom (for doors), 0 = top         "O"
//  bit 3: 1 = x-flipped, 0 = normal                                "F"
//  bit 4: 1 = masking wall, 0 = not                                "M"
//  bit 5: 1 = 1-way wall, 0 = not                                  "1"
//  bit 6: 1 = Blocking wall (use with hitscan / cliptype 1)        "H"
//  bit 7: 1 = Transluscence, 0 = not                               "T"
//  bit 8: 1 = y-flipped, 0 = normal                                "F"
//  bit 9: 1 = Transluscence reversing, 0 = normal                  "T"
//  bits 10-15: reserved
//  picnum - texture index into art file
//  overpicnum - texture index into art file for masked walls / 1-way walls
//  shade - shade offset of wall
//  pal - palette lookup table number (0 - use standard colors)
//  repeat's - used to change the size of pixels (stretch textures)
//  pannings - used to align textures or to do texture panning
//  lotag, hitag, extra - These variables used by the game programmer only

class WallStats {
  constructor() {
    this.blocking = void 0;
    this.swapBottoms = void 0;
    this.alignBottom = void 0;
    this.xflip = void 0;
    this.masking = void 0;
    this.oneWay = void 0;
    this.blocking2 = void 0;
    this.translucent = void 0;
    this.yflip = void 0;
    this.translucentReversed = void 0;
    this.unk = void 0;
  }

}
class Wall {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.point2 = void 0;
    this.nextwall = void 0;
    this.nextsector = void 0;
    this.cstat = void 0;
    this.picnum = void 0;
    this.overpicnum = void 0;
    this.shade = void 0;
    this.pal = void 0;
    this.xrepeat = void 0;
    this.yrepeat = void 0;
    this.xpanning = void 0;
    this.ypanning = void 0;
    this.lotag = void 0;
    this.hitag = void 0;
    this.extra = void 0;
  }

} //  x, y, z - position of sprite - can be defined at center bottom or center
//  cstat:
//    bit 0: 1 = Blocking sprite (use with clipmove, getzrange)       "B"
//  bit 1: 1 = transluscence, 0 = normal                            "T"
//  bit 2: 1 = x-flipped, 0 = normal                                "F"
//  bit 3: 1 = y-flipped, 0 = normal                                "F"
//  bits 5-4: 00 = FACE sprite (default)                            "R"
//  01 = WALL sprite (like masked walls)
//  10 = FLOOR sprite (parallel to ceilings&floors)
//  bit 6: 1 = 1-sided sprite, 0 = normal                           "1"
//  bit 7: 1 = Real centered centering, 0 = foot center             "C"
//  bit 8: 1 = Blocking sprite (use with hitscan / cliptype 1)      "H"
//  bit 9: 1 = Transluscence reversing, 0 = normal                  "T"
//  bits 10-14: reserved
//  bit 15: 1 = Invisible sprite, 0 = not invisible
//  picnum - texture index into art file
//  shade - shade offset of sprite
//  pal - palette lookup table number (0 - use standard colors)
//  clipdist - the size of the movement clipping square (face sprites only)
//  filler - useless byte to make structure aligned
//  repeat's - used to change the size of pixels (stretch textures)
//  offset's - used to center the animation of sprites
//  sectnum - current sector of sprite
//  statnum - current status of sprite (inactive/monster/bullet, etc.)
//
//  ang - angle the sprite is facing
//  owner, xvel, yvel, zvel, lotag, hitag, extra - These variables used by the
//  game programmer only

var FACE_SPRITE = 0;
var WALL_SPRITE = 1;
var FLOOR_SPRITE = 2;
class SpriteStats {
  constructor() {
    this.blocking = void 0;
    this.translucent = void 0;
    this.xflip = void 0;
    this.yflip = void 0;
    this.type = void 0;
    this.onesided = void 0;
    this.realCenter = void 0;
    this.blocking2 = void 0;
    this.tranclucentReversed = void 0;
    this.noautoshading = void 0;
    this.reserved = void 0;
    this.invisible = void 0;
    this.unk = void 0;
  }

}
class Sprite {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.cstat = void 0;
    this.picnum = void 0;
    this.shade = void 0;
    this.pal = void 0;
    this.clipdist = void 0;
    this.filler = void 0;
    this.xrepeat = void 0;
    this.yrepeat = void 0;
    this.xoffset = void 0;
    this.yoffset = void 0;
    this.sectnum = void 0;
    this.statnum = void 0;
    this.ang = void 0;
    this.owner = void 0;
    this.xvel = void 0;
    this.yvel = void 0;
    this.zvel = void 0;
    this.lotag = void 0;
    this.hitag = void 0;
    this.extra = void 0;
  }

}
class Board {
  constructor() {
    this.version = void 0;
    this.posx = void 0;
    this.posy = void 0;
    this.posz = void 0;
    this.ang = void 0;
    this.cursectnum = void 0;
    this.numsectors = void 0;
    this.sectors = void 0;
    this.numwalls = void 0;
    this.walls = void 0;
    this.numsprites = void 0;
    this.sprites = void 0;
  }

}
class Header1 {
  constructor() {
    this.startX = void 0;
    this.startY = void 0;
    this.startZ = void 0;
    this.startAng = void 0;
    this.startSec = void 0;
    this.unk = void 0;
  }

}

/***/ }),

/***/ "./src/build/boardvisitor.ts":
/*!***********************************!*\
  !*** ./src/build/boardvisitor.ts ***!
  \***********************************/
/*! exports provided: packWallSectorId, unpackWallId, unpackSectorId, SectorCollector, createSectorCollector, WallCollector, createWallCollector, SpriteCollector, createSpriteCollector, AllBoardVisitorResult, TopDownBoardVisitorResult, PvsBoardVisitorResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "packWallSectorId", function() { return packWallSectorId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpackWallId", function() { return unpackWallId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpackSectorId", function() { return unpackSectorId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectorCollector", function() { return SectorCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSectorCollector", function() { return createSectorCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WallCollector", function() { return WallCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createWallCollector", function() { return createWallCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteCollector", function() { return SpriteCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSpriteCollector", function() { return createSpriteCollector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AllBoardVisitorResult", function() { return AllBoardVisitorResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TopDownBoardVisitorResult", function() { return TopDownBoardVisitorResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PvsBoardVisitorResult", function() { return PvsBoardVisitorResult; });
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_profiler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/profiler */ "./src/utils/profiler.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/build/utils.ts");
/* harmony import */ var _board_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./board/query */ "./src/build/board/query.ts");





function packWallSectorId(wallId, sectorId) {
  return wallId | sectorId << 16;
}
function unpackWallId(wallSectorId) {
  return wallSectorId & 0xffff;
}
function unpackSectorId(wallSectorId) {
  return wallSectorId >> 16 & 0xffff;
}
class SectorCollector {
  constructor(pred) {
    this.visitor = void 0;
    this.sectors = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();

    this.visitor = (ctx, sectorId) => {
      if (pred(ctx, sectorId)) this.sectors.push(sectorId);
    };
  }

  visit() {
    this.sectors.clear();
    return this.visitor;
  }

}
function createSectorCollector(pred) {
  return new SectorCollector(pred);
}
class WallCollector {
  constructor(pred) {
    this.visitor = void 0;
    this.walls = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();

    this.visitor = (ctx, wallId, sectorId) => {
      if (pred(ctx, wallId, sectorId)) this.walls.push(packWallSectorId(wallId, sectorId));
    };
  }

  visit() {
    this.walls.clear();
    return this.visitor;
  }

}
function createWallCollector(pred) {
  return new WallCollector(pred);
}
class SpriteCollector {
  constructor(pred) {
    this.visitor = void 0;
    this.sprites = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();

    this.visitor = (ctx, spriteId) => {
      if (pred(ctx, spriteId)) this.sprites.push(spriteId);
    };
  }

  visit() {
    this.sprites.clear();
    return this.visitor;
  }

}
function createSpriteCollector(pred) {
  return new SpriteCollector(pred);
}
class AllBoardVisitorResult {
  constructor() {
    this.board = void 0;
  }

  visit(board) {
    this.board = board;
    return this;
  }

  forSector(ctx, secv) {
    for (var s = 0; s < this.board.numsectors; s++) {
      secv(ctx, s);
    }
  }

  forWall(ctx, wallv) {
    for (var s = 0; s < this.board.numsectors; s++) {
      var sec = this.board.sectors[s];
      var endwall = sec.wallptr + sec.wallnum;

      for (var w = sec.wallptr; w < endwall; w++) {
        wallv(ctx, w, s);
      }
    }
  }

  forSprite(ctx, sprv) {
    for (var s = 0; s < this.board.numsprites; s++) {
      sprv(ctx, s);
    }
  }

}
class TopDownBoardVisitorResult {
  constructor() {
    this.board = void 0;
    this.cx = void 0;
    this.cy = void 0;
    this.dist = void 0;
    this.visibleSectors = new Set();
  }

  visit(board, campos, dist) {
    this.board = board;
    this.cx = campos[0];
    this.cy = campos[2];
    this.dist = dist;
    this.prescan();
    return this;
  }

  prescan() {
    this.visibleSectors.clear();

    for (var s = 0; s < this.board.numsectors; s++) {
      if (Object(_board_query__WEBPACK_IMPORTED_MODULE_4__["inSector"])(this.board, this.cx, this.cy, s)) {
        this.visibleSectors.add(s);
        continue;
      }

      var sec = this.board.sectors[s];
      var end = sec.wallptr + sec.wallnum;

      for (var w = sec.wallptr; w < end; w++) {
        var wall = this.board.walls[w];

        if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["len2d"])(this.cx - wall.x, this.cy - wall.y) < this.dist) {
          this.visibleSectors.add(s);
          break;
        }
      }
    }
  }

  forSector(ctx, secv) {
    for (var s of this.visibleSectors.keys()) {
      secv(ctx, s);
    }
  }

  forWall(ctx, wallv) {
    for (var s of this.visibleSectors.keys()) {
      var sec = this.board.sectors[s];
      var end = sec.wallptr + sec.wallnum;

      for (var w = sec.wallptr; w < end; w++) {
        var wall = this.board.walls[w];

        if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["len2d"])(this.cx - wall.x, this.cy - wall.y) < this.dist) {
          wallv(ctx, w, s);
        }
      }
    }
  }

  forSprite(ctx, sprv) {
    for (var s = 0; s < this.board.numsprites; s++) {
      var spr = this.board.sprites[s];
      if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["len2d"])(this.cx - spr.x, this.cy - spr.y) < this.dist) sprv(ctx, s);
    }
  }

}

function wallBehind(board, wallId, ms, fwd) {
  // return false;
  var wall1 = board.walls[wallId];
  var wall2 = board.walls[wall1.point2];
  var dx1 = wall1.x - ms.x;
  var dy1 = wall1.y - ms.y;
  var dx2 = wall2.x - ms.x;
  var dy2 = wall2.y - ms.y;
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["dot2d"])(dx1, dy1, fwd[0], fwd[2]) < 0 && Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["dot2d"])(dx2, dy2, fwd[0], fwd[2]) < 0;
}

class PvsBoardVisitorResult {
  constructor() {
    this.sectors = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.walls = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.sprites = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.prepvs = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["IndexedDeck"]();
    this.pvs = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["IndexedDeck"]();
    this.entryWalls = new Map();
    this.angCache = new Map();
    this.board = void 0;
  }

  init(board, sectorId) {
    this.board = board;
    this.sectors.clear();
    this.walls.clear();
    this.sprites.clear();
    this.prepvs.clear();
    this.prepvs.push(sectorId);
    this.pvs.clear();
    this.pvs.push(sectorId);
    this.angCache.clear();
    this.entryWalls.clear();
  }

  ensureEntryWalls(sectorId) {
    var ewalls = this.entryWalls.get(sectorId);

    if (ewalls == undefined) {
      ewalls = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
      this.entryWalls.set(sectorId, ewalls);
    }

    return ewalls;
  }

  fillPVS(ms, fwd) {
    for (var i = 0; i < this.prepvs.length(); i++) {
      var s = this.prepvs.get(i);
      var sec = this.board.sectors[s];
      if (sec == undefined) continue;
      var endwall = sec.wallptr + sec.wallnum;

      for (var w = sec.wallptr; w < endwall; w++) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_3__["wallVisible"](this.board, w, ms) || wallBehind(this.board, w, ms, fwd)) continue;
        var wall = this.board.walls[w];
        var nextsector = wall.nextsector;
        if (nextsector == -1) continue;
        var _nextwall = wall.nextwall;

        if (this.prepvs.indexOf(nextsector) == -1) {
          this.prepvs.push(nextsector);
          this.ensureEntryWalls(nextsector).clear().push(_nextwall);
        } else {
          this.ensureEntryWalls(nextsector).push(_nextwall);
        }
      }
    }
  }

  getAngForWall(wallId, ms) {
    var ang = this.angCache.get(wallId);

    if (ang == undefined) {
      var wall = this.board.walls[wallId];
      var dx = wall.x - ms.x;
      var dy = wall.y - ms.y;
      ang = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["monoatan2"])(dy, dx);
      this.angCache.set(wallId, ang);
    }

    return ang;
  }

  visibleFromEntryWalls(wallId, entryWalls, ms) {
    return true;
    if (entryWalls.length() == 0) return true;

    for (var i = 0; i < entryWalls.length(); i++) {
      var ew = entryWalls.get(i);
      var a1s = this.getAngForWall(Object(_board_query__WEBPACK_IMPORTED_MODULE_4__["nextwall"])(this.board, ew), ms);
      var a1e = this.getAngForWall(ew, ms);
      var a2s = this.getAngForWall(wallId, ms);
      var a2e = this.getAngForWall(Object(_board_query__WEBPACK_IMPORTED_MODULE_4__["nextwall"])(this.board, wallId), ms);
      if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["arcsIntersects"])(a1s, a1e, a2s, a2e)) return true;
    }

    return false;
  }

  visit(board, ms, fwd) {
    this.init(board, ms.sec); // this.fillPVS(ms, fwd);

    _utils_profiler__WEBPACK_IMPORTED_MODULE_2__["get"](null).inc('pvs', this.prepvs.length());
    var sectors = board.sectors;
    var sec2spr = _utils__WEBPACK_IMPORTED_MODULE_3__["groupSprites"](board);

    for (var i = 0; i < this.pvs.length(); i++) {
      var s = this.pvs.get(i);
      var entryWalls = this.ensureEntryWalls(s);
      var sec = sectors[s];
      if (sec == undefined) continue;
      this.sectors.push(s);
      var endwall = sec.wallptr + sec.wallnum;

      for (var w = sec.wallptr; w < endwall; w++) {
        if (!_utils__WEBPACK_IMPORTED_MODULE_3__["wallVisible"](board, w, ms) || wallBehind(board, w, ms, fwd) || !this.visibleFromEntryWalls(w, entryWalls, ms)) continue;
        this.walls.push(packWallSectorId(w, s));
        var wall = board.walls[w];
        var nextsector = wall.nextsector;
        if (nextsector == -1) continue;

        if (this.pvs.indexOf(nextsector) == -1) {
          this.pvs.push(nextsector);
        }
      }

      var sprs = sec2spr[s];

      if (sprs != undefined) {
        for (var _i = 0; _i < sprs.length; _i++) {
          this.sprites.push(sprs[_i]);
        }
      }
    }

    _utils_profiler__WEBPACK_IMPORTED_MODULE_2__["get"](null).inc('pvs', this.pvs.length());
    return this;
  }

  forSector(ctx, secv) {
    for (var i = 0; i < this.sectors.length(); i++) {
      secv(ctx, this.sectors.get(i));
    }
  }

  forWall(ctx, wallv) {
    for (var i = 0; i < this.walls.length(); i++) {
      var id = this.walls.get(i);
      wallv(ctx, unpackWallId(id), unpackSectorId(id));
    }
  }

  forSprite(ctx, sprv) {
    for (var i = 0; i < this.sprites.length(); i++) {
      sprv(ctx, this.sprites.get(i));
    }
  }

}

/***/ }),

/***/ "./src/build/formats/art.ts":
/*!**********************************!*\
  !*** ./src/build/formats/art.ts ***!
  \**********************************/
/*! exports provided: ArtInfo, NO_ANIMATION, ANIMATE_FORWARD, OSCILLATING_ANIMATION, ANIMATE_BACKWARD, Attributes, animate, ArtFile, ArtFiles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtInfo", function() { return ArtInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_ANIMATION", function() { return NO_ANIMATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANIMATE_FORWARD", function() { return ANIMATE_FORWARD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OSCILLATING_ANIMATION", function() { return OSCILLATING_ANIMATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANIMATE_BACKWARD", function() { return ANIMATE_BACKWARD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Attributes", function() { return Attributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animate", function() { return animate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtFile", function() { return ArtFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArtFiles", function() { return ArtFiles; });
/* harmony import */ var _utils_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/stream */ "./src/utils/stream.ts");

class ArtInfo {
  constructor(w, h, attrs, img) {
    this.w = w;
    this.h = h;
    this.attrs = attrs;
    this.img = img;
  }

}
var NO_ANIMATION = 0;
var ANIMATE_FORWARD = 2;
var OSCILLATING_ANIMATION = 1;
var ANIMATE_BACKWARD = 3;
class Attributes {
  constructor() {
    this.frames = 0;
    this.type = NO_ANIMATION;
    this.xoff = 0;
    this.yoff = 0;
    this.speed = 0;
    this.unk = 0;
  }

}
function animate(frame, info) {
  var max = info.attrs.frames + 1;
  if (info.attrs.type == NO_ANIMATION) return 0;else if (info.attrs.type == OSCILLATING_ANIMATION) {
    var x = frame % (max * 2 - 2);
    return x >= max ? max * 2 - 2 - x : x;
  } else if (info.attrs.type == ANIMATE_FORWARD) return frame % max;else if (info.attrs.type == ANIMATE_BACKWARD) return max - frame % max;
}
var anumStruct = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(Attributes).field('frames', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(6)).field('type', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(2)).field('xoff', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('yoff', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('speed', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(4)).field('unk', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(4));
class ArtFile {
  constructor(stream) {
    this.offsets = void 0;
    this.ws = void 0;
    this.hs = void 0;
    this.anums = void 0;
    this.start = void 0;
    this.end = void 0;
    this.size = void 0;
    this.stream = stream;
    var version = stream.readUInt();
    var numtiles = stream.readUInt();
    var start = stream.readUInt();
    var end = stream.readUInt();
    var size = end - start + 1;
    var hs = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"], size).read(stream);
    var ws = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"], size).read(stream);
    var anums = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(anumStruct, size).read(stream);
    var offsets = new Array(size);
    var offset = stream.mark();

    for (var i = 0; i < size; i++) {
      offsets[i] = offset;
      offset += ws[i] * hs[i];
    }

    this.offsets = offsets;
    this.ws = ws;
    this.hs = hs;
    this.anums = anums;
    this.start = start;
    this.end = end;
    this.size = size;
  }

  getInfo(id) {
    var offset = this.offsets[id];
    this.stream.setOffset(offset);
    var w = this.ws[id];
    var h = this.hs[id];
    var anum = this.anums[id];
    var pixels = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["atomic_array"])(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"], w * h).read(this.stream);
    return new ArtInfo(h, w, anum, pixels);
  }

  getStart() {
    return this.start;
  }

  getEnd() {
    return this.end;
  }

}
class ArtFiles {
  constructor(arts) {
    this.arts = arts;
  }

  getArt(id) {
    for (var i in this.arts) {
      var art = this.arts[i];
      if (id >= art.getStart() && id <= art.getEnd()) return art;
    }

    return null;
  }

  getInfo(id) {
    var art = this.getArt(id);
    if (art == null) return null;
    return art.getInfo(id - art.getStart());
  }

}

/***/ }),

/***/ "./src/build/formats/grp.ts":
/*!**********************************!*\
  !*** ./src/build/formats/grp.ts ***!
  \**********************************/
/*! exports provided: GrpFile, create, createPalette, loadShadeTables, loadPlus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GrpFile", function() { return GrpFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPalette", function() { return createPalette; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadShadeTables", function() { return loadShadeTables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadPlus", function() { return loadPlus; });
/* harmony import */ var _utils_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/stream */ "./src/utils/stream.ts");

class GrpFile {
  constructor(buf) {
    this.data = void 0;
    this.count = void 0;
    this.files = {};
    this.sizes = {};
    this.data = new _utils_stream__WEBPACK_IMPORTED_MODULE_0__["Stream"](buf, true);
    this.loadFiles();
  }

  loadFiles() {
    var d = this.data;
    d.setOffset(12);
    this.count = d.readUInt();
    var offset = this.count * 16 + 16;

    for (var i = 0; i < this.count; i++) {
      var fname = d.readByteString(12);
      var size = d.readUInt();
      this.files[fname.toLowerCase()] = offset;
      this.sizes[fname.toLowerCase()] = size;
      offset += size;
    }
  }

  get(fname) {
    var off = this.files[fname.toLowerCase()];
    if (off == undefined) return null;
    this.data.setOffset(off);
    return this.data.subView();
  }

  getArrayBuffer(fname) {
    var stream = this.get(fname);
    if (stream == null) return null;
    return stream.readArrayBuffer(this.sizes[fname.toLowerCase()]);
  }

}
function create(buf) {
  return new GrpFile(buf);
}
function createPalette(stream) {
  var pal = new Uint8Array(768);

  for (var i = 0; i < 256; i++) {
    pal[i * 3 + 0] = stream.readUByte() * 4;
    pal[i * 3 + 1] = stream.readUByte() * 4;
    pal[i * 3 + 2] = stream.readUByte() * 4;
  }

  return pal;
}
function loadShadeTables(stream) {
  stream.skip(0x300);
  var size = stream.readUShort();
  var table = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["atomic_array"])(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"], 256);
  var result = [];

  for (var i = 0; i < size; i++) {
    result.push(table.read(stream));
  }

  return result;
}
function loadPlus(stream) {
  var size = stream.readUByte();
  var table = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["atomic_array"])(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"], 256);
  var plus = [];
  var refPlu = new Uint8Array(256);

  for (var i = 0; i < 256; i++) {
    refPlu[i] = i;
  }

  plus[0] = refPlu;

  for (var _i = 0; _i < size; _i++) {
    var idx = stream.readUByte();
    var plu = table.read(stream);
    plus[idx] = plu;
  }

  return plus;
}

/***/ }),

/***/ "./src/build/hitscan.ts":
/*!******************************!*\
  !*** ./src/build/hitscan.ts ***!
  \******************************/
/*! exports provided: EntityType, Entity, isSector, isWall, isSprite, Ray, pointOnRay, Hitscan, hitscan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityType", function() { return EntityType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return Entity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSector", function() { return isSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWall", function() { return isWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSprite", function() { return isSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointOnRay", function() { return pointOnRay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hitscan", function() { return Hitscan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hitscan", function() { return hitscan; });
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _board_structs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/build/utils.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _board_query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./board/query */ "./src/build/board/query.ts");






var EntityType;

(function (EntityType) {
  EntityType[EntityType["FLOOR"] = 0] = "FLOOR";
  EntityType[EntityType["CEILING"] = 1] = "CEILING";
  EntityType[EntityType["UPPER_WALL"] = 2] = "UPPER_WALL";
  EntityType[EntityType["MID_WALL"] = 3] = "MID_WALL";
  EntityType[EntityType["LOWER_WALL"] = 4] = "LOWER_WALL";
  EntityType[EntityType["SPRITE"] = 5] = "SPRITE";
  EntityType[EntityType["WALL_POINT"] = 6] = "WALL_POINT";
})(EntityType || (EntityType = {}));

class Entity {
  constructor(id, type) {
    this.id = id;
    this.type = type;
  }

  isWall() {
    return isWall(this.type);
  }

  isSector() {
    return isSector(this.type);
  }

  isSprite() {
    return isSprite(this.type);
  }

  clone() {
    return new Entity(this.id, this.type);
  }

}
function isSector(type) {
  switch (type) {
    case EntityType.FLOOR:
    case EntityType.CEILING:
      return true;

    default:
      return false;
  }
}
function isWall(type) {
  switch (type) {
    case EntityType.LOWER_WALL:
    case EntityType.MID_WALL:
    case EntityType.UPPER_WALL:
    case EntityType.WALL_POINT:
      return true;

    default:
      return false;
  }
}
function isSprite(type) {
  return type == EntityType.SPRITE;
}
class Ray {
  constructor() {
    this.start = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
    this.dir = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
  }

}
var SPRITE_OFF = 0.1;
function pointOnRay(out, ray, t) {
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].copy(out, ray.dir);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].scale(out, out, t);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(out, out, ray.start);
  return out;
}
class Hitscan {
  constructor(t, ent, ray, targetPoint) {
    if (t === void 0) {
      t = -1;
    }

    if (ent === void 0) {
      ent = null;
    }

    if (ray === void 0) {
      ray = new Ray();
    }

    if (targetPoint === void 0) {
      targetPoint = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
    }

    this.t = t;
    this.ent = ent;
    this.ray = ray;
    this.targetPoint = targetPoint;
  }

  reset(xs, ys, zs, vx, vy, vz) {
    this.ent = null;
    this.t = -1;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(this.ray.start, xs, ys, zs);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(this.ray.dir, vx, vy, vz);
  }

  testHit(t) {
    if (this.t == -1 || this.t >= t) {
      this.t = t;
      return true;
    }

    return false;
  }

  hit(t, id, type) {
    if (this.testHit(t)) {
      this.ent = new Entity(id, type);
    }
  }

  target() {
    return this.t == -1 ? _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].copy(this.targetPoint, this.ray.start) : pointOnRay(this.targetPoint, this.ray, this.t);
  }

  get coords() {
    return this.target();
  }

  get entity() {
    return this.ent;
  }

}
var hitPoint = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();

function hitSector(board, secId, t, hit, type) {
  pointOnRay(hitPoint, hit.ray, t);
  var x = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(hitPoint[0]);
  var y = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(hitPoint[1]);
  if (Object(_board_query__WEBPACK_IMPORTED_MODULE_5__["inSector"])(board, x, y, secId)) hit.hit(t, secId, type);
}

function intersectSectorPlanes(board, sec, secId, hit) {
  var wall1 = board.walls[sec.wallptr];
  var wall2 = board.walls[wall1.point2];
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var dl = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["len2d"])(dx, dy);
  if (dl == 0) return;
  var ndx = dx / dl;
  var ndy = dy / dl;
  var angk = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["cross2d"])(ndx, ndy, hit.ray.dir[0], hit.ray.dir[1]);
  var ceilk = sec.ceilingheinum * _utils__WEBPACK_IMPORTED_MODULE_3__["ANGSCALE"] * angk;
  var dk = hit.ray.dir[2] / _utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"] - ceilk;

  if (dk > 0) {
    var ceilz = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, secId, hit.ray.start[0], hit.ray.start[1], sec.ceilingheinum) + sec.ceilingz;
    var ceildz = (ceilz - hit.ray.start[2]) / _utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"];
    var t = ceildz / dk;
    hitSector(board, secId, t, hit, EntityType.CEILING);
  }

  var floork = sec.floorheinum * _utils__WEBPACK_IMPORTED_MODULE_3__["ANGSCALE"] * angk;
  var dk1 = floork - hit.ray.dir[2] / _utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"];

  if (dk1 > 0) {
    var floorz = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, secId, hit.ray.start[0], hit.ray.start[1], sec.floorheinum) + sec.floorz;
    var floordz = (hit.ray.start[2] - floorz) / _utils__WEBPACK_IMPORTED_MODULE_3__["ZSCALE"];

    var _t = floordz / dk1;

    hitSector(board, secId, _t, hit, EntityType.FLOOR);
  }
}

function intersectWall(board, wallId, hit) {
  var wall = board.walls[wallId];
  var wall2 = board.walls[wall.point2];
  var x1 = wall.x,
      y1 = wall.y;
  var x2 = wall2.x,
      y2 = wall2.y;
  var [xs, ys, zs] = hit.ray.start;
  var [vx, vy, vz] = hit.ray.dir;
  if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["cross2d"])(x1 - xs, y1 - ys, x2 - xs, y2 - ys) <= 0) return -1;
  var intersect = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rayIntersect"])(xs, ys, zs, vx, vy, vz, x1, y1, x2, y2);
  if (intersect == null) return -1;
  var [ix, iy, iz, it] = intersect;
  var nextsecId = wall.nextsector;

  if (nextsecId == -1) {
    hit.hit(it, wallId, EntityType.MID_WALL);
    return -1;
  }

  var nextsec = board.sectors[nextsecId];
  var floorz = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, nextsecId, ix, iy, nextsec.floorheinum) + nextsec.floorz;
  var ceilz = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["slope"])(board, nextsecId, ix, iy, nextsec.ceilingheinum) + nextsec.ceilingz;

  if (iz <= ceilz) {
    hit.hit(it, wallId, EntityType.UPPER_WALL);
    return -1;
  } else if (iz >= floorz) {
    hit.hit(it, wallId, EntityType.LOWER_WALL);
    return -1;
  } else if (wall.cstat.masking) {
    hit.hit(it, wallId, EntityType.MID_WALL);
    return -1;
  }

  return nextsecId;
}

function intersectFaceSprite(board, info, sprId, hit) {
  var [xs, ys, zs] = hit.ray.start;
  var [vx, vy, vz] = hit.ray.dir;
  if (vx == 0 && vy == 0) return;
  var spr = board.sprites[sprId];
  var x = spr.x,
      y = spr.y,
      z = spr.z;
  var dx = x - xs;
  var dy = y - ys;
  var vl = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["sqrLen2d"])(vx, vy);
  var t = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["dot2d"])(vx, vy, dx, dy) / vl;
  if (t <= 0) return;
  var intz = zs + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(vz * t);
  var h = info.h * (spr.yrepeat << 2);
  z += spr.cstat.realCenter ? h >> 1 : 0;
  z -= info.attrs.yoff * (spr.yrepeat << 2);
  if (intz > z || intz < z - h) return;
  var intx = xs + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(vx * t);
  var inty = ys + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(vy * t);
  var w = info.w * (spr.xrepeat >> 2);
  if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["len2d"])(x - intx, y - inty) > w >> 1) return;
  hit.hit(t, sprId, EntityType.SPRITE);
}

function intersectWallSprite(board, info, sprId, hit) {
  var [xs, ys, zs] = hit.ray.start;
  var [vx, vy, vz] = hit.ray.dir;
  if (vx == 0 && vy == 0) return;
  var spr = board.sprites[sprId];
  var x = spr.x,
      y = spr.y,
      z = spr.z;
  var ang = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["spriteAngle"])(spr.ang);
  var dx = Math.sin(ang) * (spr.xrepeat >> 2);
  var dy = Math.cos(ang) * (spr.xrepeat >> 2);
  var w = info.w;
  var xoff = info.attrs.xoff + spr.xoffset;
  if (spr.cstat.xflip) xoff = -xoff;
  var hw = (w >> 1) + xoff;
  var x1 = x - dx * hw;
  var y1 = y - dy * hw;
  var x2 = x1 + dx * w;
  var y2 = y1 + dy * w;
  if (spr.cstat.onesided && Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["cross2d"])(x1 - xs, y1 - ys, x2 - xs, y2 - ys) > 0) return;
  var intersect = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["rayIntersect"])(xs, ys, zs, vx, vy, vz, x1, y1, x2, y2);
  if (intersect == null) return;
  var [,, iz, it] = intersect;
  var h = info.h * (spr.yrepeat << 2);
  z += spr.cstat.realCenter ? h >> 1 : 0;
  z -= info.attrs.yoff * (spr.yrepeat << 2);
  if (iz > z || iz < z - h) return;
  hit.hit(it - SPRITE_OFF, sprId, EntityType.SPRITE);
}

var points_ = Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["wrap"])([[0, 0], [0, 0], [0, 0], [0, 0]]);

function points(x1, y1, x2, y2, x3, y3, x4, y4) {
  points_.get(0)[0] = x1;
  points_.get(0)[1] = y1;
  points_.get(1)[0] = x2;
  points_.get(1)[1] = y2;
  points_.get(2)[0] = x3;
  points_.get(2)[1] = y3;
  points_.get(3)[0] = x4;
  points_.get(3)[1] = y4;
  return points_;
}

function intersectFloorSprite(board, info, sprId, hit) {
  var [xs, ys, zs] = hit.ray.start;
  var [vx, vy, vz] = hit.ray.dir;
  if (vz == 0) return;
  var spr = board.sprites[sprId];
  var x = spr.x,
      y = spr.y,
      z = spr.z;
  var dz = z - zs;
  if (Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["sign"])(dz) != Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["sign"])(vz)) return;
  if (spr.cstat.onesided && spr.cstat.yflip == 1 == zs < z) return;
  var xoff = 0; //(info.attrs.xoff + spr.xoffset) * (spr.cstat.xflip ? -1 : 1);

  var yoff = 0; //(info.attrs.yoff + spr.yoffset) * (spr.cstat.yflip ? -1 : 1);

  var ang = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["spriteAngle"])(spr.ang);
  var cosang = Math.cos(ang);
  var sinang = Math.sin(ang);
  var dx = ((info.w >> 1) + xoff) * (spr.xrepeat >> 2);
  var dy = ((info.h >> 1) + yoff) * (spr.yrepeat >> 2);
  var dw = info.w * (spr.xrepeat >> 2);
  var dh = info.h * (spr.yrepeat >> 2);
  var x1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(x + sinang * dx + cosang * dy);
  var y1 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(y + sinang * dy - cosang * dx);
  var x2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(x1 - sinang * dw);
  var y2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(y1 + cosang * dw);
  var x3 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(x2 - cosang * dh);
  var y3 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(y2 - sinang * dh);
  var x4 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(x1 - cosang * dh);
  var y4 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(y1 - sinang * dh);
  var t = dz / vz;
  var ix = xs + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(vx * t);
  var iy = ys + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(vy * t);
  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["inPolygon"])(ix, iy, points(x1, y1, x2, y2, x3, y3, x4, y4))) return;
  hit.hit(t - SPRITE_OFF, sprId, EntityType.SPRITE);
}

function intersectSprite(board, artInfo, sprId, hit) {
  var spr = board.sprites[sprId];
  if (spr.picnum == 0 || spr.cstat.invisible) return;
  var info = artInfo.getInfo(spr.picnum);

  if (spr.cstat.type == _board_structs__WEBPACK_IMPORTED_MODULE_2__["FACE_SPRITE"]) {
    intersectFaceSprite(board, info, sprId, hit);
  } else if (spr.cstat.type == _board_structs__WEBPACK_IMPORTED_MODULE_2__["WALL_SPRITE"]) {
    intersectWallSprite(board, info, sprId, hit);
  } else if (spr.cstat.type == _board_structs__WEBPACK_IMPORTED_MODULE_2__["FLOOR_SPRITE"]) {
    intersectFloorSprite(board, info, sprId, hit);
  }
}

function resetStack(board, sectorId, stack) {
  stack.clear();
  if (sectorId == -1 || !board.sectors[sectorId]) for (var i of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["range"])(0, board.numsectors)) {
    stack.push(i);
  } else stack.push(sectorId);
}

var stack = new _utils_collections__WEBPACK_IMPORTED_MODULE_1__["IndexedDeck"]();
function hitscan(board, artInfo, xs, ys, zs, secId, vx, vy, vz, hit, cliptype) {
  hit.reset(xs, ys, zs, vx, vy, vz);
  resetStack(board, secId, stack);
  var sprites = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["groupSprites"])(board);

  for (var i = 0; i < stack.length(); i++) {
    var s = stack.get(i);
    var sec = board.sectors[s];
    intersectSectorPlanes(board, sec, s, hit);
    var endwall = sec.wallptr + sec.wallnum;

    for (var w = sec.wallptr; w < endwall; w++) {
      var nextsec = intersectWall(board, w, hit);

      if (nextsec != -1 && stack.indexOf(nextsec) == -1) {
        stack.push(nextsec);
      }
    }

    if (cliptype == 1) continue;
    var sprs = sprites[s];
    if (sprs == undefined) continue;

    for (var j = 0; j < sprs.length; j++) {
      intersectSprite(board, artInfo, sprs[j], hit);
    }
  }
}

/***/ }),

/***/ "./src/build/maploader.ts":
/*!********************************!*\
  !*** ./src/build/maploader.ts ***!
  \********************************/
/*! exports provided: sectorStruct, wallStruct, spriteStruct, boardStruct, loadBuildMap, saveBuildMap, initWallStats, initWall, newWall, initSectorStats, initSector, newSector, initSpriteStats, initSprite, newSprite, newBoard, cloneSector, cloneWall, cloneSprite, cloneBoard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorStruct", function() { return sectorStruct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wallStruct", function() { return wallStruct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spriteStruct", function() { return spriteStruct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boardStruct", function() { return boardStruct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadBuildMap", function() { return loadBuildMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveBuildMap", function() { return saveBuildMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initWallStats", function() { return initWallStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initWall", function() { return initWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newWall", function() { return newWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initSectorStats", function() { return initSectorStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initSector", function() { return initSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newSector", function() { return newSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initSpriteStats", function() { return initSpriteStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initSprite", function() { return initSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newSprite", function() { return newSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newBoard", function() { return newBoard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneSector", function() { return cloneSector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneWall", function() { return cloneWall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneSprite", function() { return cloneSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneBoard", function() { return cloneBoard; });
/* harmony import */ var _utils_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream */ "./src/utils/stream.ts");
/* harmony import */ var _board_structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/build/utils.ts");



var sectorStats = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["SectorStats"]).field('parallaxing', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('slopped', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('swapXY', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('doubleSmooshiness', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('xflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('yflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('alignToFirstWall', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('unk', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(9));
var sectorStruct = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["Sector"]).field('wallptr', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('wallnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('ceilingz', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('floorz', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('ceilingstat', sectorStats).field('floorstat', sectorStats).field('ceilingpicnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('ceilingheinum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('ceilingshade', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('ceilingpal', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('ceilingxpanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('ceilingypanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('floorpicnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('floorheinum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('floorshade', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('floorpal', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('floorxpanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('floorypanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('visibility', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('filler', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('lotag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('hitag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('extra', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]);
var wallStats = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["WallStats"]).field('blocking', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('swapBottoms', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('alignBottom', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('xflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('masking', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('oneWay', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('blocking2', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('translucent', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('yflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('translucentReversed', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('unk', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(6));
var wallStruct = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["Wall"]).field('x', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('y', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('point2', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('nextwall', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('nextsector', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('cstat', wallStats).field('picnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('overpicnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('shade', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('pal', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('xrepeat', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('yrepeat', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('xpanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('ypanning', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('lotag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('hitag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('extra', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]);
var spriteStats = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["SpriteStats"]).field('blocking', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('translucent', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('xflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('yflip', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('type', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(2)).field('onesided', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('realCenter', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('blocking2', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('tranclucentReversed', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('noautoshading', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1)).field('unk', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(4)).field('invisible', Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["bits"])(1));
var spriteStruct = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["Sprite"]).field('x', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('y', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('z', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('cstat', spriteStats).field('picnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('shade', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["byte"]).field('pal', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('clipdist', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('filler', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('xrepeat', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('yrepeat', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('xoffset', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('yoffset', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ubyte"]).field('sectnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('statnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('ang', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('owner', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('xvel', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('yvel', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('zvel', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["short"]).field('lotag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('hitag', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('extra', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]);
var boardStruct = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["struct"])(_board_structs__WEBPACK_IMPORTED_MODULE_1__["Board"]).field('version', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["uint"]).field('posx', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('posy', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('posz', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["int"]).field('ang', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]).field('cursectnum', _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"]);
function loadBuildMap(stream) {
  var brd = boardStruct.read(stream);
  brd.numsectors = _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].read(stream);
  brd.sectors = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(sectorStruct, brd.numsectors).read(stream);
  brd.numwalls = _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].read(stream);
  brd.walls = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(wallStruct, brd.numwalls).read(stream);
  brd.numsprites = _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].read(stream);
  brd.sprites = Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(spriteStruct, brd.numsprites).read(stream);
  return brd;
}
function saveBuildMap(board) {
  var size = boardStruct.size + 2 + sectorStruct.size * board.numsectors + 2 + wallStruct.size * board.numwalls + +2 + spriteStruct.size * board.numsprites;
  var buffer = new ArrayBuffer(size);
  var stream = new _utils_stream__WEBPACK_IMPORTED_MODULE_0__["Stream"](buffer, true);
  boardStruct.write(stream, board);
  _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].write(stream, board.numsectors);
  Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(sectorStruct, board.numsectors).write(stream, fixSectorSlopes(board.sectors));
  _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].write(stream, board.numwalls);
  Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(wallStruct, board.numwalls).write(stream, board.walls);
  _utils_stream__WEBPACK_IMPORTED_MODULE_0__["ushort"].write(stream, board.numsprites);
  Object(_utils_stream__WEBPACK_IMPORTED_MODULE_0__["array"])(spriteStruct, board.numsprites).write(stream, board.sprites);
  return buffer;
}

function fixSectorSlopes(sectors) {
  for (var sec of sectors) {
    sec.ceilingstat.slopped = 1;
    sec.floorstat.slopped = 1;
  }

  return sectors;
}

function initWallStats(stat) {
  stat.alignBottom = 0;
  stat.blocking = 0;
  stat.blocking2 = 0;
  stat.masking = 0;
  stat.oneWay = 0;
  stat.swapBottoms = 0;
  stat.translucent = 0;
  stat.translucentReversed = 0;
  stat.xflip = 0;
  stat.yflip = 0;
  stat.unk = 0;
  return stat;
}
function initWall(wall) {
  wall.x = 0;
  wall.y = 0;
  wall.point2 = -1;
  wall.nextwall = -1;
  wall.nextsector = -1;
  wall.cstat = initWallStats(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["WallStats"]());
  wall.picnum = 0;
  wall.overpicnum = 0;
  wall.shade = 0;
  wall.pal = 0;
  wall.xrepeat = 8;
  wall.yrepeat = 8;
  wall.xpanning = 0;
  wall.ypanning = 0;
  wall.lotag = 0;
  wall.hitag = 0;
  wall.extra = 65535;
  return wall;
}
function newWall() {
  return initWall(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Wall"]());
}
function initSectorStats(stat) {
  stat.alignToFirstWall = 0;
  stat.doubleSmooshiness = 0;
  stat.parallaxing = 0;
  stat.slopped = 0;
  stat.swapXY = 0;
  stat.xflip = 0;
  stat.yflip = 0;
  stat.unk = 0;
  return stat;
}
function initSector(sector) {
  sector.ceilingheinum = 0;
  sector.ceilingpal = 0;
  sector.ceilingpicnum = 0;
  sector.ceilingshade = 0;
  sector.ceilingstat = initSectorStats(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["SectorStats"]());
  sector.ceilingxpanning = 0;
  sector.ceilingypanning = 0;
  sector.ceilingz = 2048 * _utils__WEBPACK_IMPORTED_MODULE_2__["ZSCALE"];
  sector.extra = 65535;
  sector.floorheinum = 0;
  sector.floorpal = 0;
  sector.floorpicnum = 0;
  sector.floorshade = 0;
  sector.floorstat = initSectorStats(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["SectorStats"]());
  sector.floorxpanning = 0;
  sector.floorypanning = 0;
  sector.floorz = 0;
  sector.hitag = 0;
  sector.lotag = 0;
  sector.visibility = 0;
  sector.wallnum = 0;
  sector.wallptr = 0;
  sector.filler = 0;
  return sector;
}
function newSector() {
  return initSector(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Sector"]());
}
function initSpriteStats(stats) {
  stats.blocking = 0;
  stats.blocking2 = 0;
  stats.invisible = 0;
  stats.noautoshading = 0;
  stats.onesided = 0;
  stats.realCenter = 0;
  stats.tranclucentReversed = 0;
  stats.translucent = 0;
  stats.type = _board_structs__WEBPACK_IMPORTED_MODULE_1__["FACE_SPRITE"];
  stats.xflip = 0;
  stats.yflip = 0;
  stats.unk = 0;
  return stats;
}
function initSprite(sprite) {
  sprite.ang = 0;
  sprite.clipdist = 0;
  sprite.cstat = initSpriteStats(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["SpriteStats"]());
  sprite.extra = 65535;
  sprite.hitag = 0;
  sprite.lotag = 0;
  sprite.owner = -1;
  sprite.pal = 0;
  sprite.picnum = 1;
  sprite.sectnum = -1;
  sprite.shade = 0;
  sprite.statnum = 0;
  sprite.x = 0;
  sprite.y = 0;
  sprite.z = 0;
  sprite.xoffset = 0;
  sprite.yoffset = 0;
  sprite.xvel = 0;
  sprite.yvel = 0;
  sprite.xrepeat = 64;
  sprite.yrepeat = 64;
  sprite.filler = 0;
  return sprite;
}
function newSprite() {
  return initSprite(new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Sprite"]());
}
function newBoard() {
  var board = new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Board"]();
  board.walls = [];
  board.sectors = [];
  board.sprites = [];
  board.numwalls = 0;
  board.numsectors = 0;
  board.numsprites = 0;
  board.version = 0x0007;
  board.posx = board.posy = board.posz = board.cursectnum = board.ang = 0;
  return board;
}
function cloneSector(sector) {
  var sectorCopy = new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Sector"]();
  Object.assign(sectorCopy, sector);
  Object.assign(sectorCopy.floorstat, sector.floorstat);
  Object.assign(sectorCopy.ceilingstat, sector.ceilingstat);
  return sectorCopy;
}
function cloneWall(wall) {
  var wallCopy = new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Wall"]();
  Object.assign(wallCopy, wall);
  Object.assign(wallCopy.cstat, wall.cstat);
  return wallCopy;
}
function cloneSprite(sprite) {
  var spriteCopy = new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Sprite"]();
  Object.assign(spriteCopy, sprite);
  Object.assign(spriteCopy.cstat, sprite.cstat);
  return spriteCopy;
}
function cloneBoard(board) {
  var copy = new _board_structs__WEBPACK_IMPORTED_MODULE_1__["Board"]();
  Object.assign(copy, board);
  copy.sectors = [];
  copy.walls = [];
  copy.sprites = [];

  for (var i = 0; i < board.numsectors; i++) {
    copy.sectors[i] = cloneSector(board.sectors[i]);
  }

  for (var _i = 0; _i < board.numwalls; _i++) {
    copy.walls[_i] = cloneWall(board.walls[_i]);
  }

  for (var _i2 = 0; _i2 < board.numsprites; _i2++) {
    copy.sprites[_i2] = cloneSprite(board.sprites[_i2]);
  }

  return copy;
}

/***/ }),

/***/ "./src/build/utils.ts":
/*!****************************!*\
  !*** ./src/build/utils.ts ***!
  \****************************/
/*! exports provided: ZSCALE, build2gl, gl2build, getPlayerStart, inPolygon, sectorZ, sectorHeinum, setSectorZ, setSectorHeinum, sectorPicnum, setSectorPicnum, groupSprites, ANGSCALE, slope, createSlopeCalculator, lineIntersect, rayIntersect, getFirstWallAngle, wallVisible, wallNormal, sectorNormal, ang2vec, spriteAngle, vec2ang, clockwise, order */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZSCALE", function() { return ZSCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "build2gl", function() { return build2gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gl2build", function() { return gl2build; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlayerStart", function() { return getPlayerStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inPolygon", function() { return inPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorZ", function() { return sectorZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorHeinum", function() { return sectorHeinum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSectorZ", function() { return setSectorZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSectorHeinum", function() { return setSectorHeinum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorPicnum", function() { return sectorPicnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSectorPicnum", function() { return setSectorPicnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupSprites", function() { return groupSprites; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANGSCALE", function() { return ANGSCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slope", function() { return slope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSlopeCalculator", function() { return createSlopeCalculator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineIntersect", function() { return lineIntersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rayIntersect", function() { return rayIntersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstWallAngle", function() { return getFirstWallAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wallVisible", function() { return wallVisible; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wallNormal", function() { return wallNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sectorNormal", function() { return sectorNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ang2vec", function() { return ang2vec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spriteAngle", function() { return spriteAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2ang", function() { return vec2ang; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clockwise", function() { return clockwise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "order", function() { return order; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _utils_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/collections */ "./src/utils/collections.ts");
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _utils_vecmath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/vecmath */ "./src/utils/vecmath.ts");
/* harmony import */ var _board_structs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./board/structs */ "./src/build/board/structs.ts");
/* harmony import */ var _hitscan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hitscan */ "./src/build/hitscan.ts");






var ZSCALE = -16;
function build2gl(out, vec) {
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(out, vec[0], vec[2] / ZSCALE, vec[1]);
}
function gl2build(out, vec) {
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(out, vec[0], vec[2], vec[1] * ZSCALE);
}
var fakePlayerStart_;

function fakePlayerStart() {
  if (fakePlayerStart_ == null) {
    fakePlayerStart_ = new _board_structs__WEBPACK_IMPORTED_MODULE_4__["Sprite"]();
    fakePlayerStart_.x = 0;
    fakePlayerStart_.y = 0;
    fakePlayerStart_.z = 0;
    fakePlayerStart_.sectnum = -1;
  }

  return fakePlayerStart_;
}

function getPlayerStart(board) {
  for (var i = 0; i < board.numsprites; i++) {
    var sprite = board.sprites[i];
    if (sprite.lotag == 1) return sprite;
  }

  return fakePlayerStart();
}
function inPolygon(x, y, points) {
  var inter = 0;

  for (var [p1, p2] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["loopPairs"])(points)) {
    var [x1, y1] = p1;
    var [x2, y2] = p2;
    var dx1 = x1 - x;
    var dx2 = x2 - x;
    var dy1 = y1 - y;
    var dy2 = y2 - y;
    if (dx1 == 0 && dx2 == 0 && (dy1 == 0 || dy2 == 0 || (dy1 ^ dy2) < 0)) return true;
    if (dy1 == 0 && dy2 == 0 && (dx1 == 0 || dx2 == 0 || (dx1 ^ dx2) < 0)) return true;

    if ((dy1 ^ dy2) < 0) {
      if ((dx1 ^ dx2) >= 0) inter ^= dx1;else inter ^= Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(dx1, dy1, dx2, dy2) ^ dy2;
    }
  }

  return inter >>> 31 == 1;
}
function sectorZ(board, sectorEnt) {
  var sec = board.sectors[sectorEnt.id];
  return sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING ? sec.ceilingz : sec.floorz;
}
function sectorHeinum(board, sectorEnt) {
  var sec = board.sectors[sectorEnt.id];
  return sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING ? sec.ceilingheinum : sec.floorheinum;
}
function setSectorZ(board, sectorEnt, z) {
  var pz = sectorZ(board, sectorEnt);
  if (pz == z) return false;
  var sec = board.sectors[sectorEnt.id];
  if (sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING) sec.ceilingz = z;else sec.floorz = z;
  return true;
}
function setSectorHeinum(board, sectorEnt, h) {
  var ph = sectorHeinum(board, sectorEnt);
  if (ph == h) return false;
  var sec = board.sectors[sectorEnt.id];
  if (sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING) sec.ceilingheinum = h;else sec.floorheinum = h;
  return true;
}
function sectorPicnum(board, sectorEnt) {
  var sec = board.sectors[sectorEnt.id];
  return sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING ? sec.ceilingpicnum : sec.floorpicnum;
}
function setSectorPicnum(board, sectorEnt, picnum) {
  if (picnum == -1 || sectorPicnum(board, sectorEnt) == picnum) return false;
  var sec = board.sectors[sectorEnt.id];
  if (sectorEnt.type == _hitscan__WEBPACK_IMPORTED_MODULE_5__["EntityType"].CEILING) sec.ceilingpicnum = picnum;else sec.floorpicnum = picnum;
  return true;
}
function groupSprites(board) {
  var sec2spr = {};

  for (var s = 0; s < board.numsprites; s++) {
    var spr = board.sprites[s];
    var sprs = sec2spr[spr.sectnum];

    if (sprs == undefined) {
      sprs = [];
      sec2spr[spr.sectnum] = sprs;
    }

    sprs.push(s);
  }

  return sec2spr;
}
var ANGSCALE = 1 / 4096;
function slope(board, sectorId, x, y, heinum) {
  var sec = board.sectors[sectorId];
  var wall1 = board.walls[sec.wallptr];
  var wall2 = board.walls[wall1.point2];
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var ln = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["len2d"])(dx, dy);
  dx /= ln;
  dy /= ln;
  var dx1 = x - wall1.x;
  var dy1 = y - wall1.y;
  var k = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(dx, dy, dx1, dy1);
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(heinum * ANGSCALE * k * ZSCALE);
}
function createSlopeCalculator(board, sectorId) {
  var sector = board.sectors[sectorId];
  var wall1 = board.walls[sector.wallptr];
  var wall2 = board.walls[wall1.point2];
  var dx = wall2.x - wall1.x;
  var dy = wall2.y - wall1.y;
  var ln = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["len2d"])(dx, dy);
  dx /= ln;
  dy /= ln;
  return function (x, y, heinum) {
    var dx1 = x - wall1.x;
    var dy1 = y - wall1.y;
    var k = -Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(dx, dy, dx1, dy1);
    return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(heinum * ANGSCALE * k * ZSCALE);
  };
}
function lineIntersect(sx, sy, sz, x2, y2, z2, x3, y3, x4, y4) {
  var x21 = x2 - sx,
      x34 = x3 - x4;
  var y21 = y2 - sy,
      y34 = y3 - y4;
  var bot = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x21, y21, x34, y34);
  if (bot == 0) return null;
  var x31 = x3 - sx,
      y31 = y3 - sy;
  var topt = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x31, y31, x34, y34);

  if (bot > 0) {
    if (topt < 0 || topt >= bot) return null;
    var topu = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x21, y31, x31, y31);
    if (topu < 0 || topu >= bot) return null;
  } else {
    if (topt > 0 || topt <= bot) return null;

    var _topu = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x21, y21, x31, y31);

    if (_topu > 0 || _topu <= bot) return null;
  }

  var t = topt / bot;
  var x = sx + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(x21 * t);
  var y = sy + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(y21 * t);
  var z = sz + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])((z2 - sz) * t) * ZSCALE;
  return [x, y, z, t];
}
function rayIntersect(xs, ys, zs, vx, vy, vz, x3, y3, x4, y4) {
  var x34 = x3 - x4;
  var y34 = y3 - y4;
  var bot = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(vx, vy, x34, y34);
  if (bot == 0) return null;
  var x31 = x3 - xs;
  var y31 = y3 - ys;
  var topt = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(x31, y31, x34, y34);

  if (bot > 0) {
    if (topt < 0) return null;
    var topu = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(vx, vy, x31, y31);
    if (topu < 0 || topu >= bot) return null;
  } else {
    if (topt > 0) return null;

    var _topu2 = Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(vx, vy, x31, y31);

    if (_topu2 > 0 || _topu2 <= bot) return null;
  }

  var t = topt / bot;
  var x = xs + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(vx * t);
  var y = ys + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(vy * t);
  var z = zs + Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(vz * t);
  return [x, y, z, t];
}
function getFirstWallAngle(board, sectorId) {
  var sector = board.sectors[sectorId];
  var w1 = board.walls[sector.wallptr];
  var w2 = board.walls[w1.point2];
  var dx = w2.x - w1.x;
  var dy = w2.y - w1.y;
  return Math.atan2(-dy, dx);
}
function wallVisible(board, wallId, ms) {
  var wall1 = board.walls[wallId];
  var wall2 = board.walls[wall1.point2];
  var dx1 = wall2.x - wall1.x;
  var dy1 = wall2.y - wall1.y;
  var dx2 = ms.x - wall1.x;
  var dy2 = ms.y - wall1.y;
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(dx1, dy1, dx2, dy2) >= 0;
}

var _normal = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].create();

function wallNormal(out, board, wallId) {
  var w1 = board.walls[wallId];
  var w2 = board.walls[w1.point2];
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].set(_normal, w1.x - w2.x, w1.y - w2.y);
  Object(_utils_vecmath__WEBPACK_IMPORTED_MODULE_3__["normal2d"])(_normal, _normal);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(out, _normal[0], 0, _normal[1]);
  return out;
}

var _wn = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();

var _up = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, 1, 0);

var _down = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, -1, 0);

function sectorNormal(out, board, sectorId, ceiling) {
  var sector = board.sectors[sectorId];
  wallNormal(_wn, board, sector.wallptr);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].negate(_wn, _wn);
  var h = ceiling ? sector.ceilingheinum : sector.floorheinum;
  var normal = ceiling ? _down : _up;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].lerp(out, normal, _wn, Math.atan(h * ANGSCALE) / (Math.PI / 2));
  return out;
}
function ang2vec(ang) {
  ang += Math.PI / 2;
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(Math.sin(ang), 0, Math.cos(ang));
}
function spriteAngle(ang) {
  return _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["PI2"] - ang * ANGSCALE * 2 * _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["PI2"];
}
function vec2ang(x, y) {
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["int"])(Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["monoatan2"])(y, x) / _utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["PI2"] / ANGSCALE / 2);
}
function clockwise(polygon) {
  var minx = Number.MAX_VALUE;
  var minwall = -1;
  var points = [...polygon];
  var len = points.length;

  for (var [w1, w2] of Object(_utils_collections__WEBPACK_IMPORTED_MODULE_1__["cyclicPairs"])(len)) {
    var _wall = points[w2];

    if (_wall[0] < minx) {
      minx = _wall[0];
      minwall = w1;
    }
  }

  var wall0 = points[minwall];
  var wall1 = points[Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cyclic"])(minwall + 1, len)];
  var wall2 = points[Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cyclic"])(minwall + 2, len)];
  if (wall2[1] <= wall1[1] && wall1[1] <= wall0[1]) return true;
  if (wall0[1] <= wall1[1] && wall1[1] <= wall2[1]) return false;
  return Object(_utils_mathutils__WEBPACK_IMPORTED_MODULE_2__["cross2d"])(wall0[0] - wall1[0], wall0[1] - wall1[1], wall2[0] - wall1[0], wall2[1] - wall1[1]) < 0;
}
function order(points, cw) {
  if (cw === void 0) {
    cw = true;
  }

  var actual = clockwise(points);
  if (actual == cw) return points;else {
    var reversed = [...points];
    reversed.reverse();
    return reversed;
  }
}

/***/ }),

/***/ "./src/builded.ts":
/*!************************!*\
  !*** ./src/builded.ts ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_modules_duke_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app/modules/duke/module */ "./src/app/modules/duke/module.ts");
/* harmony import */ var _app_modules_buildartprovider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app/modules/buildartprovider */ "./src/app/modules/buildartprovider.ts");
/* harmony import */ var _app_modules_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/modules/context */ "./src/app/modules/context.ts");
/* harmony import */ var _app_modules_fs_db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/modules/fs/db */ "./src/app/modules/fs/db.ts");
/* harmony import */ var _app_modules_fs_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app/modules/fs/manager */ "./src/app/modules/fs/manager.ts");
/* harmony import */ var _app_modules_arteditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./app/modules/arteditor */ "./src/app/modules/arteditor.ts");
/* harmony import */ var _app_modules_photonui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./app/modules/photonui */ "./src/app/modules/photonui.ts");
/* harmony import */ var _utils_gl_gl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/gl/gl */ "./src/utils/gl/gl.ts");
/* harmony import */ var _utils_injector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/injector */ "./src/utils/injector.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _app_modules_input__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./app/modules/input */ "./src/app/modules/input.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }












Object(_utils_logger__WEBPACK_IMPORTED_MODULE_9__["addLogAppender"])(_utils_logger__WEBPACK_IMPORTED_MODULE_9__["CONSOLE"]);
var gl = Object(_utils_gl_gl__WEBPACK_IMPORTED_MODULE_7__["createContextFromCanvas"])("display", {
  alpha: false,
  antialias: true,
  stencil: true
});
var module = new _utils_injector__WEBPACK_IMPORTED_MODULE_8__["RootModule"]();
module.bindInstance(_app_modules_buildartprovider__WEBPACK_IMPORTED_MODULE_1__["GL"], gl);
module.install(_app_modules_input__WEBPACK_IMPORTED_MODULE_10__["InputModule"]);
module.install(Object(_app_modules_fs_db__WEBPACK_IMPORTED_MODULE_3__["DbFsModule"])('resources/engines/blood/'));
module.install(_app_modules_context__WEBPACK_IMPORTED_MODULE_2__["DefaultSetupModule"]); // module.install(BloodModule);

module.install(_app_modules_duke_module__WEBPACK_IMPORTED_MODULE_0__["DukeModule"]);
module.install(_app_modules_photonui__WEBPACK_IMPORTED_MODULE_6__["PhotonUiModule"]);
module.install(_app_modules_fs_manager__WEBPACK_IMPORTED_MODULE_4__["FileBrowserModule"]);
module.install(_app_modules_arteditor__WEBPACK_IMPORTED_MODULE_5__["ArtEditorModule"]);
module.execute( /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (injector) {
    Object(_app_modules_context__WEBPACK_IMPORTED_MODULE_2__["MainLoopConstructor"])(injector).then(mainLoop => {
      Object(_utils_gl_gl__WEBPACK_IMPORTED_MODULE_7__["animate"])(gl, (gl, time) => {
        mainLoop.frame(time);
      });
    });
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
module.start();

/***/ }),

/***/ "./src/libs_js/glmatrix.js":
/*!*********************************!*\
  !*** ./src/libs_js/glmatrix.js ***!
  \*********************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _glmatrix_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glmatrix/common.js */ "./src/libs_js/glmatrix/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _glmatrix_common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _glmatrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glmatrix/mat2.js */ "./src/libs_js/glmatrix/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _glmatrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _glmatrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glmatrix/mat2d.js */ "./src/libs_js/glmatrix/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _glmatrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _glmatrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glmatrix/mat3.js */ "./src/libs_js/glmatrix/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _glmatrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _glmatrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glmatrix/mat4.js */ "./src/libs_js/glmatrix/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _glmatrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _glmatrix_quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./glmatrix/quat.js */ "./src/libs_js/glmatrix/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _glmatrix_quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _glmatrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./glmatrix/quat2.js */ "./src/libs_js/glmatrix/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _glmatrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _glmatrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./glmatrix/vec2.js */ "./src/libs_js/glmatrix/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _glmatrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _glmatrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./glmatrix/vec3.js */ "./src/libs_js/glmatrix/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _glmatrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _glmatrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./glmatrix/vec4.js */ "./src/libs_js/glmatrix/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _glmatrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./src/libs_js/glmatrix/common.js":
/*!****************************************!*\
  !*** ./src/libs_js/glmatrix/common.js ***!
  \****************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./src/libs_js/glmatrix/mat2.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/mat2.js ***!
  \**************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./src/libs_js/glmatrix/mat2d.js":
/*!***************************************!*\
  !*** ./src/libs_js/glmatrix/mat2d.js ***!
  \***************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b, c,
 *  d, tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./src/libs_js/glmatrix/mat3.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/mat3.js ***!
  \**************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./src/libs_js/glmatrix/mat4.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/mat4.js ***!
  \**************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./src/libs_js/glmatrix/quat.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/quat.js ***!
  \**************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./src/libs_js/glmatrix/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./src/libs_js/glmatrix/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./src/libs_js/glmatrix/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./src/libs_js/glmatrix/quat2.js":
/*!***************************************!*\
  !*** ./src/libs_js/glmatrix/quat2.js ***!
  \***************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./src/libs_js/glmatrix/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./src/libs_js/glmatrix/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q a normalized quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./src/libs_js/glmatrix/vec2.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/vec2.js ***!
  \**************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/libs_js/glmatrix/vec3.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/vec3.js ***!
  \**************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/libs_js/glmatrix/vec4.js":
/*!**************************************!*\
  !*** ./src/libs_js/glmatrix/vec4.js ***!
  \**************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./src/libs_js/glmatrix/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/utils/bag.ts":
/*!**************************!*\
  !*** ./src/utils/bag.ts ***!
  \**************************/
/*! exports provided: Place, Bag, BagController, create, createController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Place", function() { return Place; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bag", function() { return Bag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BagController", function() { return BagController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createController", function() { return createController; });
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list */ "./src/utils/list.ts");

class Place {
  constructor(offset, size, data) {
    if (data === void 0) {
      data = null;
    }

    this.offset = offset;
    this.size = size;
    this.data = data;
  }

}
class Bag {
  constructor(size) {
    this.holes = void 0;
    this.size = size;
    this.reset();
  }

  getSuitablePlace(size) {
    for (var hole = this.holes.first(); hole != this.holes.terminator(); hole = hole.next) {
      if (hole.obj.size >= size) return hole;
    }

    return null;
  }

  tryMerge(node) {
    if (node != this.holes.terminator() && node.next != this.holes.terminator()) {
      if (node.obj.offset + node.obj.size == node.next.obj.offset) {
        node.obj.size += node.next.obj.size;
        this.holes.remove(node.next);
        this.tryMerge(node);
      }
    }
  }

  put(offset, size) {
    var hole = this.holes.first();

    if (hole == this.holes.terminator()) {
      this.holes.insertAfter(new Place(offset, size));
      return;
    }

    while (hole.next != this.holes.terminator()) {
      var next = hole.next;
      if (next.obj.offset >= size + offset) break;
      hole = next;
    }

    var end = hole.obj.offset + hole.obj.size;

    if (hole.obj.offset > offset) {
      var newHole = this.holes.insertBefore(new Place(offset, size), hole);
      this.tryMerge(newHole);
    } else if (end == offset) {
      hole.obj.size += size;
      this.tryMerge(hole);
    } else {
      var _newHole = this.holes.insertAfter(new Place(offset, size), hole);

      this.tryMerge(_newHole);
    }
  }

  get(size) {
    var hole = this.getSuitablePlace(size);
    if (hole == null) return null;

    if (hole.obj.size == size) {
      var prev = hole.prev;
      this.holes.remove(hole);
      this.tryMerge(prev);
      return hole.obj.offset;
    } else {
      var off = hole.obj.offset;
      hole.obj.offset += size;
      hole.obj.size -= size;
      return off;
    }
  }

  reset() {
    this.holes = new _list__WEBPACK_IMPORTED_MODULE_0__["List"]();
    this.holes.insertAfter(new Place(0, this.size));
  }

  freeSpace(segments) {
    var results = new Array(segments).fill(1);
    var ds = this.size / segments;

    for (var hole of this.holes) {
      var hstart = hole.offset;
      var hend = hstart + hole.size;

      for (var i = hstart / ds | 0; i <= (hend / ds | 0) && i < segments; i++) {
        var start = i * ds;
        var end = start + ds;
        var dl = Math.max(0, hstart - start);
        var dr = Math.max(0, end - hend);
        results[i] -= 1 - (dl + dr) / ds;
      }
    }

    return results;
  }

}
class BagController {
  constructor(size, updater) {
    this.bag = void 0;
    this.places = {};
    this.updater = void 0;
    this.bag = new Bag(size);
    this.updater = updater;
  }

  get(size) {
    var offset = this.bag.get(size); // if (offset == null) {
    //   this.optimize();
    //   offset = this.bag.get(size);
    // }

    if (offset == null) return null;
    var result = new Place(offset, size);
    this.places[offset] = result;
    return result;
  }

  put(place) {
    this.bag.put(place.offset, place.size);
    delete this.places[place.offset];
  }

  optimize() {
    var places = this.places;
    var keys = Object.keys(places);
    this.places = {};
    this.bag.reset();
    var offset = 0;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var _place = places[key];
      this.places[offset] = _place;
      if (_place.offset == offset) continue;
      this.updater(_place, offset);
      _place.offset = offset;
      offset += _place.size;
    }

    this.bag.get(offset);
  }

  freeSpace(segments) {
    return this.bag.freeSpace(segments);
  }

}
function create(size) {
  return new Bag(size);
}
function createController(size, updater) {
  return new BagController(size, updater);
}

/***/ }),

/***/ "./src/utils/cachedvalue.ts":
/*!**********************************!*\
  !*** ./src/utils/cachedvalue.ts ***!
  \**********************************/
/*! exports provided: CachedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedValue", function() { return CachedValue; });
class CachedValue {
  constructor(supplier, cached) {
    if (cached === void 0) {
      cached = null;
    }

    this.valid = false;
    this.supplier = supplier;
    this.cached = cached;
  }

  get() {
    if (!this.valid) {
      this.cached = this.supplier(this.cached);
      this.valid = true;
    }

    return this.cached;
  }

  invalidate() {
    this.valid = false;
  }

}

/***/ }),

/***/ "./src/utils/camera/camera.ts":
/*!************************************!*\
  !*** ./src/utils/camera/camera.ts ***!
  \************************************/
/*! exports provided: Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mathutils */ "./src/utils/mathutils.ts");


class Camera {
  constructor(x, y, z, ax, ay) {
    this.transform = void 0;
    this.position = void 0;
    this.angleX = void 0;
    this.angleY = void 0;
    this.needUpdate = true;
    this.transform = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    this.position = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(x, y, z);
    this.angleX = ax;
    this.angleY = ay;
  }

  setPosition(x, y, z) {
    this.position[0] = x;
    this.position[1] = y;
    this.position[2] = z;
    this.needUpdate = true;
  }

  setPositionXYZ(x, y, z) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this.position, x, y, z);
    this.needUpdate = true;
  }

  getPosition() {
    return this.position;
  }

  forward() {
    var mat4 = this.getTransformMatrix();
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-mat4[2], -mat4[6], -mat4[10]);
  }

  side() {
    var mat4 = this.getTransformMatrix();
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(mat4[0], mat4[4], mat4[8]);
  }

  updateAngles(dx, dy) {
    this.angleY -= dx;
    this.angleX -= dy;
    this.angleX = Math.max(-90, Math.min(90, this.angleX));
    this.needUpdate = true;
  }

  setAngles(ax, ay) {
    this.angleX = Math.max(-90, Math.min(90, ax));
    this.angleY = ay;
    this.needUpdate = true;
  }

  getTransformMatrix() {
    var mat = this.transform;

    if (this.needUpdate) {
      var pos = this.position;
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(mat);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateX(mat, mat, Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(-this.angleX));
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateY(mat, mat, Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(-this.angleY));
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].negate(pos, pos);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(mat, mat, pos);
      _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].negate(pos, pos);
      this.needUpdate = false;
    }

    return mat;
  }

}

/***/ }),

/***/ "./src/utils/camera/controller2d.ts":
/*!******************************************!*\
  !*** ./src/utils/camera/controller2d.ts ***!
  \******************************************/
/*! exports provided: Controller2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller2D", function() { return Controller2D; });
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera */ "./src/utils/camera/camera.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");


class Controller2D {
  constructor() {
    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_0__["Camera"](0, 0, 0, 0, 0);
    this.width = 800;
    this.height = 600;
    this.oldX = 0;
    this.oldY = 0;
    this.scale = 1;
    this.projection = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
  }

  track(x, y, z, move) {
    if (move) {
      var dx = (x - this.oldX) * this.scale;
      var dy = (y - this.oldY) * this.scale;
      var pos = this.camera.getPosition();
      this.camera.setPositionXYZ(pos[0] - dx, z, pos[2] - dy);
    }

    this.oldX = x;
    this.oldY = y;
  }

  setSize(w, h) {
    this.width = w;
    this.height = h;
  }

  getWidth() {
    return this.width;
  }

  getHeight() {
    return this.height;
  }

  setUnitsPerPixel(scale) {
    this.scale = scale;
  }

  getUnitsPerPixel() {
    return this.scale;
  }

  setPosition(x, y, z) {
    this.camera.setPositionXYZ(x, z, y);
  }

  getPosition() {
    return this.camera.getPosition();
  }

  getTransformMatrix() {
    return this.camera.getTransformMatrix();
  }

  getPointerPosition(pointer, x, y) {
    var pos = this.camera.getPosition();
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pointer, pos[0] + this.width / 2 * x * this.scale, 0, pos[2] + this.height / 2 * y * this.scale);
  }

  getProjectionMatrix() {
    var projection = this.projection;
    var wscale = this.width / 2 * this.scale;
    var hscale = this.height / 2 * this.scale;
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].identity(projection);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].ortho(projection, -wscale, wscale, hscale, -hscale, 1, 0xFFFF);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].rotateX(projection, projection, -Math.PI / 2);
    return projection;
  }

}

/***/ }),

/***/ "./src/utils/camera/controller3d.ts":
/*!******************************************!*\
  !*** ./src/utils/camera/controller3d.ts ***!
  \******************************************/
/*! exports provided: Controller3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller3D", function() { return Controller3D; });
/* harmony import */ var _utils_mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ "./src/utils/camera/camera.ts");
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");



var invertTrans = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
var invTP = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
var forward = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
class Controller3D {
  constructor() {
    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_1__["Camera"](0, 0, 0, 0, 0);
    this.projection = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
    this.fov = 90;
    this.oldX = 0;
    this.oldY = 0;
  }

  setFov(fov) {
    this.fov = fov;
  }

  getFov() {
    return this.fov;
  }

  getMatrix(aspect) {
    var projection = this.getProjectionMatrix(aspect);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].mul(projection, projection, this.camera.getTransformMatrix());
    return projection;
  }

  getProjectionMatrix(aspect) {
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].perspective(this.projection, _utils_mathutils__WEBPACK_IMPORTED_MODULE_0__["deg2rad"](this.fov), aspect, 1, 0x4FFF);
  }

  getTransformMatrix() {
    return this.camera.getTransformMatrix();
  }

  getPosition() {
    return this.camera.getPosition();
  }

  setPosition(x, y, z) {
    this.camera.setPosition(x, y, z);
  }

  getForward() {
    return this.camera.forward();
  }

  getForwardUnprojected(aspect, x, y) {
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].invert(invertTrans, this.getTransformMatrix());
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].invert(invTP, this.getProjectionMatrix(aspect));
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["mat4"].mul(invTP, invertTrans, invTP);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].set(forward, x, -y, -1);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(forward, forward, invTP);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].sub(forward, forward, this.getPosition());
    return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].normalize(forward, forward);
  }

  moveForward(dist) {
    var forward = this.camera.forward();
    var campos = this.camera.getPosition();
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].scale(forward, forward, dist);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].add(campos, campos, forward);
    this.camera.setPosition(campos[0], campos[1], campos[2]);
  }

  moveSideway(dist) {
    var sideways = this.camera.side();
    var campos = this.camera.getPosition();
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].scale(sideways, sideways, dist);
    _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_2__["vec3"].add(campos, campos, sideways);
    this.camera.setPosition(campos[0], campos[1], campos[2]);
  }

  track(x, y, move) {
    if (move) this.camera.updateAngles((x - this.oldX) / 2, (y - this.oldY) / 2);
    this.oldX = x;
    this.oldY = y;
  }

}

/***/ }),

/***/ "./src/utils/collections.ts":
/*!**********************************!*\
  !*** ./src/utils/collections.ts ***!
  \**********************************/
/*! exports provided: last, first, isEmpty, TERMINAL_ITERATOR_RESULT, EMPTY_ITERATOR, EMPTY_COLLECTION, iteratorResult, ArrayWrapper, wrap, Deck, IndexedDeck, reverse, length, filter, map, forEach, reduce, sub, all, any, iterIsEmpty, findFirst, chain, butLast, reversed, enumerate, range, rangeIter, cyclicRange, cyclicPairs, loopPairs, pairs, take, skip, skipWhile, rect, intersect, interpolate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "first", function() { return first; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TERMINAL_ITERATOR_RESULT", function() { return TERMINAL_ITERATOR_RESULT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_ITERATOR", function() { return EMPTY_ITERATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_COLLECTION", function() { return EMPTY_COLLECTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iteratorResult", function() { return iteratorResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayWrapper", function() { return ArrayWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deck", function() { return Deck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IndexedDeck", function() { return IndexedDeck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return reduce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return any; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterIsEmpty", function() { return iterIsEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFirst", function() { return findFirst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "butLast", function() { return butLast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reversed", function() { return reversed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumerate", function() { return enumerate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rangeIter", function() { return rangeIter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicRange", function() { return cyclicRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicPairs", function() { return cyclicPairs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loopPairs", function() { return loopPairs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return pairs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "take", function() { return take; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return skip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skipWhile", function() { return skipWhile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rect", function() { return rect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iter */ "./src/utils/iter.ts");
var _Symbol$iterator;



function last(c) {
  return c.get(c.length() - 1);
}
function first(c) {
  return c.get(0);
}
function isEmpty(c) {
  return c.length() == 0;
}
var TERMINAL_ITERATOR_RESULT = {
  value: null,
  done: true
};
var EMPTY_ITERATOR = {
  next: () => TERMINAL_ITERATOR_RESULT
};
var EMPTY_COLLECTION = {
  get: i => undefined,
  length: () => 0,
  [Symbol.iterator]: () => EMPTY_ITERATOR,
  set: (i, v) => {}
};
function iteratorResult(isDone, val) {
  return isDone ? TERMINAL_ITERATOR_RESULT : {
    done: false,
    value: val
  };
}
class ArrayWrapper {
  constructor(array, size) {
    if (size === void 0) {
      size = array.length;
    }

    this.array = array;
    this.size = size;
  }

  get(i) {
    return this.array[i];
  }

  length() {
    return this.size;
  }

  [Symbol.iterator]() {
    return this.array.values();
  }

  set(i, value) {
    this.array[i] = value;
  }

}
function wrap(array, len) {
  if (len === void 0) {
    len = array.length;
  }

  return new ArrayWrapper(array, len);
}
_Symbol$iterator = Symbol.iterator;
class Deck {
  constructor() {
    this.array = [];
    this.size = 0;
  }

  get(i) {
    return this.array[i];
  }

  set(i, value) {
    if (i < 0 || i >= this.size) throw new Error("Invalid set position: " + i + ", size:" + this.size);
    this.array[i] = value;
  }

  push(value) {
    this.array[this.size++] = value;
    return this;
  }

  pushAll(values) {
    for (var val of values) {
      this.push(val);
    }

    return this;
  }

  pop() {
    this.size--;
    return this;
  }

  top() {
    return this.array[this.size - 1];
  }

  clear() {
    this.size = 0;
    return this;
  }

  length() {
    return this.size;
  }

  clone() {
    var copy = new Deck();
    copy.array = [...take(this.array, this.size)];
    copy.size = this.size;
    return copy;
  }

  [_Symbol$iterator]() {
    var i = 0;
    return this.size == 0 ? EMPTY_ITERATOR : {
      next: () => {
        return iteratorResult(i == this.size, this.array[i++]);
      }
    };
  }

}
class IndexedDeck extends Deck {
  constructor() {
    super(...arguments);
    this.index = new Map();
  }

  push(value) {
    if (this.index.has(value)) return this;
    super.push(value);
    this.index.set(value, this.size - 1);
    return this;
  }

  set(i, value) {
    var last = this.get(i);
    super.set(i, value);
    this.index.delete(last);
    this.index.set(value, i);
  }

  clear() {
    super.clear();
    this.index.clear();
    return this;
  }

  indexOf(value) {
    var idx = this.index.get(value);
    return idx == undefined ? -1 : idx;
  }

  hasAny(i) {
    for (var v of i) {
      if (this.indexOf(v) != -1) return true;
    }

    return false;
  }

}
function reverse(c) {
  return isEmpty(c) ? EMPTY_COLLECTION : {
    get: i => c.get(c.length() - 1 - i),
    length: () => c.length(),
    [Symbol.iterator]: () => reversed(c)
  };
}
function length(it) {
  var length = 0;

  for (var _ of it) {
    length++;
  }

  return length;
}
function* filter(i, f) {
  for (var v of i) {
    if (f(v)) yield v;
  }
}
function* map(i, f) {
  for (var v of i) {
    yield f(v);
  }
}
function forEach(i, f) {
  for (var v of i) {
    f(v);
  }
}
function reduce(i, f, start) {
  for (var v of i) {
    start = f(start, v);
  }

  return start;
}
function* sub(c, start, length) {
  for (var _i = 0; _i < length; _i++) {
    yield c.get(start + _i);
  }
}
function all(i, f) {
  for (var _t of i) {
    if (!f(_t)) return false;
  }

  return true;
}
function any(i, f) {
  for (var _t2 of i) {
    if (f(_t2)) return true;
  }

  return false;
}
function iterIsEmpty(i) {
  var ii = i[Symbol.iterator]();
  return ii.next().done;
}
function findFirst(i, f, def) {
  for (var _t3 of i) {
    if (f(_t3)) return _t3;
  }

  return def;
}
function* chain(i1, i2) {
  var iter1 = i1[Symbol.iterator]();
  var v = iter1.next();

  while (!v.done) {
    yield v.value;
    v = iter1.next();
  }

  var iter2 = i2[Symbol.iterator]();
  v = iter2.next();

  while (!v.done) {
    yield v.value;
    v = iter2.next();
  }
}
function* butLast(i) {
  var iter = i[Symbol.iterator]();
  var v1 = iter.next();
  if (v1.done) return;
  var v2 = iter.next();

  while (!v2.done) {
    yield v1.value;
    v1 = v2;
    v2 = iter.next();
  }
}
function* reversed(c) {
  for (var _i2 = c.length() - 1; _i2 >= 0; _i2--) {
    yield c.get(_i2);
  }
}
function* enumerate(c) {
  var i = 0;

  for (var _t4 of c) {
    yield [_t4, i++];
  }
}
function* range(start, end) {
  var di = start > end ? -1 : 1;

  for (var _i3 = start; _i3 != end; _i3 += di) {
    yield _i3;
  }
}
function rangeIter(start, end) {
  return _iter__WEBPACK_IMPORTED_MODULE_1__["Iter"].of(range(start, end));
}
function* cyclicRange(start, length) {
  if (start >= length) throw new Error(start + " >= " + length);

  for (var _i4 = 0; _i4 < length; _i4++) {
    yield Object(_mathutils__WEBPACK_IMPORTED_MODULE_0__["cyclic"])(start + _i4, length);
  }
}
function* cyclicPairs(length) {
  if (length < 0) throw new Error(length + " < 0");

  for (var _i5 = 0; _i5 < length; _i5++) {
    yield [_i5, Object(_mathutils__WEBPACK_IMPORTED_MODULE_0__["cyclic"])(_i5 + 1, length)];
  }
}
function* loopPairs(i) {
  var iter = i[Symbol.iterator]();
  var first = iter.next();
  if (first.done) return;
  var lh = first;
  var rh = iter.next();

  while (!rh.done) {
    yield [lh.value, rh.value];
    lh = rh;
    rh = iter.next();
  }

  yield [lh.value, first.value];
}
function* pairs(i) {
  var iter = i[Symbol.iterator]();
  var first = iter.next();
  if (first.done) return;
  var lh = first;
  var rh = iter.next();

  while (!rh.done) {
    yield [lh.value, rh.value];
    lh = rh;
    rh = iter.next();
  }
}
function* take(c, count) {
  if (count < 0) return;
  var iter = c[Symbol.iterator]();

  while (count > 0) {
    var next = iter.next();
    if (next.done) return;
    yield next.value;
    count--;
  }
}
function skip(i, count) {
  var iter = i[Symbol.iterator]();

  while (count > 0) {
    var v = iter.next();
    if (v.done) break;
    count--;
  }

  return {
    [Symbol.iterator]: () => {
      return {
        next: () => {
          return iter.next();
        }
      };
    }
  };
}
function skipWhile(i, f) {
  var iter = i[Symbol.iterator]();

  for (;;) {
    var v = iter.next();
    if (v.done || !f(v.value)) break;
  }

  return {
    [Symbol.iterator]: () => {
      return {
        next: () => {
          return iter.next();
        }
      };
    }
  };
}
function* rect(w, h) {
  if (w < 0) throw new Error(w + " < 0");
  if (h < 0) throw new Error(h + " < 0");

  for (var y = 0; y < h; y++) {
    for (var x = 0; x < w; x++) {
      yield [x, y];
    }
  }
}
function intersect(lh, rh) {
  return new Set([...lh].filter(t => rh.has(t)));
}
function* interpolate(ii, f, points) {
  if (points === void 0) {
    points = [0.5];
  }

  var i = ii[Symbol.iterator]();
  var lh = i.next();
  if (lh.done) return;
  yield lh.value;
  var rh = i.next();

  while (!rh.done) {
    for (var p of points) {
      yield f(lh.value, rh.value, p);
    }

    yield rh.value;
    lh = rh;
    rh = i.next();
  }
}

/***/ }),

/***/ "./src/utils/color.ts":
/*!****************************!*\
  !*** ./src/utils/color.ts ***!
  \****************************/
/*! exports provided: rgb2hsl, hsl2rgb, rgb2xyz, xyz2rgb, xyz2lab, convertPal, labDist, findLab, resizeIndexed, convoluteIndexed, ditherMatrix, dither, rgb2lum, scale2x */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2hsl", function() { return rgb2hsl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl2rgb", function() { return hsl2rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2xyz", function() { return rgb2xyz; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2rgb", function() { return xyz2rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2lab", function() { return xyz2lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertPal", function() { return convertPal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labDist", function() { return labDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findLab", function() { return findLab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeIndexed", function() { return resizeIndexed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convoluteIndexed", function() { return convoluteIndexed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ditherMatrix", function() { return ditherMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dither", function() { return dither; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2lum", function() { return rgb2lum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale2x", function() { return scale2x; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "./src/utils/collections.ts");
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mathutils */ "./src/utils/mathutils.ts");


function rgb2hsl(r, g, b) {
  var rd = r / 255.0;
  var gd = g / 255.0;
  var bd = b / 255.0;
  var max = Math.max(rd, gd, bd);
  var min = Math.min(rd, gd, bd);
  var l = (max + min) / 2.0;
  var delta = max - min;
  var s = 0;
  var h = 0;

  if (max != min) {
    s = delta / (1 - Math.abs(2 * l - 1));
    if (max == rd) h = 42.5 * (gd - bd) / delta;else if (max == gd) h = 42.5 * ((bd - rd) / delta + 2);else h = 42.5 * ((rd - gd) / delta + 4);
    if (h < 0) h += 255;
  }

  return [Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(h), Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(s * 255), Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(l * 255)];
}
function hsl2rgb(h, s, l) {
  if (s == 0) return [l, l, l];
  var lf = l / 255.0;
  var sf = s / 255.0;
  var c = (1 - Math.abs(2 * lf - 1)) * sf;
  var x = c * (1 - Math.abs(h / 42.5 % 2 - 1));
  var m = lf - c / 2;
  var r = 0,
      g = 0,
      b = 0;

  if (h >= 0 && h < 42.5) {
    r = c;
    g = x;
    b = 0;
  } else if (h >= 42.5 && h <= 42.5 * 2) {
    r = x;
    g = c;
    b = 0;
  } else if (h >= 42.5 * 2 && h <= 42.5 * 3) {
    r = 0;
    g = c;
    b = x;
  } else if (h >= 42.5 * 3 && h <= 42.5 * 4) {
    r = 0;
    g = x;
    b = c;
  } else if (h >= 42.5 * 4 && h <= 42.5 * 5) {
    r = x;
    g = 0;
    b = c;
  } else if (h >= 42.5 * 5 && h <= 42.5 * 6) {
    r = c;
    g = 0;
    b = x;
  }

  return [Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])((r + m) * 255), Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])((g + m) * 255), Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])((b + m) * 255)];
}
function rgb2xyz(r, g, b) {
  return [(r * 0.49 + g * 0.31 + b * 0.2) / 0.17697, (r * 0.17697 + g * 0.8124 + b * 0.01063) / 0.17697, (r * 0 + g * 0.01 + b * 0.99) / 0.17697];
}
function xyz2rgb(x, y, z) {
  return [x * 0.41847 + y * -0.15866 + z * -0.082835, x * -0.091169 + y * 0.25243 + z * 0.015708, x * 0.00092090 + y * -0.0025498 + z * 0.1786];
}
var xn = 95.047;
var yn = 100;
var zn = 108.883;
var c = Math.pow(6 / 29, 3);

function f(t) {
  if (t > c) return Math.pow(t, 1 / 3);else return 1 / 3 * Math.pow(29 / 6, 2) * t + 4 / 29;
}

function xyz2lab(x, y, z) {
  return [116 * f(y / yn) - 16, 500 * (f(x / xn) - f(y / yn)), 200 * (f(y / yn) - f(z / zn))];
}
function convertPal(srcPal, conv) {
  var dst = new Array(256 * 3);

  for (var i = 0; i < 256; i++) {
    var off = i * 3;
    var r = conv(srcPal[off + 0], srcPal[off + 1], srcPal[off + 2]);
    dst[off + 0] = r[0];
    dst[off + 1] = r[1];
    dst[off + 2] = r[2];
  }

  return dst;
}
function labDist(pal, color, l, a, b) {
  var off = color * 3;
  var dh = l - pal[off + 0];
  var ds = a - pal[off + 1];
  var dl = b - pal[off + 2];
  return Math.sqrt(dh * dh + ds * ds + dl * dl);
}
function findLab(pal, l, a, b) {
  var mindist = Number.MAX_VALUE;
  var mindist1 = Number.MAX_VALUE;
  var idx = 0;
  var idx1 = 0;

  for (var i = 0; i < 256; i++) {
    var off = i * 3;
    var dh = l - pal[off + 0];
    var ds = a - pal[off + 1];
    var dl = b - pal[off + 2];
    var dist = Math.sqrt(dh * dh + ds * ds + dl * dl);

    if (dist < mindist) {
      mindist1 = mindist;
      idx1 = idx;
      mindist = dist;
      idx = i;
    }
  }

  return [idx, idx1, mindist / mindist1];
}
function resizeIndexed(dstw, dsth, srcw, srch, src, pal, labpal) {
  var dst = new Uint8Array(dstw * dsth);
  var dx = srcw / dstw;
  var dy = srch / dsth;

  for (var [x, y] of Object(_collections__WEBPACK_IMPORTED_MODULE_0__["rect"])(dstw, dsth)) {
    dst[y * dstw + x] = convoluteIndexed(x * dx, y * dy, dx, dy, srcw, src, pal, labpal);
  }

  return dst;
}
function convoluteIndexed(x, y, w, h, imgw, img, pal, labpal) {
  if (w == Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(w) && h == Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(h) && x == Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(x) && y == Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(y)) {
    var sum = [0, 0, 0];
    var trans = 0;
    var colors = new Set();

    for (var [xx, yy] of Object(_collections__WEBPACK_IMPORTED_MODULE_0__["rect"])(w, h)) {
      var off = (yy + y) * imgw + xx + x;
      var color = img[off] * 3;

      if (color == 255 * 3) {
        trans++;
        if (trans > w * h / 2) return 255;
      } else {
        sum[0] += pal[color + 0];
        sum[1] += pal[color + 1];
        sum[2] += pal[color + 2];
        colors.add(color / 3);
      }
    }

    var weight = 1 / (w * h - trans);
    var xyz = rgb2xyz(sum[0] * weight, sum[1] * weight, sum[2] * weight);
    var lab = xyz2lab(xyz[0], xyz[1], xyz[2]);
    var mindist = Number.MAX_VALUE;
    var mindist1 = Number.MAX_VALUE;
    var idx = 0;
    var idx1 = 0;

    for (var _color of colors) {
      var dist = labDist(labpal, _color, lab[0], lab[1], lab[2]);

      if (mindist > dist) {
        idx1 = idx;
        mindist1 = mindist;
        idx = _color;
        mindist = dist;
      }
    }

    var [i, i1, t] = findLab(labpal, lab[0], lab[1], lab[2]);
    var d = labDist(labpal, i, lab[0], lab[1], lab[2]); // return dither(x, y, t, ditherMatrix) ? i : i1;

    return d / mindist < 0.2 ? i : dither(x, y, mindist / mindist1, ditherMatrix) ? idx : idx1;
  } else {
    return img[Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(y + h / 2) * imgw + Object(_mathutils__WEBPACK_IMPORTED_MODULE_1__["int"])(x + w / 2)];
  }
}

function scale3resample(x, y, w, h, src) {
  var px = Math.min(x + 1, w - 1);
  var mx = Math.max(x - 1, 0);
  var py = Math.min(y + 1, h - 1);
  var my = Math.max(y - 1, 0);
  return 0;
}

var ditherMatrix = [0, 32, 8, 40, 2, 34, 10, 42, 48, 16, 56, 24, 50, 18, 58, 26, 12, 44, 4, 36, 14, 46, 6, 38, 60, 28, 52, 20, 62, 30, 54, 22, 3, 35, 11, 43, 1, 33, 9, 41, 51, 19, 59, 27, 49, 17, 57, 25, 15, 47, 7, 39, 13, 45, 5, 37, 63, 31, 55, 23, 61, 29, 53, 21];
function dither(x, y, t, matrix) {
  var size = matrix.length;
  var rsize = 1 / size;
  if (t < 0.0 + rsize / 2) return true;
  if (t > 1.0 - rsize / 2) return false;
  var sqrsize = Math.sqrt(size);
  var idx = y % sqrsize * sqrsize + x % sqrsize;
  var d = matrix[idx] / (size - 1);
  return t <= d;
}
function rgb2lum(r, g, b) {
  return r * 0.2126 + g * 0.7152 + b * 0.0722;
}
function scale2x(width, height, src) {
  var dst = new Uint8Array(4 * width * height);

  for (var [x, y] of Object(_collections__WEBPACK_IMPORTED_MODULE_0__["rect"])(width, height)) {
    var px = Math.min(x + 1, width - 1);
    var mx = Math.max(x - 1, 0);
    var py = Math.min(y + 1, height - 1);
    var my = Math.max(y - 1, 0);
    var _b = src[my * width + x];
    var d = src[y * width + mx];
    var e = src[y * width + x];
    var _f = src[y * width + px];
    var h = src[py * width + x];

    if (_b != h && d != _f) {
      dst[y * width * 4 + x * 2] = d == _b ? d : e;
      dst[y * width * 4 + x * 2 + 1] = _b == _f ? _f : e;
      dst[(y * 2 + 1) * width * 2 + x * 2] = d == h ? d : e;
      dst[(y * 2 + 1) * width * 2 + x * 2 + 1] = h == _f ? _f : e;
    } else {
      dst[y * width * 4 + x * 2] = dst[y * width * 4 + x * 2 + 1] = dst[(y * 2 + 1) * width * 2 + x * 2] = dst[(y * 2 + 1) * width * 2 + x * 2 + 1] = e;
    }
  }

  return dst;
}

/***/ }),

/***/ "./src/utils/filesave.ts":
/*!*******************************!*\
  !*** ./src/utils/filesave.ts ***!
  \*******************************/
/*! exports provided: save, saveAs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAs", function() { return saveAs; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var save = function () {
  var a = document.createElement("a");
  document.body.appendChild(a);
  a.style.display = 'none';
  return function (buffer, fileName) {
    var url = window.URL.createObjectURL(new Blob([buffer], {
      type: "octet/stream"
    }));
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  };
}();
function saveAs(_x, _x2) {
  return _saveAs.apply(this, arguments);
}

function _saveAs() {
  _saveAs = _asyncToGenerator(function* (buffer, fileName) {
    var opts = {
      type: 'save-file',
      accepts: [{
        description: 'BUILD Map',
        extensions: ['map']
      }]
    };
    var handle = yield window['chooseFileSystemEntries'](opts);
    var writable = yield handle.createWritable();
    yield writable.write(buffer);
    yield writable.close();
  });
  return _saveAs.apply(this, arguments);
}

/***/ }),

/***/ "./src/utils/getter.ts":
/*!*****************************!*\
  !*** ./src/utils/getter.ts ***!
  \*****************************/
/*! exports provided: loadBin, loadString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadBin", function() { return loadBin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadString", function() { return loadString; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function loadBin(_x) {
  return _loadBin.apply(this, arguments);
}

function _loadBin() {
  _loadBin = _asyncToGenerator(function* (fname) {
    var r = yield fetch(fname);
    return r.ok ? r.arrayBuffer() : null;
  });
  return _loadBin.apply(this, arguments);
}

function loadString(_x2) {
  return _loadString.apply(this, arguments);
}

function _loadString() {
  _loadString = _asyncToGenerator(function* (fname) {
    var r = yield fetch(fname);
    return r.ok ? r.text() : null;
  });
  return _loadString.apply(this, arguments);
}

/***/ }),

/***/ "./src/utils/gl/buffergl.ts":
/*!**********************************!*\
  !*** ./src/utils/gl/buffergl.ts ***!
  \**********************************/
/*! exports provided: BufferBuilder, Buffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferBuilder", function() { return BufferBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return Buffer; });
/* harmony import */ var _bufferimpl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bufferimpl */ "./src/utils/gl/bufferimpl.ts");
/* harmony import */ var _bag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bag */ "./src/utils/bag.ts");



class Pointerimpl {
  constructor(buffer, vtx, idx) {
    this.buffer = buffer;
    this.vtx = vtx;
    this.idx = idx;
  }

}

class BufferBuilder {
  constructor(size) {
    if (size === void 0) {
      size = 64 * 1024;
    }

    this.vtxBuffers = [];
    this.size = size;
  }

  addVertexBuffer(gl, type, spacing) {
    this.vtxBuffers.push(Object(_bufferimpl__WEBPACK_IMPORTED_MODULE_0__["createVertexBuffer"])(gl, type, this.size, spacing));
    return this;
  }

}
class Buffer {
  constructor(gl, builder, blockSize) {
    if (blockSize === void 0) {
      blockSize = 1024;
    }

    this.vtxBag = void 0;
    this.idxBag = void 0;
    this.vtxBuffers = void 0;
    this.idxBuffer = void 0;
    this.vtxRegions = [];
    this.idxRegions = [];
    this.needUpdate = true;
    this.blockSize = blockSize;
    var vtxSize = builder.size;
    var idxSize = vtxSize * 2;
    this.vtxBuffers = builder.vtxBuffers;
    this.idxBuffer = Object(_bufferimpl__WEBPACK_IMPORTED_MODULE_0__["createIndexBuffer"])(gl, gl.UNSIGNED_SHORT, idxSize);
    this.vtxBag = Object(_bag__WEBPACK_IMPORTED_MODULE_1__["createController"])(vtxSize, (place, noffset) => {
      for (var v of this.vtxBuffers) {
        var buff = v.getData();
        var spacing = v.getSpacing();
        buff.set(buff.subarray(place.offset * spacing, (place.offset + place.size) * spacing), noffset * spacing);
      }

      var ptr = place.data;
      var offdiff = noffset - place.offset;
      var idxData = this.idxBuffer.getData();

      for (var i = 0; i < ptr.size; i++) {
        idxData[ptr.offset + i] += offdiff;
      }
    });
    this.idxBag = Object(_bag__WEBPACK_IMPORTED_MODULE_1__["createController"])(idxSize, (place, noffset) => {
      var idxData = this.idxBuffer.getData();
      idxData.set(idxData.subarray(place.offset, place.offset + place.size), noffset);
    });

    for (var i = 0; i < this.vtxBuffers.length; i++) {
      this.vtxRegions.push([]);
    }
  }

  getVertexBuffer(idx) {
    return this.vtxBuffers[idx];
  }

  getIndexBuffer() {
    return this.idxBuffer;
  }

  allocate(vtxs, idxs) {
    var vtx = this.vtxBag.get(vtxs);
    if (vtx == null) return null;
    var idx = this.idxBag.get(idxs);

    if (idx == null) {
      this.vtxBag.put(vtx);
      return null;
    }

    vtx.data = idx;
    return new Pointerimpl(this, vtx, idx);
  }

  deallocate(ptr) {
    if (ptr.buffer != this) throw new Error('Invalid Buffer for this Pointer');
    this.vtxBag.put(ptr.vtx);
    this.idxBag.put(ptr.idx);
  }

  writeVertex(ptr, idx, off, vdata) {
    var buff = this.vtxBuffers[idx];
    var offset = (ptr.vtx.offset + off) * buff.getSpacing();
    var data = buff.getData();

    for (var i = 0; i < vdata.length; i++) {
      data[offset + i] = vdata[i];
    }

    this.vtxRegions[idx].push([offset / buff.getSpacing(), Math.ceil(vdata.length / buff.getSpacing())]);
    this.needUpdate = true;
  }

  writeIndex(ptr, off, idata) {
    var buff = this.idxBuffer;
    var offset = ptr.idx.offset + off;
    var vtxoff = ptr.vtx.offset;
    var data = buff.getData();

    for (var i = 0; i < idata.length; i++) {
      data[offset + i] = idata[i] + vtxoff;
    }

    this.idxRegions.push([offset, idata.length]);
    this.needUpdate = true;
  }

  mergeRegions(regions, i) {
    var region = regions[i];

    for (;;) {
      if (i + 1 >= regions.length) break;
      var currentend = region[0] + region[1];
      var nextstart = regions[i + 1][0];
      var diff = nextstart - currentend;
      if (diff < 0 || diff > this.blockSize) break;
      region[1] += regions[++i][1] + diff;
    }

    return [i, region];
  }

  updateBuffer(gl, buffer, regions) {
    for (var i = 0; i < regions.length; i++) {
      var [ii, region] = this.mergeRegions(regions, i);
      i = ii; // PROFILE.get(null).inc('traffic', region[1]);
      // PROFILE.get(null).inc('updates');

      buffer.updateRegion(gl, region[0], region[1]);
    }

    return true;
  }

  update(gl) {
    if (!this.needUpdate) return;

    for (var v = 0; v < this.vtxBuffers.length; v++) {
      if (this.vtxRegions[v].length == 0) continue;
      this.updateBuffer(gl, this.vtxBuffers[v], this.vtxRegions[v]);
      this.vtxRegions[v] = [];
    }

    if (this.idxRegions.length != 0) {
      this.updateBuffer(gl, this.idxBuffer, this.idxRegions);
      this.idxRegions = [];
    }

    this.needUpdate = false; // PROFILE.get(null).set('buffer', this.vtxBag.freeSpace(64));
  }

}

/***/ }),

/***/ "./src/utils/gl/bufferimpl.ts":
/*!************************************!*\
  !*** ./src/utils/gl/bufferimpl.ts ***!
  \************************************/
/*! exports provided: VertexBufferImpl, genIndexBuffer, GlType2ArrayType, ArrayType2GlType, VertexBufferDynamic, DynamicIndexBuffer, createVertexBuffer, wrap, createIndexBuffer, wrapIndexBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexBufferImpl", function() { return VertexBufferImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genIndexBuffer", function() { return genIndexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlType2ArrayType", function() { return GlType2ArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayType2GlType", function() { return ArrayType2GlType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexBufferDynamic", function() { return VertexBufferDynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicIndexBuffer", function() { return DynamicIndexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVertexBuffer", function() { return createVertexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIndexBuffer", function() { return createIndexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapIndexBuffer", function() { return wrapIndexBuffer; });
class VertexBufferImpl {
  constructor(buffer, type, spacing, normalized, stride, offset) {
    if (spacing === void 0) {
      spacing = 3;
    }

    if (normalized === void 0) {
      normalized = false;
    }

    if (stride === void 0) {
      stride = 0;
    }

    if (offset === void 0) {
      offset = 0;
    }

    this.buffer = buffer;
    this.type = type;
    this.spacing = spacing;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
  }

  getBuffer() {
    return this.buffer;
  }

  getType() {
    return this.type;
  }

  getSpacing() {
    return this.spacing;
  }

  getNormalized() {
    return this.normalized;
  }

  getStride() {
    return this.stride;
  }

  getOffset() {
    return this.offset;
  }

}

class IndexBufferImpl {
  constructor(buffer, type) {
    this.buffer = buffer;
    this.type = type;
  }

  getBuffer() {
    return this.buffer;
  }

  getType() {
    return this.type;
  }

}

function genIndexBuffer(gl, count, pattern) {
  var bufIdx = gl.createBuffer();
  var len = pattern.length;
  var size = Math.max.apply(null, pattern) + 1;
  var data = new Uint16Array(count * len);

  for (var i = 0; i < count; i++) {
    var off = i * len;
    var off1 = i * size;

    for (var j = 0; j < len; j++) {
      data[off + j] = off1 + pattern[j];
    }
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.buffer, gl.STATIC_DRAW);
  return new IndexBufferImpl(bufIdx, gl.UNSIGNED_SHORT);
}
function GlType2ArrayType(glType) {
  switch (glType) {
    case WebGLRenderingContext.BYTE:
      return Int8Array;

    case WebGLRenderingContext.UNSIGNED_BYTE:
      return Uint8Array;

    case WebGLRenderingContext.SHORT:
      return Int16Array;

    case WebGLRenderingContext.UNSIGNED_SHORT:
      return Uint16Array;

    case WebGLRenderingContext.INT:
      return Int32Array;

    case WebGLRenderingContext.UNSIGNED_INT:
      return Uint32Array;

    case WebGLRenderingContext.FLOAT:
      return Float32Array;

    default:
      throw new Error('Unknown GL Type: ' + glType);
  }
}
function ArrayType2GlType(arrayType) {
  switch (arrayType) {
    case Int8Array:
      return WebGLRenderingContext.BYTE;

    case Uint8Array:
      return WebGLRenderingContext.UNSIGNED_BYTE;

    case Int16Array:
      return WebGLRenderingContext.SHORT;

    case Uint16Array:
      return WebGLRenderingContext.UNSIGNED_SHORT;

    case Int32Array:
      return WebGLRenderingContext.INT;

    case Uint32Array:
      return WebGLRenderingContext.UNSIGNED_INT;

    case Float32Array:
      return WebGLRenderingContext.FLOAT;

    default:
      throw new Error('Unknown Array Type: ' + arrayType);
  }
}
class VertexBufferDynamic extends VertexBufferImpl {
  constructor(gl, type, data, spacing, usage, normalized) {
    if (usage === void 0) {
      usage = WebGLRenderingContext.STREAM_DRAW;
    }

    if (normalized === void 0) {
      normalized = false;
    }

    super(gl.createBuffer(), type, spacing, normalized, 0, 0);
    this.data = void 0;
    this.data = data;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.getBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, this.data, usage);
  }

  getData() {
    return this.data;
  }

  update(gl) {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.getBuffer());
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.data);
  }

  updateRegion(gl, offset, length) {
    var sizeof = this.data.BYTES_PER_ELEMENT * this.getSpacing();
    var region = new Uint8Array(this.data.buffer, offset * sizeof, length * sizeof);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.getBuffer());
    gl.bufferSubData(gl.ARRAY_BUFFER, offset * sizeof, region);
  }

}
class DynamicIndexBuffer extends IndexBufferImpl {
  constructor(gl, data, type, usage) {
    if (type === void 0) {
      type = WebGLRenderingContext.UNSIGNED_SHORT;
    }

    if (usage === void 0) {
      usage = WebGLRenderingContext.STREAM_DRAW;
    }

    super(gl.createBuffer(), type);
    this.data = void 0;
    this.data = data;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.getBuffer());
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.data, usage);
  }

  update(gl, length) {
    if (length === void 0) {
      length = 0;
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.getBuffer());
    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, this.data);
  }

  updateRegion(gl, offset, length) {
    var sizeof = 2;
    var region = new Uint8Array(this.data.buffer, offset * sizeof, length * sizeof);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.getBuffer());
    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset * sizeof, region);
  }

  getData() {
    return this.data;
  }

}
function createVertexBuffer(gl, type, data, spacing, usage, norm) {
  if (usage === void 0) {
    usage = WebGLRenderingContext.DYNAMIC_DRAW;
  }

  if (norm === void 0) {
    norm = false;
  }

  var arrtype = GlType2ArrayType(type);
  if (typeof data == 'number') data = new arrtype(data * spacing);else if (arrtype != data.constructor) throw new Error('GL Type and ArrayBuffer is incompatible');
  return new VertexBufferDynamic(gl, type, data, spacing, usage, norm);
}
function wrap(gl, data, spacing, usage, norm) {
  if (usage === void 0) {
    usage = WebGLRenderingContext.STREAM_DRAW;
  }

  if (norm === void 0) {
    norm = false;
  }

  return new VertexBufferDynamic(gl, ArrayType2GlType(data.constructor), data, spacing, usage, norm);
}
function createIndexBuffer(gl, type, data, usage) {
  if (usage === void 0) {
    usage = WebGLRenderingContext.STREAM_DRAW;
  }

  var arrtype = GlType2ArrayType(type);
  if (typeof data == 'number') data = new arrtype(data);else if (arrtype != data.constructor) throw new Error('GL Type and ArrayBuffer is incompatible');
  return new DynamicIndexBuffer(gl, data, type, usage);
}
function wrapIndexBuffer(gl, data, usage) {
  if (usage === void 0) {
    usage = WebGLRenderingContext.STREAM_DRAW;
  }

  return new DynamicIndexBuffer(gl, data, ArrayType2GlType(data.constructor), usage);
}

/***/ }),

/***/ "./src/utils/gl/gl.ts":
/*!****************************!*\
  !*** ./src/utils/gl/gl.ts ***!
  \****************************/
/*! exports provided: createContextFromCanvas, createContext, animate, readId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContextFromCanvas", function() { return createContextFromCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return createContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animate", function() { return animate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readId", function() { return readId; });
function createContextFromCanvas(id, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var canvas = document.getElementById(id);
  var gl = canvas.getContext('webgl2', opts);
  return gl;
}
function createContext(w, h, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  canvas.id = 'gl';
  var gl = canvas.getContext('webgl2', opts);
  document.body.appendChild(canvas);
  document.body.style.overflow = 'hidden';
  canvas.style.position = 'absolute';
  return gl;
}

function resize(gl) {
  var canvas = gl.canvas;
  var displayWidth = canvas.clientWidth;
  var displayHeight = canvas.clientHeight;

  if (canvas.width != displayWidth || canvas.height != displayHeight) {
    canvas.width = displayWidth;
    canvas.height = displayHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
}

function animate(gl, callback) {
  var time = new Date().getTime();

  function update() {
    resize(gl);
    var now = new Date().getTime();
    callback(gl, (now - time) / 1000);
    requestAnimationFrame(update);
    time = now;
  }

  update();
}
var pixel = new Uint8Array(4);
function readId(gl, x, y) {
  gl.readPixels(x, gl.drawingBufferHeight - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  return pixel[0] | pixel[1] << 8 | pixel[2] << 16
  /*| pixel[3]<<24*/
  ;
}

/***/ }),

/***/ "./src/utils/gl/shaders.ts":
/*!*********************************!*\
  !*** ./src/utils/gl/shaders.ts ***!
  \*********************************/
/*! exports provided: ShaderImpl, createShader, DefinitionImpl, Definitions, setUniform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderImpl", function() { return ShaderImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShader", function() { return createShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefinitionImpl", function() { return DefinitionImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Definitions", function() { return Definitions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUniform", function() { return setUniform; });
/* harmony import */ var _getter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../getter */ "./src/utils/getter.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


class ShaderImpl {
  constructor(gl, prog, defs) {
    this.program = void 0;
    this.definitions = void 0;
    this.uniforms = [];
    this.attribs = [];
    this.uniformIndex = {};
    this.attributeIndex = {};
    this.program = prog;
    this.definitions = defs;
    this.initUniformLocations(gl);
    this.initAttributeLocations(gl);
  }

  initUniformLocations(gl) {
    for (var i = 0; i < this.definitions.uniforms.length; i++) {
      var uniform = this.definitions.uniforms[i];
      this.uniformIndex[uniform.name] = i;
      this.uniforms[i] = gl.getUniformLocation(this.program, uniform.name);
    }
  }

  initAttributeLocations(gl) {
    for (var i = 0; i < this.definitions.attributes.length; i++) {
      var attrib = this.definitions.attributes[i];
      this.attributeIndex[attrib.name] = i;
      this.attribs[i] = gl.getAttribLocation(this.program, attrib.name);
    }
  }

  getUniformLocation(name, gl) {
    return this.uniforms[this.uniformIndex[name]];
  }

  getAttributeLocation(name, gl) {
    return this.attribs[this.attributeIndex[name]];
  }

  getProgram() {
    return this.program;
  }

  getUniforms() {
    return this.definitions.uniforms;
  }

  getAttributes() {
    return this.definitions.attributes;
  }

  getSamplers() {
    return this.definitions.samplers;
  }

}
function createShader(_x, _x2, _x3) {
  return _createShader.apply(this, arguments);
}

function _createShader() {
  _createShader = _asyncToGenerator(function* (gl, name, defines) {
    if (defines === void 0) {
      defines = [];
    }

    var deftext = '#version 300 es\n' + defines.map(d => "#define " + d).join("\n") + "\n";
    return Promise.all([Object(_getter__WEBPACK_IMPORTED_MODULE_0__["loadString"])(name + '.vsh'), Object(_getter__WEBPACK_IMPORTED_MODULE_0__["loadString"])(name + '.fsh')]).then((_ref) => {
      var [vsh, fsh] = _ref;
      return Promise.all([preprocess(vsh), preprocess(fsh)]).then((_ref2) => {
        var [pvhs, pfsh] = _ref2;
        var program = compileProgram(gl, deftext + pvhs, deftext + pfsh);
        var defs = processShaders(gl, program);
        return new ShaderImpl(gl, program, defs);
      });
    });
  });
  return _createShader.apply(this, arguments);
}

function compileProgram(gl, vsh, fsh) {
  var program = gl.createProgram();
  gl.attachShader(program, compileSource(gl, gl.VERTEX_SHADER, vsh));
  gl.attachShader(program, compileSource(gl, gl.FRAGMENT_SHADER, fsh));
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw new Error('link error: ' + gl.getProgramInfoLog(program));
  return program;
}

function compileSource(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw new Error('compile error: ' + gl.getShaderInfoLog(shader) + '\nin source:\n' + source);
  return shader;
}

class DefinitionImpl {
  constructor(type, name) {
    this.type = type;
    this.name = name;
  }

}
class Definitions {
  constructor() {
    this.uniforms = [];
    this.attributes = [];
    this.samplers = [];
  }

}

function processShaders(gl, program) {
  var defs = new Definitions();
  var attribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

  for (var a = 0; a < attribs; a++) {
    var info = gl.getActiveAttrib(program, a);
    defs.attributes.push(convertToDefinition(info));
  }

  var uniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

  for (var u = 0; u < uniforms; u++) {
    var _info = gl.getActiveUniform(program, u);

    var def = convertToDefinition(_info);
    defs.uniforms.push(def);
    if (def.type == 'sampler2D') defs.samplers.push(def);
  }

  return defs;
}

function convertToDefinition(info) {
  return new DefinitionImpl(type2String(info.type), info.name);
}

function type2String(type) {
  switch (type) {
    case WebGLRenderingContext.SAMPLER_2D:
      return "sampler2D";

    case WebGLRenderingContext.INT:
      return "int";

    case WebGLRenderingContext.FLOAT:
      return "float";

    case WebGLRenderingContext.FLOAT_MAT4:
      return "mat4";

    case WebGLRenderingContext.FLOAT_MAT3:
      return "mat3";

    case WebGLRenderingContext.FLOAT_VEC2:
      return "vec2";

    case WebGLRenderingContext.FLOAT_VEC3:
      return "vec3";

    case WebGLRenderingContext.FLOAT_VEC4:
      return "vec4";

    case WebGLRenderingContext.INT_VEC2:
      return "ivec2";

    case WebGLRenderingContext.INT_VEC3:
      return "ivec3";

    case WebGLRenderingContext.INT_VEC4:
      return "ivec4";

    default:
      throw new Error('Invalid type: ' + type);
  }
}

function preprocess(_x4) {
  return _preprocess.apply(this, arguments);
}

function _preprocess() {
  _preprocess = _asyncToGenerator(function* (shader) {
    var lines = shader.split("\n");
    var includes = [];

    for (var i = 0; i < lines.length; i++) {
      var l = lines[i];
      var m = l.match(/^#include +"([^"]+)"/);
      includes.push(m != null ? Object(_getter__WEBPACK_IMPORTED_MODULE_0__["loadString"])(m[1]) : Promise.resolve(l));
    }

    return Promise.all(includes).then(lines => lines.join('\n'));
  });
  return _preprocess.apply(this, arguments);
}

var setters = {
  mat4: (gl, loc, val) => gl.uniformMatrix4fv(loc, false, val),
  ivec2: (gl, loc, val) => gl.uniform2iv(loc, val),
  vec2: (gl, loc, val) => gl.uniform2fv(loc, val),
  vec3: (gl, loc, val) => gl.uniform3fv(loc, val),
  vec4: (gl, loc, val) => gl.uniform4fv(loc, val),
  int: (gl, loc, val) => gl.uniform1i(loc, val),
  float: (gl, loc, val) => gl.uniform1f(loc, val),
  sampler2D: (gl, loc, val) => gl.uniform1i(loc, val)
};
function setUniform(gl, shader, uniform, value) {
  if (uniform == undefined) return;
  var loc = shader.getUniformLocation(uniform.name, gl);
  var setter = setters[uniform.type];
  if (setter == undefined) throw new Error('Invalid type: ' + uniform.type);
  setter(gl, loc, value);
}

/***/ }),

/***/ "./src/utils/gl/stategl.ts":
/*!*********************************!*\
  !*** ./src/utils/gl/stategl.ts ***!
  \*********************************/
/*! exports provided: Profile, State, DrawCall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Profile", function() { return Profile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawCall", function() { return DrawCall; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collections */ "./src/utils/collections.ts");
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders */ "./src/utils/gl/shaders.ts");
/* harmony import */ var _statevalue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./statevalue */ "./src/utils/gl/statevalue.ts");





function createStateValue(type, changecb) {
  switch (type) {
    case "mat4":
    case "vec3":
    case "vec4":
      return new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueMatrix"](changecb, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__[type].create(), _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__[type].exactEquals, _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__[type].copy);

    default:
      return new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueGeneric"](changecb, 0);
  }
}

class Profile {
  constructor() {
    this.drawsRequested = 0;
    this.drawsMerged = 0;
    this.shaderChanges = 0;
    this.uniformChanges = 0;
    this.textureChanges = 0;
    this.bufferChanges = 0;
    this.shaderSwaps = {};
    this.uniqTextures = new Set();
  }

  changeShader(from, to) {
    var key = from + "->" + to;
    var swap = this.shaderSwaps[key];
    this.shaderSwaps[key] = !swap ? 1 : swap + 1;
  }

  changeTexture(tex) {
    this.uniqTextures.add(tex);
  }

  reset() {
    this.drawsRequested = 0;
    this.drawsMerged = 0;
    this.shaderChanges = 0;
    this.uniformChanges = 0;
    this.textureChanges = 0;
    this.bufferChanges = 0;
    this.shaderSwaps = {};
    this.uniqTextures.clear();
  }

}

function nextBatch(batch) {
  var nb = batch + 0.05;
  return nb > 1.0 ? 0 : nb;
}

class ShaderConfig {
  constructor(shader, uniforms, attribs, samplers) {
    this.shader = shader;
    this.uniforms = uniforms;
    this.attribs = attribs;
    this.samplers = samplers;
  }

}

class State {
  constructor() {
    this.profile = new Profile();
    this.batchUniform = -1;
    this.lastBuffer = void 0;
    this.shader = new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueGeneric"](() => this.changeShader = true, null);
    this.lastShader = void 0;
    this.selectedShader = void 0;
    this.indexBuffer = new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueGeneric"](() => this.changeIndexBuffer = true, null);
    this.shaders = {};
    this.states = [];
    this.stateIndex = {};
    this.attribs = [];
    this.attribNames = [];
    this.attribIndex = {};
    this.uniforms = [];
    this.uniformDefinitions = [];
    this.uniformIndex = {};
    this.textures = [];
    this.textureIndex = {};
    this.changeShader = true;
    this.changeIndexBuffer = true;
    this.changedVertexBuffersIds = new _collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.changedTextures = new _collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.changedUniformIdxs = new _collections__WEBPACK_IMPORTED_MODULE_1__["Deck"]();
    this.chainOffset = -1;
    this.chainSize = -1;
    this.chainMode = -1;
    this.registerState('shader', this.shader);
    this.registerState('aIndex', this.indexBuffer);
  }

  nextBatch() {
    if (this.batchUniform == -1) {
      this.batchUniform = this.getState('sys');
    }

    var value = [...this.states[this.batchUniform].get()];
    value[3] = nextBatch(value[3]);
    this.states[this.batchUniform].set(value);
  }

  flush(gl, buffer) {
    if (buffer === void 0) {
      buffer = this.lastBuffer;
    }

    if (this.chainMode == -1) return;
    if (buffer) buffer.update(gl);
    gl.drawElements(this.chainMode, this.chainSize, gl.UNSIGNED_SHORT, this.chainOffset * 2); // this.nextBatch();

    this.chainMode = -1;
    this.lastBuffer = null;
  }

  tryChain(gl, buffer, offset, size, mode) {
    if (this.chainMode == -1) {
      this.chainMode = mode;
      this.chainOffset = offset;
      this.chainSize = size;
      this.lastBuffer = buffer;
      return false;
    } else if (this.sameState(mode)) {
      if (this.chainOffset == offset + size) {
        this.chainOffset = offset;
        this.chainSize += size;
        return true;
      } else if (this.chainOffset + this.chainSize == offset) {
        this.chainSize += size;
        return true;
      }
    }

    this.flush(gl);
    return this.tryChain(gl, buffer, offset, size, mode);
  }

  sameState(mode) {
    return this.chainMode == mode && !this.changeShader && !this.changeIndexBuffer && Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedUniformIdxs) && Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedTextures) && Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedVertexBuffersIds);
  }

  registerUniforms(shader) {
    var _this = this;

    var uniforms = [];

    var _loop = function _loop(uniform) {
      var existedId = _this.uniformIndex[uniform.name];

      if (existedId != undefined) {
        uniforms.push(existedId);
        return "continue";
      }

      var idx = _this.uniforms.length;
      var state = createStateValue(uniform.type, () => _this.changedUniformIdxs.push(idx));
      if (uniform.type != 'sampler2D') _this.registerState(uniform.name, state);

      _this.uniforms.push(state);

      _this.uniformDefinitions.push(uniform);

      _this.uniformIndex[uniform.name] = idx;
      uniforms.push(idx);
    };

    for (var uniform of shader.getUniforms()) {
      var _ret = _loop(uniform);

      if (_ret === "continue") continue;
    }

    return uniforms;
  }

  registerSamplers(shader) {
    var _this2 = this;

    var samplers = shader.getSamplers();
    var shaderSamplers = [];

    var _loop2 = function _loop2(s) {
      var sampler = samplers[s];
      var existedId = _this2.textureIndex[sampler.name];

      if (existedId != undefined) {
        shaderSamplers.push([existedId, s]);
        return "continue";
      }

      ;
      var idx = _this2.textures.length;
      var key = [idx, s];
      var state = new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueGeneric"](() => _this2.changedTextures.push(key), null);

      _this2.registerState(sampler.name, state);

      _this2.textures.push(state);

      _this2.textureIndex[sampler.name] = idx;
      shaderSamplers.push(key);
    };

    for (var s = 0; s < samplers.length; s++) {
      var _ret2 = _loop2(s);

      if (_ret2 === "continue") continue;
    }

    return shaderSamplers;
  }

  registerAttributes(shader) {
    var _this3 = this;

    var attribs = [];

    var _loop3 = function _loop3(attrib) {
      var existedId = _this3.attribIndex[attrib.name];

      if (existedId != undefined) {
        attribs.push(existedId);
        return "continue";
      }

      var idx = _this3.attribs.length;
      var state = new _statevalue__WEBPACK_IMPORTED_MODULE_3__["StateValueGeneric"](() => _this3.changedVertexBuffersIds.push(idx), null);

      _this3.registerState(attrib.name, state);

      _this3.attribNames[idx] = attrib.name;

      _this3.attribs.push(state);

      _this3.attribIndex[attrib.name] = idx;
      attribs.push(idx);
    };

    for (var attrib of shader.getAttributes()) {
      var _ret3 = _loop3(attrib);

      if (_ret3 === "continue") continue;
    }

    return attribs;
  }

  registerShader(name, shader) {
    var uniforms = this.registerUniforms(shader);
    var attribs = this.registerAttributes(shader);
    var samplers = this.registerSamplers(shader);
    this.shaders[name] = new ShaderConfig(shader, uniforms, attribs, samplers);
  }

  registerState(name, state) {
    if (this.stateIndex[name] != undefined) throw new Error("Duplicate state name " + name);
    var idx = this.states.length;
    this.states.push(state);
    this.stateIndex[name] = idx;
  }

  getState(name) {
    var idx = this.stateIndex[name];
    if (idx == undefined) throw new Error("Invalid state name " + name);
    return idx;
  }

  setUniform(name, value) {
    this.getUniformValue(name).set(value);
  }

  getUniformValue(name) {
    var u = this.uniformIndex[name];
    if (u == undefined) throw new Error('Invalid uniform name: ' + name);
    return this.uniforms[u];
  }

  isUniformEnabled(name) {
    return this.uniformIndex[name] != undefined;
  }

  setShader(name) {
    var s = this.shaders[name];
    if (s == undefined) throw new Error('Unknown shader: ' + name);
    this.shader.set(name);
  }

  setTexture(name, tex) {
    this.getTextureValue(name).set(tex);
  }

  getTextureValue(name) {
    var t = this.textureIndex[name];
    if (t == undefined) throw new Error('Invalid sampler name: ' + name);
    return this.textures[t];
  }

  setIndexBuffer(b) {
    this.indexBuffer.set(b);
  }

  setVertexBuffer(name, b) {
    this.getVertexBufferValue(name).set(b);
  }

  getVertexBufferValue(name) {
    var a = this.attribIndex[name];
    if (a == undefined) throw new Error("Invalid attribute name " + name);
    return this.attribs[a];
  }

  rebindShader(gl) {
    if (!this.changeShader) return;
    ++this.profile.shaderChanges;
    var newShader = this.shader.get();
    this.profile.changeShader(this.lastShader, newShader);
    this.lastShader = newShader;
    var shaderConfig = this.shaders[newShader];
    var shader = shaderConfig.shader;
    this.selectedShader = shader;
    gl.useProgram(shader.getProgram());
    var samplers = shader.getSamplers();

    for (var s = 0; s < samplers.length; s++) {
      var sampler = samplers[s];
      this.setUniform(sampler.name, s);
    }

    this.changedUniformIdxs.clear().pushAll(shaderConfig.uniforms);
    this.changedVertexBuffersIds.clear().pushAll(shaderConfig.attribs);
    this.changedTextures.clear().pushAll(shaderConfig.samplers);
    this.changeShader = false;
    this.changeIndexBuffer = true;
  }

  rebindVertexBuffers(gl) {
    if (Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedVertexBuffersIds)) return;
    var vertexBufferIdxs = this.changedVertexBuffersIds;
    var len = vertexBufferIdxs.length();
    var shader = this.selectedShader;

    for (var a = 0; a < len; a++) {
      var idx = vertexBufferIdxs.get(a);
      var buf = this.attribs[idx];
      var vbuf = buf.get();
      var location = shader.getAttributeLocation(this.attribNames[idx], gl);
      if (location == -1) continue;
      gl.bindBuffer(gl.ARRAY_BUFFER, vbuf.getBuffer());
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, vbuf.getSpacing(), vbuf.getType(), vbuf.getNormalized(), vbuf.getStride(), vbuf.getOffset());
    }

    vertexBufferIdxs.clear();
  }

  rebindIndexBuffer(gl) {
    if (!this.changeIndexBuffer) return;
    ++this.profile.bufferChanges;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer.get().getBuffer());
    this.changeIndexBuffer = false;
  }

  rebindTextures(gl) {
    if (Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedTextures)) return;
    var textures = this.changedTextures;
    var len = textures.length();
    this.profile.textureChanges += len;

    for (var t = 0; t < len; t++) {
      var [idx, sampler] = textures.get(t);
      var texture = this.textures[idx];

      if (texture != undefined && texture.get() != null) {
        this.profile.changeTexture(texture.get());
        gl.activeTexture(gl.TEXTURE0 + sampler);
        gl.bindTexture(gl.TEXTURE_2D, texture.get().get());
      }
    }

    textures.clear();
  }

  updateUniforms(gl) {
    if (Object(_collections__WEBPACK_IMPORTED_MODULE_1__["isEmpty"])(this.changedUniformIdxs)) return;
    var uniformsIdxs = this.changedUniformIdxs;
    var len = uniformsIdxs.length();
    this.profile.uniformChanges += len;

    for (var u = 0; u < len; u++) {
      var idx = uniformsIdxs.get(u);
      var state = this.uniforms[idx];
      _shaders__WEBPACK_IMPORTED_MODULE_2__["setUniform"](gl, this.selectedShader, this.uniformDefinitions[idx], state.get());
    }

    uniformsIdxs.clear();
  }

  draw(gl, buffer, offset, size, mode) {
    if (mode === void 0) {
      mode = gl.TRIANGLES;
    }

    ++this.profile.drawsRequested;

    if (this.tryChain(gl, buffer, offset, size, mode)) {
      ++this.profile.drawsMerged;
      return;
    }

    this.rebindShader(gl);
    this.rebindVertexBuffers(gl);
    this.rebindIndexBuffer(gl);
    this.updateUniforms(gl);
    this.rebindTextures(gl);
  }

  run(gl, call) {
    var values = call.values;
    var size = call.values.length;

    for (var i = 0; i < size; i += 2) {
      var idx = values[i];
      var value = values[i + 1];
      this.states[idx].set(value);
    }

    this.draw(gl, call.buffer, call.offset, call.size, call.mode);
  }

}
class DrawCall {
  constructor(values, buffer, offset, size, mode, hint, kind) {
    this.values = values;
    this.buffer = buffer;
    this.offset = offset;
    this.size = size;
    this.mode = mode;
    this.hint = hint;
    this.kind = kind;
  }

}

/***/ }),

/***/ "./src/utils/gl/statevalue.ts":
/*!************************************!*\
  !*** ./src/utils/gl/statevalue.ts ***!
  \************************************/
/*! exports provided: StateValueGeneric, StateValueMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateValueGeneric", function() { return StateValueGeneric; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateValueMatrix", function() { return StateValueMatrix; });
class StateValueGeneric {
  constructor(changecb, value) {
    this.changecb = changecb;
    this.value = value;
  }

  get() {
    return this.value;
  }

  set(v) {
    if (v !== this.value) {
      this.value = v;
      this.changecb();
    }
  }

}
class StateValueMatrix {
  constructor(changecb, value, cmp, setter) {
    this.changecb = changecb;
    this.value = value;
    this.cmp = cmp;
    this.setter = setter;
  }

  get() {
    return this.value;
  }

  set(v) {
    if (!this.cmp(v, this.value)) {
      this.setter(this.value, v);
      this.changecb();
    }
  }

}

/***/ }),

/***/ "./src/utils/gl/textures.ts":
/*!**********************************!*\
  !*** ./src/utils/gl/textures.ts ***!
  \**********************************/
/*! exports provided: TextureStub, TextureImpl, createTexture, DrawTexture, createDrawTexture, RenderTexture, createRenderTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureStub", function() { return TextureStub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureImpl", function() { return TextureImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTexture", function() { return createTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawTexture", function() { return DrawTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDrawTexture", function() { return createDrawTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderTexture", function() { return RenderTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRenderTexture", function() { return createRenderTexture; });
class TextureStub {
  constructor(w, h) {
    this.w = w;
    this.h = h;
  }

  get() {
    return null;
  }

  getWidth() {
    return this.w;
  }

  getHeight() {
    return this.h;
  }

  getFormat() {
    return null;
  }

  getType() {
    return null;
  }

}

function getMagFilter(filter) {
  switch (filter) {
    case WebGLRenderingContext.NEAREST:
    case WebGLRenderingContext.NEAREST_MIPMAP_LINEAR:
    case WebGLRenderingContext.NEAREST_MIPMAP_NEAREST:
      return WebGLRenderingContext.NEAREST;

    case WebGLRenderingContext.LINEAR:
    case WebGLRenderingContext.LINEAR_MIPMAP_LINEAR:
    case WebGLRenderingContext.LINEAR_MIPMAP_NEAREST:
      return WebGLRenderingContext.LINEAR;
  }
}

class TextureImpl {
  constructor(width, height, gl, options, img, format, bpp) {
    if (options === void 0) {
      options = {};
    }

    if (img === void 0) {
      img = null;
    }

    if (format === void 0) {
      format = gl.RGBA;
    }

    if (bpp === void 0) {
      bpp = 4;
    }

    this.id = void 0;
    this.width = void 0;
    this.height = void 0;
    this.format = void 0;
    this.type = void 0;
    this.data = void 0;
    this.id = gl.createTexture();
    this.width = width;
    this.height = height;
    this.format = format;
    this.type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, getMagFilter(options.filter || gl.NEAREST));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.filter || gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.repeat || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.repeat || gl.CLAMP_TO_EDGE);

    if (options.aniso) {
      var ext = gl.getExtension('EXT_texture_filter_anisotropic');
      var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
    }

    if (img == null) img = new Uint8Array(width * height * bpp);
    this.data = img;
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, this.data);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  get() {
    return this.id;
  }

  getWidth() {
    return this.width;
  }

  getHeight() {
    return this.height;
  }

  getFormat() {
    return this.format;
  }

  getType() {
    return this.type;
  }

  reload(gl) {
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this.getFormat(), this.getType(), this.data);
  }

  mip(gl, level, width, height, data) {
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texImage2D(gl.TEXTURE_2D, level, this.format, width, height, 0, this.format, this.type, data);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

}
function createTexture(width, height, gl, options, img, format, bpp) {
  if (options === void 0) {
    options = {};
  }

  if (img === void 0) {
    img = null;
  }

  if (format === void 0) {
    format = gl.RGBA;
  }

  if (bpp === void 0) {
    bpp = 4;
  }

  return new TextureImpl(width, height, gl, options, img, format, bpp);
}
class DrawTexture extends TextureImpl {
  constructor(width, height, gl, options, img, format, bpp) {
    if (options === void 0) {
      options = {};
    }

    if (img === void 0) {
      img = null;
    }

    if (format === void 0) {
      format = gl.RGBA;
    }

    if (bpp === void 0) {
      bpp = 4;
    }

    super(width, height, gl, options, img, format, bpp);
  }

  putPixel(x, y, pixel, gl) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, 1, 1, this.getFormat(), this.getType(), pixel);
  }

  putSubImage(x, y, w, h, img, gl) {
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, w, h, this.getFormat(), this.getType(), img);
  }

}
function createDrawTexture(width, height, gl, options, img, format, bpp) {
  if (options === void 0) {
    options = {};
  }

  if (img === void 0) {
    img = null;
  }

  if (format === void 0) {
    format = gl.RGBA;
  }

  if (bpp === void 0) {
    bpp = 4;
  }

  return new DrawTexture(width, height, gl, options, img, format, bpp);
}
class RenderTexture extends TextureImpl {
  constructor(width, height, gl, options, img) {
    if (options === void 0) {
      options = {};
    }

    if (img === void 0) {
      img = null;
    }

    super(width, height, gl, options, img);
    this.framebuffer = void 0;
    this.renderbuffer = void 0;
    this.framebuffer = gl.createFramebuffer();
    this.renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.getWidth(), this.getHeight());
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }

  drawTo(gl, callback) {
    var v = gl.getParameter(gl.VIEWPORT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
    gl.viewport(0, 0, this.getWidth(), this.getHeight());
    callback(gl);
    gl.readPixels(0, 0, this.getWidth(), this.getHeight(), gl.RGBA, gl.UNSIGNED_BYTE, this.data);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.viewport(v[0], v[1], v[2], v[3]);
    return this.data;
  }

}
function createRenderTexture(width, height, gl, options, img) {
  if (options === void 0) {
    options = {};
  }

  if (img === void 0) {
    img = null;
  }

  return new RenderTexture(width, height, gl, options, img);
}

/***/ }),

/***/ "./src/utils/imglib.ts":
/*!*****************************!*\
  !*** ./src/utils/imglib.ts ***!
  \*****************************/
/*! exports provided: INDEXED_IMG_LIB, IndexedImgLibJsConstructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INDEXED_IMG_LIB", function() { return INDEXED_IMG_LIB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IndexedImgLibJsConstructor", function() { return IndexedImgLibJsConstructor; });
/* harmony import */ var _injector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./injector */ "./src/utils/injector.ts");
/* harmony import */ var _app_modules_artselector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app/modules/artselector */ "./src/app/modules/artselector.ts");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color */ "./src/utils/color.ts");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collections */ "./src/utils/collections.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


 // import init, { ImgLib } from "../libs_js/wasm_lib";



var INDEXED_IMG_LIB = new _injector__WEBPACK_IMPORTED_MODULE_0__["Dependency"]('IndexedImgLib'); // export async function IndexedImgLibWasmConstructor(injector: Injector): Promise<IndexedImgLib> {
//   const pal = await injector.getInstance(RAW_PAL);
//   await init();
//   let lib = ImgLib.init(pal, 256, 255);
//   return {
//     palettize: (w: number, h: number, img: Uint8Array) => {
//       const dst = new Uint8Array(w * h);
//       lib.palettize(w, h, img, dst);
//       return dst;
//     },
//     resize: (dstw: number, dsth: number, srcw: number, srch: number, src: Uint8Array) => {
//       const dst = new Uint8Array(dstw * dsth);
//       lib.resize(dstw, dsth, dst, srcw, srch, src);
//       return dst;
//     }
//   }
// }

function IndexedImgLibJsConstructor(_x) {
  return _IndexedImgLibJsConstructor.apply(this, arguments);
}

function _IndexedImgLibJsConstructor() {
  _IndexedImgLibJsConstructor = _asyncToGenerator(function* (injector) {
    var pal = [...(yield injector.getInstance(_app_modules_artselector__WEBPACK_IMPORTED_MODULE_1__["RAW_PAL"]))];
    var xyzpal = Object(_color__WEBPACK_IMPORTED_MODULE_2__["convertPal"])(pal, _color__WEBPACK_IMPORTED_MODULE_2__["rgb2xyz"]);
    var labpal = Object(_color__WEBPACK_IMPORTED_MODULE_2__["convertPal"])(xyzpal, _color__WEBPACK_IMPORTED_MODULE_2__["xyz2lab"]);
    return {
      palettize: (w, h, img) => {
        var dst = new Uint8Array(w * h);

        for (var [x, y] of Object(_collections__WEBPACK_IMPORTED_MODULE_3__["rect"])(w, h)) {
          var idx = y * w + x;
          var r = img[idx * 4];
          var g = img[idx * 4 + 1];
          var b = img[idx * 4 + 2];
          var xyz = Object(_color__WEBPACK_IMPORTED_MODULE_2__["rgb2xyz"])(r, g, b);
          var lab = Object(_color__WEBPACK_IMPORTED_MODULE_2__["xyz2lab"])(xyz[0], xyz[1], xyz[2]);
          dst[idx] = Object(_color__WEBPACK_IMPORTED_MODULE_2__["findLab"])(labpal, lab[0], lab[1], lab[2])[0];
        }

        return dst;
      },
      resize: (dstw, dsth, srcw, srch, src) => {
        return Object(_color__WEBPACK_IMPORTED_MODULE_2__["resizeIndexed"])(dstw, dsth, srcw, srch, src, pal, labpal);
      }
    };
  });
  return _IndexedImgLibJsConstructor.apply(this, arguments);
}

/***/ }),

/***/ "./src/utils/imgutils.ts":
/*!*******************************!*\
  !*** ./src/utils/imgutils.ts ***!
  \*******************************/
/*! exports provided: createEmptyCanvas, createCanvas, drawToCanvas, clearCanvas, loadImageFromBuffer, loadImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmptyCanvas", function() { return createEmptyCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawToCanvas", function() { return drawToCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearCanvas", function() { return clearCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImageFromBuffer", function() { return loadImageFromBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony import */ var _pixelprovider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pixelprovider */ "./src/utils/pixelprovider.ts");

function createEmptyCanvas(width, height) {
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createCanvas(provider, blend) {
  if (blend === void 0) {
    blend = _pixelprovider__WEBPACK_IMPORTED_MODULE_0__["BlendNormal"];
  }

  var canvas = document.createElement('canvas');
  canvas.width = provider.getWidth();
  canvas.height = provider.getHeight();
  drawToCanvas(provider, canvas.getContext('2d'), 0, 0, blend);
  return canvas;
}
function drawToCanvas(provider, ctx, x, y, blend) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  if (blend === void 0) {
    blend = _pixelprovider__WEBPACK_IMPORTED_MODULE_0__["BlendNormal"];
  }

  var data;
  var id;

  if (blend === _pixelprovider__WEBPACK_IMPORTED_MODULE_0__["BlendNormal"]) {
    data = new Uint8ClampedArray(provider.getWidth() * provider.getHeight() * 4);
    id = new ImageData(data, provider.getWidth(), provider.getHeight());
  } else {
    id = ctx.getImageData(x, y, provider.getWidth(), provider.getHeight());
    data = id.data;
  }

  provider.render(data, blend);
  ctx.putImageData(id, x, y);
}
function clearCanvas(canvas, style) {
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = style;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
function loadImageFromBuffer(buff) {
  return new Promise(resolve => {
    var blob = new Blob([buff]);
    var urlCreator = window.URL;
    var imageUrl = urlCreator.createObjectURL(blob);
    var img = new Image();
    img.src = imageUrl;

    img.onload = evt => {
      var img = evt.target;
      var canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      var data = new Uint8Array(ctx.getImageData(0, 0, img.width, img.height).data);
      resolve([img.width, img.height, data]);
    };
  });
}
function loadImage(name) {
  return new Promise(resolve => {
    var image = new Image();
    image.src = name;

    image.onload = evt => {
      var img = evt.target;
      var canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      resolve([img.width, img.height, new Uint8Array(ctx.getImageData(0, 0, img.width, img.height).data)]);
    };
  });
}

/***/ }),

/***/ "./src/utils/injector.ts":
/*!*******************************!*\
  !*** ./src/utils/injector.ts ***!
  \*******************************/
/*! exports provided: Dependency, CircularDependencyError, RootModule, create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dependency", function() { return Dependency; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircularDependencyError", function() { return CircularDependencyError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootModule", function() { return RootModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class Dependency {
  constructor(name, multi) {
    if (multi === void 0) {
      multi = false;
    }

    this.name = name;
    this.multi = multi;
  }

}
class CircularDependencyError extends Error {
  constructor(dependencies) {
    super();
    this.name = 'CircularDependencyError';
    this.stack = super.stack;
    this.dependencies = dependencies;
  }

  get message() {
    return 'Circular dependency detected while trying to resolve ' + this.dependencies.join(' -> ');
  }

}

class ChildInjector {
  constructor(dependency, parent) {
    this.dependency = dependency;
    this.parent = parent;
  }

  getInstanceParent(dependency, injector) {
    return this.parent.getInstanceParent(dependency, injector);
  }

  getInstance(dependency) {
    return this.parent.getInstanceParent(dependency, this);
  }

}

class DependencyNode {
  constructor(label) {
    this.dependencies = new Set();
    this.label = label;
  }

}

class Graph {
  constructor() {
    this.nodes = new Map();
  }

  ensureNode(label) {
    var node = this.nodes.get(label);

    if (node == undefined) {
      node = new DependencyNode(label);
      this.nodes.set(label, node);
    }

    return node;
  }

  add(o, i) {
    this.ensureNode(o).dependencies.add(this.ensureNode(i));
  }

  checkCycles() {
    var colors = new Map();

    var paint = function paint(node) {
      colors.set(node.label, 'gray');

      for (var child of node.dependencies) {
        var c = colors.get(child.label);

        if (c == undefined) {
          try {
            paint(child);
          } catch (e) {
            if (e instanceof CircularDependencyError) e.dependencies.unshift(child.label);
            throw e;
          }
        } else if (c == 'gray') throw new CircularDependencyError([child.label]);
      }

      colors.set(node.label, 'black');
    };

    for (var [_label, node] of this.nodes) {
      if (colors.has(_label)) continue;
      paint(node);
    }
  }

}

class RootModule {
  constructor() {
    this.providers = new Map();
    this.promises = new Map();
    this.executables = [];
  }

  bind(dependency, provider) {
    var p = this.providers.get(dependency);

    if (dependency.multi) {
      if (p == undefined) {
        p = [];
        this.providers.set(dependency, p);
      }

      p.push(provider);
    } else {
      if (p != undefined) throw new Error("Multiple bindings to dependency " + dependency.name);
      this.providers.set(dependency, [provider]);
    }
  }

  bindInstance(dependency, instance) {
    this.promises.set(dependency, Promise.resolve(instance));
  }

  install(submodule) {
    submodule(this);
  }

  execute(executable) {
    this.executables.push(executable);
  }

  start() {
    var injector = new RootInjector(this.providers, this.promises);

    for (var e of this.executables) {
      e(injector);
    }
  }

}

class RootInjector {
  constructor(providers, promises) {
    this.graph = new Graph();
    this.providers = providers;
    this.promises = promises;
  }

  add(dependency, injector) {
    var chain = [dependency.name];
    var current = injector;

    while (current instanceof ChildInjector) {
      chain.unshift(current.dependency.name);
      current = current.parent;
    }

    for (var i = 0; i < chain.length - 1; i++) {
      this.graph.add(chain[i], chain[i + 1]);
    }

    this.graph.checkCycles();
  }

  getInstanceParent(dependency, injector) {
    this.add(dependency, injector);
    var instance = this.promises.get(dependency);

    if (instance == undefined) {
      instance = this.create(dependency, injector);
      this.promises.set(dependency, instance);
    }

    return instance;
  }

  getInstance(dependency) {
    return this.getInstanceParent(dependency, this);
  }

  create(dependency, parent) {
    var provider = this.providers.get(dependency);
    if (provider == null) throw new Error("No provider bound to " + dependency.name);
    var injector = new ChildInjector(dependency, parent);
    return dependency.multi ? Promise.all(provider.map(p => p(injector))) : provider[0](injector);
  }

}

function create(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
  return _create.apply(this, arguments);
}

function _create() {
  _create = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4, d5, d6, d7, d8) {
    if (d8 != undefined) return create8(i, ctr, d1, d2, d3, d4, d5, d6, d7, d8);
    if (d7 != undefined) return create7(i, ctr, d1, d2, d3, d4, d5, d6, d7);
    if (d6 != undefined) return create6(i, ctr, d1, d2, d3, d4, d5, d6);
    if (d5 != undefined) return create5(i, ctr, d1, d2, d3, d4, d5);
    if (d4 != undefined) return create4(i, ctr, d1, d2, d3, d4);
    if (d3 != undefined) return create3(i, ctr, d1, d2, d3);
    if (d2 != undefined) return create2(i, ctr, d1, d2);
    if (d1 != undefined) return create1(i, ctr, d1);
    throw new Error('Invalid create usage');
  });
  return _create.apply(this, arguments);
}

function create8(_x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19, _x20) {
  return _create2.apply(this, arguments);
}

function _create2() {
  _create2 = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4, d5, d6, d7, d8) {
    var [i1, i2, i3, i4, i5, i6, i7, i8] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3), i.getInstance(d4), i.getInstance(d5), i.getInstance(d6), i.getInstance(d7), i.getInstance(d8)]);
    return new ctr(i1, i2, i3, i4, i5, i6, i7, i8);
  });
  return _create2.apply(this, arguments);
}

function create7(_x21, _x22, _x23, _x24, _x25, _x26, _x27, _x28, _x29) {
  return _create3.apply(this, arguments);
}

function _create3() {
  _create3 = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4, d5, d6, d7) {
    var [i1, i2, i3, i4, i5, i6, i7] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3), i.getInstance(d4), i.getInstance(d5), i.getInstance(d6), i.getInstance(d7)]);
    return new ctr(i1, i2, i3, i4, i5, i6, i7);
  });
  return _create3.apply(this, arguments);
}

function create6(_x30, _x31, _x32, _x33, _x34, _x35, _x36, _x37) {
  return _create4.apply(this, arguments);
}

function _create4() {
  _create4 = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4, d5, d6) {
    var [i1, i2, i3, i4, i5, i6] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3), i.getInstance(d4), i.getInstance(d5), i.getInstance(d6)]);
    return new ctr(i1, i2, i3, i4, i5, i6);
  });
  return _create4.apply(this, arguments);
}

function create5(_x38, _x39, _x40, _x41, _x42, _x43, _x44) {
  return _create5.apply(this, arguments);
}

function _create5() {
  _create5 = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4, d5) {
    var [i1, i2, i3, i4, i5] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3), i.getInstance(d4), i.getInstance(d5)]);
    return new ctr(i1, i2, i3, i4, i5);
  });
  return _create5.apply(this, arguments);
}

function create4(_x45, _x46, _x47, _x48, _x49, _x50) {
  return _create6.apply(this, arguments);
}

function _create6() {
  _create6 = _asyncToGenerator(function* (i, ctr, d1, d2, d3, d4) {
    var [i1, i2, i3, i4] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3), i.getInstance(d4)]);
    return new ctr(i1, i2, i3, i4);
  });
  return _create6.apply(this, arguments);
}

function create3(_x51, _x52, _x53, _x54, _x55) {
  return _create7.apply(this, arguments);
}

function _create7() {
  _create7 = _asyncToGenerator(function* (i, ctr, d1, d2, d3) {
    var [i1, i2, i3] = yield Promise.all([i.getInstance(d1), i.getInstance(d2), i.getInstance(d3)]);
    return new ctr(i1, i2, i3);
  });
  return _create7.apply(this, arguments);
}

function create2(_x56, _x57, _x58, _x59) {
  return _create8.apply(this, arguments);
}

function _create8() {
  _create8 = _asyncToGenerator(function* (i, ctr, d1, d2) {
    var [i1, i2] = yield Promise.all([i.getInstance(d1), i.getInstance(d2)]);
    return new ctr(i1, i2);
  });
  return _create8.apply(this, arguments);
}

function create1(_x60, _x61, _x62) {
  return _create9.apply(this, arguments);
}

function _create9() {
  _create9 = _asyncToGenerator(function* (i, ctr, d1) {
    var i1 = yield i.getInstance(d1);
    return new ctr(i1);
  });
  return _create9.apply(this, arguments);
}

/***/ }),

/***/ "./src/utils/input.ts":
/*!****************************!*\
  !*** ./src/utils/input.ts ***!
  \****************************/
/*! exports provided: postFrame, bind, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postFrame", function() { return postFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return bind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
var named = {
  8: 'BACKSPACE',
  9: 'TAB',
  13: 'ENTER',
  16: 'SHIFT',
  27: 'ESCAPE',
  32: 'SPACE',
  37: 'LEFT',
  38: 'UP',
  39: 'RIGHT',
  40: 'DOWN',
  45: 'INSERT',
  46: 'DELETE'
};

function mapKeyCode(code) {
  return named[code] || (code >= 65 && code <= 90 ? String.fromCharCode(code) : null);
}

var state = {
  keys: {},
  keysPress: {},
  mouseButtons: [false, false, false],
  mouseClicks: [false, false, false],
  mouseX: 0,
  mouseY: 0,
  wheel: 0
};
function postFrame() {
  state.wheel = 0;
  state.mouseClicks[0] = false;
  state.mouseClicks[1] = false;
  state.mouseClicks[2] = false;
  state.keysPress = {};
}
function bind(canvas) {
  canvas.addEventListener('mousemove', e => mousemove(e));
  canvas.addEventListener('mouseup', e => mouseup(e));
  canvas.addEventListener('mousedown', e => mousedown(e));
  canvas.addEventListener('wheel', e => wheelevent(e));
  document.addEventListener('keyup', e => keyup(e));
  document.addEventListener('keydown', e => keydown(e));
}

function updateState(keys, e, state) {
  keys['ALT'] = e.altKey;
  keys['SHIFT'] = e.shiftKey;
  keys['CTRL'] = e.ctrlKey;
  var key = mapKeyCode(e.keyCode);
  if (key) keys[key] = state;
  keys[e.keyCode] = state;
  keys[e.key] = state;
}

function keydown(e) {
  if (e.target != document.body) return true;
  updateState(state.keys, e, true);
  updateState(state.keysPress, e, true);
  e.preventDefault();
  return false;
}

function keyup(e) {
  if (e.target != document.body) return true;
  updateState(state.keys, e, false);
  e.preventDefault();
  return false;
}

function mousemove(e) {
  state.mouseX = e.offsetX;
  state.mouseY = e.offsetY;
  return false;
}

function mouseup(e) {
  state.mouseButtons[e.button] = false;
  state.mouseClicks[e.button] = true;
  return false;
}

function mousedown(e) {
  state.mouseButtons[e.button] = true;
  return false;
}

function wheelevent(e) {
  state.wheel = e.deltaY > 0 ? 1 : -1;
  return false;
}

function get() {
  return state;
}

/***/ }),

/***/ "./src/utils/interpolator.ts":
/*!***********************************!*\
  !*** ./src/utils/interpolator.ts ***!
  \***********************************/
/*! exports provided: NumberInterpolator, Vec3Interpolator, Vec4Interpolator, Point, PointComparator, Range, binaryIndexOf1, binaryIndexOf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberInterpolator", function() { return NumberInterpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec3Interpolator", function() { return Vec3Interpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec4Interpolator", function() { return Vec4Interpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointComparator", function() { return PointComparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binaryIndexOf1", function() { return binaryIndexOf1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binaryIndexOf", function() { return binaryIndexOf; });
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list */ "./src/utils/list.ts");

var NumberInterpolator = (lh, rh, t) => {
  return lh + (rh - lh) * t;
};
var Vec3Interpolator = (lh, rh, t) => {
  return [lh[0] + (rh[0] - lh[0]) * t, lh[1] + (rh[1] - lh[1]) * t, lh[2] + (rh[2] - lh[2]) * t];
};
var Vec4Interpolator = (lh, rh, t) => {
  return [lh[0] + (rh[0] - lh[0]) * t, lh[1] + (rh[1] - lh[1]) * t, lh[2] + (rh[2] - lh[2]) * t, lh[3] + (rh[3] - lh[3]) * t];
};
class Point {
  constructor(val, pos, interpolator) {
    this.val = val;
    this.pos = pos;
    this.interpolator = interpolator;
  }

}
function PointComparator(lh, rh) {
  return lh.pos - rh.pos;
}
class Range {
  constructor(start, end, interpolator) {
    this.points = new _list__WEBPACK_IMPORTED_MODULE_0__["FastList"]();
    this.points.push(new Point(start, 0, interpolator));
    this.points.push(new Point(end, 1, null));
  }

  insert(val, t, interpolator) {
    var idx = binaryIndexOf1(this.points, new Point(null, t, null), PointComparator);
    this.points.insertAfter(new Point(val, t, interpolator), idx);
  }

  get(t) {
    if (t < 0) return this.points.get(this.points.next(0)).val;
    if (t > 1) return this.points.get(this.points.last(0)).val;
    var idx = binaryIndexOf1(this.points, new Point(null, t, null), PointComparator);
    var lh = this.points.get(idx);
    var rh = this.points.get(this.points.next(idx));
    var localT = (t - lh.pos) / (rh.pos - lh.pos);
    return lh.interpolator(lh.val, rh.val, localT);
  }

}

function advance(iter, list, steps) {
  for (var i = 0; i < steps; i++) {
    iter = list.next(iter);
  }

  return iter;
}

function length(list) {
  var length = 0;

  for (var i = 0; i != list.last(0); i = list.next(i)) {
    length++;
  }

  return length;
}

function binaryIndexOf1(list, searchElement, cmp) {
  var refMin = list.next(0);
  var min = list.next(0);
  var max = list.last(0);
  if (cmp(searchElement, list.get(min)) < 0 || cmp(searchElement, list.get(max)) > 0) return -1;
  var current = min;
  var currentElement = null;

  while (min != max) {
    current = advance(min, list, length(list) / 2 | 0);
    currentElement = list.get(current);
    var cmpVal = cmp(currentElement, searchElement);
    if (cmpVal < 0) min = list.next(current);else if (cmpVal > 0) max = list.last(current);else break;
  }

  return current == refMin ? refMin : current - 1;
}
function binaryIndexOf(arr, searchElement, cmp, minIndex, maxIndex) {
  if (minIndex === void 0) {
    minIndex = 0;
  }

  if (maxIndex === void 0) {
    maxIndex = arr.length() - 1;
  }

  var refMinIndex = minIndex;
  if (cmp(searchElement, arr.get(minIndex)) < 0 || cmp(searchElement, arr.get(maxIndex)) > 0) return -1;
  var currentIndex = 0;
  var currentElement = null;

  while (minIndex <= maxIndex) {
    currentIndex = (minIndex + maxIndex) / 2 | 0;
    currentElement = arr.get(currentIndex);
    var cmpVal = cmp(currentElement, searchElement);
    if (cmpVal < 0) minIndex = currentIndex + 1;else if (cmpVal > 0) maxIndex = currentIndex - 1;else break;
  }

  return currentIndex == refMinIndex ? refMinIndex : currentIndex - 1;
}

/***/ }),

/***/ "./src/utils/iter.ts":
/*!***************************!*\
  !*** ./src/utils/iter.ts ***!
  \***************************/
/*! exports provided: Iter, iter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Iter", function() { return Iter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iter", function() { return iter; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "./src/utils/collections.ts");

class Iter {
  static of(iter) {
    return new Iter(iter);
  }

  constructor(iter) {
    this.iter = iter;
  }

  [Symbol.iterator]() {
    return this.iter[Symbol.iterator]();
  }

  filter(f) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["filter"])(this.iter, f));
  }

  map(f) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["map"])(this.iter, f));
  }

  forEach(f) {
    Object(_collections__WEBPACK_IMPORTED_MODULE_0__["forEach"])(this.iter, f);
    return this;
  }

  enumerate() {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["enumerate"])(this.iter));
  }

  take(count) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["take"])(this.iter, count));
  }

  skip(count) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["skip"])(this.iter, count));
  }

  skipWhile(f) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["skipWhile"])(this.iter, f));
  }

  reduce(f, start) {
    return Object(_collections__WEBPACK_IMPORTED_MODULE_0__["reduce"])(this.iter, f, start);
  }

  all(f) {
    return Object(_collections__WEBPACK_IMPORTED_MODULE_0__["all"])(this.iter, f);
  }

  any(f) {
    return Object(_collections__WEBPACK_IMPORTED_MODULE_0__["any"])(this.iter, f);
  }

  isEmpty() {
    return Object(_collections__WEBPACK_IMPORTED_MODULE_0__["iterIsEmpty"])(this.iter);
  }

  first(f, def) {
    return Object(_collections__WEBPACK_IMPORTED_MODULE_0__["findFirst"])(this.iter, f, def);
  }

  chain(i) {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["chain"])(this.iter, i));
  }

  butLast() {
    return new Iter(Object(_collections__WEBPACK_IMPORTED_MODULE_0__["butLast"])(this.iter));
  }

  collect() {
    return [...this.iter];
  }

  set() {
    return new Set(this.iter);
  }

}
function iter(iter) {
  return Iter.of(iter);
}

/***/ }),

/***/ "./src/utils/lexer.ts":
/*!****************************!*\
  !*** ./src/utils/lexer.ts ***!
  \****************************/
/*! exports provided: LexerRule, Lexer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LexerRule", function() { return LexerRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
class LexerRule {
  constructor(pattern, name, mid, conv) {
    if (mid === void 0) {
      mid = 0;
    }

    if (conv === void 0) {
      conv = s => s;
    }

    this.id = null;
    this.pattern = pattern;
    this.name = name;
    this.mid = mid;
    this.conv = conv;
  }

}
class Lexer {
  constructor() {
    this.rulesIndex = {};
    this.rules = [];
    this.src = void 0;
    this.offset = 0;
    this.lastOffset = 0;
    this.eoi = false;
    this.matchedRule = null;
    this.matchedValue = null;
  }

  addRule(rule) {
    var r = this.rulesIndex[rule.name];

    if (r == undefined) {
      rule.id = this.rules.length;
      this.rules.push(rule);
    } else {
      throw new Error('Rule ' + rule.name + ' already exist');
    }

    this.rulesIndex[rule.name] = rule;
    return this;
  }

  mark() {
    return this.lastOffset;
  }

  reset(offset) {
    if (offset === void 0) {
      offset = 0;
    }

    this.offset = offset;
    this.lastOffset = offset;
    this.eoi = false;
    return this.next();
  }

  setSource(src) {
    this.src = src;
    this.offset = 0;
    this.eoi = false;
  }

  exec() {
    if (this.offset >= this.src.length) this.eoi = true;
    if (this.eoi) return null;
    var len = 0;
    var matchedValue = null;
    var matchedRule = null;
    var subsrc = this.src.substr(this.offset);

    for (var i = 0; i < this.rules.length; i++) {
      var rule = this.rules[i];
      var match = rule.pattern.exec(subsrc);

      if (match != null && match[0].length >= len) {
        matchedValue = match;
        matchedRule = rule;
        len = match[0].length;
      }
    }

    this.matchedRule = matchedRule;
    this.matchedValue = matchedValue;
    this.lastOffset = this.offset;
    this.offset += len;
    if (matchedRule == null) throw new Error('Unexpected input "' + subsrc.substr(0, 10) + '..."');
    return matchedRule.name;
  }

  next() {
    return this.exec();
  }

  rule() {
    return this.matchedRule;
  }

  value() {
    return this.rule().conv(this.matchedValue[this.rule().mid]);
  }

  isEoi() {
    return this.eoi;
  }

}

/***/ }),

/***/ "./src/utils/list.ts":
/*!***************************!*\
  !*** ./src/utils/list.ts ***!
  \***************************/
/*! exports provided: Node, List, FastList, SortedHeap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FastList", function() { return FastList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SortedHeap", function() { return SortedHeap; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "./src/utils/collections.ts");
var _Symbol$iterator, _Symbol$iterator2;


class Node {
  constructor(obj, next, prev) {
    if (obj === void 0) {
      obj = null;
    }

    if (next === void 0) {
      next = null;
    }

    if (prev === void 0) {
      prev = null;
    }

    this.obj = obj;
    this.next = next;
    this.prev = prev;
  }

}
_Symbol$iterator = Symbol.iterator;
class List {
  constructor() {
    this.nil = new Node();
    this.clear();
  }

  first() {
    return this.nil.next;
  }

  last() {
    return this.nil.prev;
  }

  terminator() {
    return this.nil;
  }

  pop() {
    var ret = this.last().obj;
    this.remove(this.last());
    return ret;
  }

  push(value) {
    return this.insertAfter(value);
  }

  pushAll(values) {
    var nodes = [];

    for (var i = 0; i < values.length; i++) {
      nodes.push(this.insertAfter(values[i]));
    }

    return nodes;
  }

  isEmpty() {
    return this.nil.next == this.nil;
  }

  insertNodeBefore(node, ref) {
    if (ref === void 0) {
      ref = this.nil.next;
    }

    node.next = ref;
    node.prev = ref.prev;
    node.prev.next = node;
    ref.prev = node;
    return node;
  }

  insertBefore(val, ref) {
    if (ref === void 0) {
      ref = this.nil.next;
    }

    return this.insertNodeBefore(new Node(val), ref);
  }

  insertNodeAfter(node, ref) {
    if (ref === void 0) {
      ref = this.nil.prev;
    }

    node.next = ref.next;
    node.next.prev = node;
    ref.next = node;
    node.prev = ref;
    return node;
  }

  insertAfter(val, ref) {
    if (ref === void 0) {
      ref = this.nil.prev;
    }

    return this.insertNodeAfter(new Node(val), ref);
  }

  remove(ref) {
    if (ref == this.nil) return;
    ref.next.prev = ref.prev;
    ref.prev.next = ref.next;
    return ref;
  }

  clear() {
    this.nil.next = this.nil;
    this.nil.prev = this.nil;
  }

  [_Symbol$iterator]() {
    var pointer = this.first();
    return pointer == this.terminator() ? _collections__WEBPACK_IMPORTED_MODULE_0__["EMPTY_ITERATOR"] : {
      next: () => {
        if (pointer == this.terminator()) return _collections__WEBPACK_IMPORTED_MODULE_0__["TERMINAL_ITERATOR_RESULT"];else {
          var obj = pointer.obj;
          pointer = pointer.next;
          return {
            done: false,
            value: obj
          };
        }
      }
    };
  }

}
_Symbol$iterator2 = Symbol.iterator;
class FastList {
  constructor() {
    this.elements = new _collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.nextIdx = new _collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.lastIdx = new _collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.clear();
  }

  insertAfter(value, after) {
    if (after === void 0) {
      after = this.lastIdx.get(0);
    }

    var idx = this.elements.length();
    var next = this.nextIdx.get(after);
    this.elements.push(value);
    this.nextIdx.push(next);
    this.lastIdx.push(after);
    this.nextIdx.set(after, idx);
    this.lastIdx.set(next, idx);
    return idx;
  }

  insertBefore(value, before) {
    if (before === void 0) {
      before = this.nextIdx.get(0);
    }

    var idx = this.elements.length();
    var last = this.lastIdx.get(before);
    this.elements.push(value);
    this.nextIdx.push(before);
    this.lastIdx.push(last);
    this.nextIdx.set(last, idx);
    this.lastIdx.set(before, idx);
    return idx;
  }

  remove(idx) {
    if (idx <= 0 || idx >= this.elements.length() - 1 || this.nextIdx.get(idx) == -1) return null;
    this.nextIdx.set(this.lastIdx.get(idx), this.nextIdx.get(idx));
    this.lastIdx.set(this.nextIdx.get(idx), this.lastIdx.get(idx));
    this.nextIdx.set(idx, -1);
    return this.elements.get(idx);
  }

  pop() {
    var lastId = this.last(0);
    var last = this.get(lastId);
    this.remove(lastId);
    return last;
  }

  get(idx) {
    return this.elements.get(idx);
  }

  next(idx) {
    return this.nextIdx.get(idx);
  }

  last(idx) {
    return this.lastIdx.get(idx);
  }

  push(value) {
    this.insertAfter(value);
  }

  first() {
    return this.next(0);
  }

  clear() {
    this.elements.clear().push(null);
    this.nextIdx.clear().push(0);
    this.lastIdx.clear().push(0);
  }

  [_Symbol$iterator2]() {
    var pointer = this.first();
    return pointer == 0 ? _collections__WEBPACK_IMPORTED_MODULE_0__["EMPTY_ITERATOR"] : {
      next: () => {
        if (pointer == 0) return _collections__WEBPACK_IMPORTED_MODULE_0__["TERMINAL_ITERATOR_RESULT"];else {
          var obj = this.get(pointer);
          pointer = this.next(pointer);
          return {
            done: false,
            value: obj
          };
        }
      }
    };
  }

}

function advance(iter, list, steps) {
  for (var i = 0; i < steps; i++) {
    iter = list.next(iter);
  }

  return iter;
}

function length(list, from, to) {
  var length = 0;

  for (var i = from; i != to; i = list.next(i)) {
    length++;
  }

  return length;
}

function binaryIndexOf(list, searchElement) {
  var refMin = list.first();
  var min = list.first();
  var max = list.last(0);
  if (searchElement < list.get(min)) return 0;
  if (searchElement >= list.get(max)) return max;
  var current = min;
  var currentElement = null;
  var size = length(list, min, max);

  while (size > 0) {
    size -= size / 2 | 0;
    current = advance(min, list, size);
    currentElement = list.get(current);
    if (currentElement < searchElement) min = list.next(current);else if (currentElement > searchElement) max = list.last(current);else break;
    size--;
  }

  return current == refMin ? refMin : current;
}

class SortedHeap {
  constructor() {
    this.values = new FastList();
    this.sortValues = new FastList();
  }

  add(value, sortValue) {
    var ptr = binaryIndexOf(this.sortValues, sortValue);
    this.values.insertAfter(value, ptr);
    this.sortValues.insertAfter(sortValue, ptr);
  }

  clear() {
    this.values.clear();
    this.sortValues.clear();
  }

  get() {
    return this.values;
  }

}

/***/ }),

/***/ "./src/utils/logger.ts":
/*!*****************************!*\
  !*** ./src/utils/logger.ts ***!
  \*****************************/
/*! exports provided: ERROR, WARN, INFO, TRACE, DEBUG, error, warning, info, trace, debug, addLogAppender, CONSOLE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR", function() { return ERROR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WARN", function() { return WARN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INFO", function() { return INFO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE", function() { return TRACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG", function() { return DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "error", function() { return error; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warning", function() { return warning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "info", function() { return info; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trace", function() { return trace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLogAppender", function() { return addLogAppender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE", function() { return CONSOLE; });
var ERROR = 0;
var WARN = 1;
var INFO = 2;
var TRACE = 3;
var DEBUG = 4;
var appenders = [];

function write(level) {
  for (var _len = arguments.length, msg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    msg[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < appenders.length; i++) {
    appenders[i](level, ...msg);
  }
}

var error = function error() {
  for (var _len2 = arguments.length, msg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    msg[_key2] = arguments[_key2];
  }

  return write(ERROR, ...msg);
};
var warning = function warning() {
  for (var _len3 = arguments.length, msg = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    msg[_key3] = arguments[_key3];
  }

  return write(WARN, ...msg);
};
var info = function info() {
  for (var _len4 = arguments.length, msg = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    msg[_key4] = arguments[_key4];
  }

  return write(INFO, ...msg);
};
var trace = function trace() {
  for (var _len5 = arguments.length, msg = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    msg[_key5] = arguments[_key5];
  }

  return write(TRACE, ...msg);
};
var debug = function debug() {
  for (var _len6 = arguments.length, msg = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    msg[_key6] = arguments[_key6];
  }

  return write(DEBUG, ...msg);
};
function addLogAppender(appender) {
  appenders.push(appender);
}
var CONSOLE = function CONSOLE(level) {
  for (var _len7 = arguments.length, msg = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    msg[_key7 - 1] = arguments[_key7];
  }

  switch (level) {
    case ERROR:
      console.error(...msg);
      return;

    case WARN:
      console.warn(...msg);
      return;

    case INFO:
      console.info(...msg);
      return;

    case TRACE:
      console.trace(...msg);
      return;

    case DEBUG:
      console.debug(...msg);
      return;
  }
};

/***/ }),

/***/ "./src/utils/mathutils.ts":
/*!********************************!*\
  !*** ./src/utils/mathutils.ts ***!
  \********************************/
/*! exports provided: radsInDeg, degInRad, PI2, EPS, eq, lse, gte, deg2rad, rad2deg, sign, int, ispow2, fract, nextpow2, sqrLen2d, len2d, lenPointToLine, len3d, dot2d, cross2d, monoatan2, angInArc, arcsIntersects, cyclic, reverse, ubyte2byte, int2vec4, int2vec4norm, tuple, detuple0, detuple1, tuple2, tuple3, tuple4, productValue, minValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radsInDeg", function() { return radsInDeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degInRad", function() { return degInRad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PI2", function() { return PI2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPS", function() { return EPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eq", function() { return eq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lse", function() { return lse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gte", function() { return gte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int", function() { return int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ispow2", function() { return ispow2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fract", function() { return fract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextpow2", function() { return nextpow2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen2d", function() { return sqrLen2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len2d", function() { return len2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lenPointToLine", function() { return lenPointToLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len3d", function() { return len3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot2d", function() { return dot2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross2d", function() { return cross2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monoatan2", function() { return monoatan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angInArc", function() { return angInArc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arcsIntersects", function() { return arcsIntersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclic", function() { return cyclic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ubyte2byte", function() { return ubyte2byte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int2vec4", function() { return int2vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int2vec4norm", function() { return int2vec4norm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuple", function() { return tuple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detuple0", function() { return detuple0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detuple1", function() { return detuple1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuple2", function() { return tuple2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuple3", function() { return tuple3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuple4", function() { return tuple4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "productValue", function() { return productValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minValue", function() { return minValue; });
var radsInDeg = 180 / Math.PI;
var degInRad = Math.PI / 180;
var PI2 = Math.PI * 2;
var EPS = 1e-9;
function eq(lh, rh) {
  return Math.abs(lh - rh) < EPS;
}
function lse(lh, rh) {
  return eq(lh, rh) || lh < rh;
}
function gte(lh, rh) {
  return eq(lh, rh) || lh > rh;
}
function deg2rad(deg) {
  return deg * degInRad;
}
function rad2deg(rad) {
  return rad * radsInDeg;
}
function sign(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
}
function int(x) {
  return x | 0;
}
function ispow2(x) {
  return (x & x - 1) == 0;
}
function fract(x) {
  return x - int(x);
}
function nextpow2(x) {
  --x;

  for (var i = 1; i < 32; i <<= 1) {
    x = x | x >> i;
  }

  return x + 1;
}
function sqrLen2d(x, y) {
  return x * x + y * y;
}
function len2d(x, y) {
  return Math.sqrt(x * x + y * y);
}
function lenPointToLine(px, py, l1x, l1y, l2x, l2y) {
  var ldx = l2x - l1x;
  var ldy = l2y - l1y;
  var pdx = px - l1x;
  var pdy = py - l1y;
  var dot = dot2d(ldx, ldy, pdx, pdy);
  if (dot <= 0) return len2d(pdx, pdy);
  var llensqr = sqrLen2d(ldx, ldy);
  if (dot >= llensqr) return len2d(px - l2x, py - l2y);
  var t = dot / llensqr;
  return len2d(px - (l1x + ldx * t), py - (l1y + ldy * t));
}
function len3d(x, y, z) {
  return Math.sqrt(x * x + y * y + z * z);
}
function dot2d(x1, y1, x2, y2) {
  return x1 * x2 + y1 * y2;
}
function cross2d(x1, y1, x2, y2) {
  return x1 * y2 - y1 * x2;
}
function monoatan2(y, x) {
  var atan = Math.atan2(y, x);
  return atan < 0 ? 2 * Math.PI + atan : atan;
}
function angInArc(arcStart, arcEnd, ang) {
  return arcStart > arcEnd ? ang >= arcStart || ang <= arcEnd : ang >= arcStart && ang <= arcEnd;
}
function arcsIntersects(a1s, a1e, a2s, a2e) {
  return angInArc(a1s, a1e, a2s) || angInArc(a1s, a1e, a2e) || angInArc(a2s, a2e, a1s) || angInArc(a2s, a2e, a1e);
}
function cyclic(x, max) {
  var mod = x % max;
  return x >= 0 ? mod : mod == 0 ? max - 1 : max + mod;
}
function reverse(x, max) {
  return max - x;
}
function ubyte2byte(n) {
  var minus = (n & 0x80) != 0;
  return minus ? -(~n & 0xFF) - 1 : n;
}
function int2vec4(int) {
  return [int & 0xff, int >>> 8 & 0xff, int >>> 16 & 0xff, int >>> 24 & 0xff];
}
function int2vec4norm(int) {
  return [(int & 0xff) / 256, (int >>> 8 & 0xff) / 256, (int >>> 16 & 0xff) / 256, (int >>> 24 & 0xff) / 256];
}
function tuple(v0, v1) {
  return v0 & 0xffff | v1 << 16;
}
function detuple0(v) {
  return v & 0xffff;
}
function detuple1(v) {
  return v >>> 16 & 0xffff;
}
function tuple2(value, v0, v1) {
  value[0] = v0;
  value[1] = v1;
  return value;
}
function tuple3(value, v0, v1, v2) {
  value[0] = v0;
  value[1] = v1;
  value[2] = v2;
  return value;
}
function tuple4(value, v0, v1, v2, v3) {
  value[0] = v0;
  value[1] = v1;
  value[2] = v2;
  value[3] = v3;
  return value;
}
function productValue(start, f) {
  return {
    get: () => start,
    set: v => start = f(start, v)
  };
}
function minValue(start) {
  return productValue(start, (lh, rh) => Math.min(rh, lh));
}

/***/ }),

/***/ "./src/utils/pixelprovider.ts":
/*!************************************!*\
  !*** ./src/utils/pixelprovider.ts ***!
  \************************************/
/*! exports provided: BlendNormal, BlendAlpha, AbstractPixelProvider, ConstPixelProvider, RGBAArrayPixelProvider, RGBPalPixelProvider, RectPixelProvider, ResizePixelProvider, AxisSwapPixelProvider, FlipPixelProvider, OffsetPixelProvider, fromPal, axisSwap, xflip, yflip, xyflip, rect, center, resize, fit, offset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlendNormal", function() { return BlendNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlendAlpha", function() { return BlendAlpha; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractPixelProvider", function() { return AbstractPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstPixelProvider", function() { return ConstPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAArrayPixelProvider", function() { return RGBAArrayPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBPalPixelProvider", function() { return RGBPalPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectPixelProvider", function() { return RectPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResizePixelProvider", function() { return ResizePixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisSwapPixelProvider", function() { return AxisSwapPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlipPixelProvider", function() { return FlipPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffsetPixelProvider", function() { return OffsetPixelProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPal", function() { return fromPal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisSwap", function() { return axisSwap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xflip", function() { return xflip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yflip", function() { return yflip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyflip", function() { return xyflip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rect", function() { return rect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "center", function() { return center; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resize", function() { return resize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fit", function() { return fit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mathutils */ "./src/utils/mathutils.ts");

var BlendNormal = (dst, dstoff, src, srcoff) => {
  // dst.set(src.slice(srcoff, srcoff+4), dstoff);
  dst[dstoff] = src[srcoff];
  dst[dstoff + 1] = src[srcoff + 1];
  dst[dstoff + 2] = src[srcoff + 2];
  dst[dstoff + 3] = src[srcoff + 3];
};
var BlendAlpha = (dst, dstoff, src, srcoff) => {
  var a = src[srcoff + 3] / 255;

  var _a = 1 - a;

  dst[dstoff] = src[srcoff] * a + dst[dstoff] * _a;
  dst[dstoff + 1] = src[srcoff + 1] * a + dst[dstoff + 1] * _a;
  dst[dstoff + 2] = src[srcoff + 2] * a + dst[dstoff + 2] * _a;
  dst[dstoff + 3] = 255;
};
class AbstractPixelProvider {
  constructor(w, h) {
    this.w = w;
    this.h = h;
    if (w < 0 || h < 0) throw new Error('Invalid size');
  }

  putToDst(x, y, dst, dstoff, blend) {}

  getPixel(x, y) {
    var dst = new Uint8Array(4);
    this.putToDst(x, y, dst, 0, BlendNormal);
    return dst;
  }

  getWidth() {
    return this.w;
  }

  getHeight() {
    return this.h;
  }

  render(dst, blend) {
    if (blend === void 0) {
      blend = BlendNormal;
    }

    var off = 0;

    for (var y = 0; y < this.h; y++) {
      for (var x = 0; x < this.w; x++) {
        this.putToDst(x, y, dst, off, blend);
        off += 4;
      }
    }
  }

}
class ConstPixelProvider extends AbstractPixelProvider {
  constructor(color, w, h) {
    super(w, h);
    this.color = color;
  }

  putToDst(x, y, dst, dstoff, blend) {
    blend(dst, dstoff, this.color, 0);
  }

}
class RGBAArrayPixelProvider extends AbstractPixelProvider {
  constructor(arr, w, h) {
    super(w, h);
    this.arr = arr;
    if (arr.length != w * h * 4) throw new Error('Invalid array size. Need ' + w * h * 4 + ' but provided ' + arr.length);
  }

  putToDst(x, y, dst, dstoff, blend) {
    var w = this.getWidth();
    blend(dst, dstoff, this.arr, (x + y * w) * 4);
  }

}
class RGBPalPixelProvider extends AbstractPixelProvider {
  constructor(arr, pal, w, h, alpha, transIdx, shadow, shadowColor) {
    if (alpha === void 0) {
      alpha = 255;
    }

    if (transIdx === void 0) {
      transIdx = -1;
    }

    if (shadow === void 0) {
      shadow = -1;
    }

    if (shadowColor === void 0) {
      shadowColor = new Uint8Array([0, 0, 0, 0]);
    }

    super(w, h);
    this.palTmp = new Uint8Array(4);
    this.arr = arr;
    this.pal = pal;
    this.alpha = alpha;
    this.transIdx = transIdx;
    this.shadow = shadow;
    this.shadowColor = shadowColor;
    if (arr.length != w * h) throw new Error('Invalid array size. Need ' + w * h * 4 + ' but provided ' + arr.length);
  }

  putToDst(x, y, dst, dstoff, blend) {
    var w = this.getWidth();
    var idx = this.arr[x + y * w];

    if (idx == this.shadow) {
      blend(dst, dstoff, this.shadowColor, 0);
      return;
    }

    var paloff = idx * 3; // this.palTmp.set(this.pal.slice(paloff, paloff + 3));

    this.palTmp[0] = this.pal[paloff];
    this.palTmp[1] = this.pal[paloff + 1];
    this.palTmp[2] = this.pal[paloff + 2];
    this.palTmp[3] = idx == this.transIdx ? 0 : this.alpha;
    blend(dst, dstoff, this.palTmp, 0);
  }

}
class RectPixelProvider extends AbstractPixelProvider {
  constructor(provider, sx, sy, ex, ey, paddColor) {
    if (paddColor === void 0) {
      paddColor = new Uint8Array([0, 0, 0, 0]);
    }

    super(ex - sx, ey - sy);
    this.origw = void 0;
    this.origh = void 0;
    this.provider = provider;
    this.sx = sx;
    this.sy = sy;
    this.ex = ex;
    this.ey = ey;
    this.paddColor = paddColor;
    this.origw = provider.getWidth();
    this.origh = provider.getHeight();
    if (sx >= ex || sy >= ey) throw new Error('Invalid subrect');
  }

  putToDst(x, y, dst, dstoff, blend) {
    var nx = this.sx + x;
    var ny = this.sy + y;
    if (nx < 0 || ny < 0 || nx >= this.origw || ny >= this.origh) blend(dst, dstoff, this.paddColor, 0);else this.provider.putToDst(nx, ny, dst, dstoff, blend);
  }

}
class ResizePixelProvider extends AbstractPixelProvider {
  constructor(provider, w, h) {
    super(w, h);
    this.dx = void 0;
    this.dy = void 0;
    this.provider = provider;
    this.dx = provider.getWidth() / w;
    this.dy = provider.getHeight() / h;
  }

  putToDst(x, y, dst, dstoff, blend) {
    this.provider.putToDst(_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"](x * this.dx), _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"](y * this.dy), dst, dstoff, blend);
  }

}
class AxisSwapPixelProvider extends AbstractPixelProvider {
  constructor(provider) {
    super(provider.getHeight(), provider.getWidth());
    this.provider = provider;
  }

  putToDst(x, y, dst, dstoff, blend) {
    this.provider.putToDst(y, x, dst, dstoff, blend);
  }

}
class FlipPixelProvider extends AbstractPixelProvider {
  constructor(provider, xswap, yswap) {
    super(provider.getWidth(), provider.getHeight());
    this.xs = void 0;
    this.ys = void 0;
    this.provider = provider;
    this.xs = xswap ? provider.getWidth() - 1 : 0;
    this.ys = yswap ? provider.getHeight() - 1 : 0;
  }

  putToDst(x, y, dst, dstoff, blend) {
    this.provider.putToDst(Math.abs(x - this.xs), Math.abs(y - this.ys), dst, dstoff, blend);
  }

}
class OffsetPixelProvider extends AbstractPixelProvider {
  constructor(provider, w, h, xo, yo, paddColor) {
    if (paddColor === void 0) {
      paddColor = new Uint8Array([0, 0, 0, 0]);
    }

    super(w, h);
    this.provider = provider;
    this.xo = xo;
    this.yo = yo;
    this.paddColor = paddColor;
  }

  putToDst(x, y, dst, dstoff, blend) {
    var rx = x - this.xo;
    var ry = y - this.yo;
    if (rx < 0 || ry < 0 || rx >= this.provider.getWidth() || ry >= this.provider.getHeight()) blend(dst, dstoff, this.paddColor, 0);else this.provider.putToDst(rx, ry, dst, dstoff, blend);
  }

}
function fromPal(arr, pal, w, h, alpha, transIdx, shadow, shadowColor) {
  if (alpha === void 0) {
    alpha = 255;
  }

  if (transIdx === void 0) {
    transIdx = -1;
  }

  if (shadow === void 0) {
    shadow = -1;
  }

  if (shadowColor === void 0) {
    shadowColor = new Uint8Array([0, 0, 0, 0]);
  }

  return new RGBPalPixelProvider(arr, pal, w, h, alpha, transIdx, shadow, shadowColor);
}
function axisSwap(provider) {
  return new AxisSwapPixelProvider(provider);
}
function xflip(provider) {
  return new FlipPixelProvider(provider, true, false);
}
function yflip(provider) {
  return new FlipPixelProvider(provider, false, true);
}
function xyflip(provider) {
  return new FlipPixelProvider(provider, true, true);
}
function rect(provider, sx, sy, ex, ey, paddColod) {
  if (paddColod === void 0) {
    paddColod = new Uint8Array([0, 0, 0, 0]);
  }

  if (sx == 0 && sy == 0 && provider.getHeight() == ey && provider.getWidth() == ex) return provider;
  return new RectPixelProvider(provider, sx, sy, ex, ey, paddColod);
}
function center(provider, w, h, paddColod) {
  if (paddColod === void 0) {
    paddColod = new Uint8Array([0, 0, 0, 0]);
  }

  var dw = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((provider.getWidth() - w) / 2);
  var dh = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((provider.getHeight() - h) / 2);
  return rect(provider, dw, dh, w + dw, h + dh);
}
function resize(provider, w, h) {
  if (provider.getHeight() == h && provider.getWidth() == w) return provider;
  return new ResizePixelProvider(provider, w, h);
}
function fit(w, h, provider, paddColor) {
  if (paddColor === void 0) {
    paddColor = new Uint8Array([0, 0, 0, 0]);
  }

  if (provider.getHeight() == h && provider.getWidth() == w) return provider;

  if (provider.getWidth() <= w && provider.getHeight() <= h) {
    var sx = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((provider.getWidth() - w) / 2);
    var sy = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((provider.getHeight() - h) / 2);
    return rect(provider, sx, sy, w + sx, h + sy, paddColor);
  } else {
    var aspect = provider.getWidth() / provider.getHeight();
    var nw = provider.getWidth();
    var nh = provider.getHeight();
    var r = false;

    if (nw > w) {
      nw = w;
      nh = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"](nw / aspect);
      r = true;
    }

    if (nh > h) {
      nh = h;
      nw = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"](nh * aspect);
      r = true;
    }

    if (r) {
      var sx = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((nw - w) / 2);
      var sy = _mathutils__WEBPACK_IMPORTED_MODULE_0__["int"]((nh - h) / 2);
      return rect(resize(provider, nw, nh), sx, sy, w + sx, h + sy, paddColor);
    } else {
      return resize(provider, w, h);
    }
  }
}
function offset(provider, w, h, xo, yo, paddColor) {
  if (paddColor === void 0) {
    paddColor = new Uint8Array([0, 0, 0, 0]);
  }

  return new OffsetPixelProvider(provider, w, h, xo, yo, paddColor);
}

/***/ }),

/***/ "./src/utils/profiler.ts":
/*!*******************************!*\
  !*** ./src/utils/profiler.ts ***!
  \*******************************/
/*! exports provided: Section, startProfile, startGlobalProfile, incCount, set, endProfile, start, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Section", function() { return Section; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startProfile", function() { return startProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startGlobalProfile", function() { return startGlobalProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "incCount", function() { return incCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endProfile", function() { return endProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
function now() {
  return window.performance.now();
}

class Section {
  constructor(parent, name, startTime, time, subSections, counts) {
    if (startTime === void 0) {
      startTime = now();
    }

    if (time === void 0) {
      time = 0;
    }

    if (subSections === void 0) {
      subSections = {};
    }

    if (counts === void 0) {
      counts = {};
    }

    this.parent = parent;
    this.name = name;
    this.startTime = startTime;
    this.time = time;
    this.subSections = subSections;
    this.counts = counts;
    if (parent != null) parent.subSections[name] = this;
  }

  start() {
    if (this.startTime == -1) this.startTime = now();
  }

  stop() {
    if (this.startTime != -1) {
      this.time = now() - this.startTime;
      this.startTime = -1;
    }

    return this.time;
  }

  pause() {
    if (this.startTime != -1) {
      this.time += now() - this.startTime;
      this.startTime = -1;
    }

    return this.time;
  }

  currentTime() {
    return this.startTime == -1 ? this.time : now() - this.startTime;
  }

  createSubsection(name) {
    return new Section(this, name);
  }

  inc(name, amount) {
    if (amount === void 0) {
      amount = 1;
    }

    var count = this.counts[name];
    this.counts[name] = (count == undefined ? 0 : count) + amount;
  }

  set(name, value) {
    this.counts[name] = value;
  }

}
var mainSection = new Section(null, 'Main');
var currentSection = mainSection;
function startProfile(name) {
  var subsec = currentSection.subSections[name];

  if (subsec == undefined) {
    subsec = new Section(currentSection, name);
  }

  currentSection = subsec;
  currentSection.start();
}
function startGlobalProfile(name) {
  var subsec = mainSection.subSections[name];

  if (subsec == undefined) {
    subsec = new Section(mainSection, name);
    subsec.parent = currentSection;
  }

  currentSection = subsec;
  currentSection.start();
}
function incCount(name, amount) {
  if (amount === void 0) {
    amount = 1;
  }

  currentSection.inc(name, amount);
}
function set(name, value) {
  currentSection.set(name, value);
}
function endProfile() {
  var time = currentSection.pause();
  if (currentSection != mainSection) currentSection = currentSection.parent;
  return time;
}
function start() {
  mainSection = new Section(null, 'Main');
  currentSection = mainSection;
}
function get(path) {
  if (path === void 0) {
    path = null;
  }

  if (path == null) return mainSection;
  var parts = path.split('.');
  var section = mainSection;

  for (var i = 0; i < parts.length; i++) {
    section = section.subSections[parts[i]];
  }

  return section;
}

/***/ }),

/***/ "./src/utils/stream.ts":
/*!*****************************!*\
  !*** ./src/utils/stream.ts ***!
  \*****************************/
/*! exports provided: Stream, byte, ubyte, short, ushort, int, uint, float, string, bits, array, atomic_array, struct */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stream", function() { return Stream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "byte", function() { return byte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ubyte", function() { return ubyte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "short", function() { return short; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ushort", function() { return ushort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int", function() { return int; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint", function() { return uint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "float", function() { return float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "string", function() { return string; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bits", function() { return bits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "array", function() { return array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atomic_array", function() { return atomic_array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "struct", function() { return struct; });
class Stream {
  constructor(buf, isLE) {
    this.view = void 0;
    this.offset = void 0;
    this.littleEndian = void 0;
    this.aligned = true;
    this.currentBit = 0;
    this.currentByte = 0;
    this.view = new DataView(buf);
    this.offset = 0;
    this.littleEndian = isLE;
  }

  checkBitAlignment() {
    if (!this.aligned) throw new Error("Unaligned offset: " + this.offset + ":" + this.currentBit);
  }

  buffer() {
    return this.view.buffer;
  }

  eoi() {
    return this.offset >= this.view.byteLength;
  }

  skip(n) {
    this.checkBitAlignment();
    this.offset += n;
  }

  setOffset(off) {
    this.checkBitAlignment();
    this.offset = off;
  }

  mark() {
    this.checkBitAlignment();
    return this.offset;
  }

  readByte() {
    this.checkBitAlignment();
    return this.view.getInt8(this.offset++);
  }

  writeByte(byte) {
    this.checkBitAlignment();
    this.view.setInt8(this.offset++, byte);
  }

  readUByte() {
    this.checkBitAlignment();
    return this.view.getUint8(this.offset++);
  }

  writeUByte(byte) {
    this.checkBitAlignment();
    this.view.setUint8(this.offset++, byte);
  }

  readShort() {
    this.checkBitAlignment();
    var ret = this.view.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return ret;
  }

  writeShort(short) {
    this.checkBitAlignment();
    this.view.setInt16(this.offset, short, this.littleEndian);
    this.offset += 2;
  }

  readUShort() {
    this.checkBitAlignment();
    var ret = this.view.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return ret;
  }

  writeUShort(short) {
    this.checkBitAlignment();
    this.view.setUint16(this.offset, short, this.littleEndian);
    this.offset += 2;
  }

  readInt() {
    this.checkBitAlignment();
    var ret = this.view.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return ret;
  }

  writeInt(int) {
    this.checkBitAlignment();
    this.view.setInt32(this.offset, int, this.littleEndian);
    this.offset += 4;
  }

  readUInt() {
    this.checkBitAlignment();
    var ret = this.view.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return ret;
  }

  writeUInt(int) {
    this.checkBitAlignment();
    this.view.setUint32(this.offset, int, this.littleEndian);
    this.offset += 4;
  }

  readFloat() {
    this.checkBitAlignment();
    var ret = this.view.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return ret;
  }

  writeFloat(float) {
    this.checkBitAlignment();
    this.view.setFloat32(this.offset, float, this.littleEndian);
    this.offset += 4;
  }

  readByteString(len) {
    this.checkBitAlignment();
    var str = new Array(len);

    for (var i = 0; i < len; i++) {
      var c = this.readByte();

      if (c == 0) {
        this.skip(len - i - 1);
        break;
      }

      str.push(String.fromCharCode(c));
    }

    return str.join('');
  }

  writeByteString(len, str) {
    this.checkBitAlignment();
    str = str.length > len ? str.substr(0, len) : str;

    for (var c of str) {
      this.writeByte(c.charCodeAt(0));
    }

    for (var i = 0; i < len - str.length; i++) {
      this.writeByte(0);
    }
  }

  subView() {
    this.checkBitAlignment();
    var ret = new Stream(this.view.buffer, this.littleEndian);
    ret.setOffset(this.offset);
    return ret;
  }

  readArrayBuffer(bytes) {
    this.checkBitAlignment();
    var slice = this.view.buffer.slice(this.offset, this.offset + bytes);
    this.offset += bytes;
    return slice;
  }

  writeArrayBuffer(buffer, len) {
    var dst = new Uint8Array(this.view.buffer, this.offset);
    dst.set(new Uint8Array(buffer, 0, len));
    this.offset += len;
  }

  readBit() {
    if (this.aligned) this.currentByte = this.readUByte();
    var bit = this.currentByte >> this.currentBit & 1;
    this.currentBit = (this.currentBit + 1) % 8;
    this.aligned = this.currentBit == 0;
    return bit;
  }

  writeBit(bit) {
    if (this.aligned) this.currentByte = 0;
    if (bit) this.currentByte |= 1 << this.currentBit;else this.currentByte &= ~(1 << this.currentBit) & 0xff;
    this.currentBit = (this.currentBit + 1) % 8;
    this.aligned = this.currentBit == 0;
    if (this.aligned) this.writeUByte(this.currentByte);
  }

  readBits(bits) {
    var value = 0;
    var signed = bits < 0;
    bits = signed ? -bits : bits;

    for (var i = 0; i < bits; i++) {
      var b = this.readBit();
      value = value | b << i;
    }

    return signed ? toSigned(value, bits) : value;
  }

  writeBits(bits, value) {
    var signed = bits < 0;
    bits = signed ? -bits : bits;
    value = signed ? fromSigned(value, bits) : value;

    for (var i = 0; i < bits; i++) {
      this.writeBit((value >> i & 1) == 1);
    }
  }

}

function toSigned(value, bits) {
  return value & 1 << bits - 1 ? -(~value & (1 << bits) - 1) - 1 : value;
}

function fromSigned(value, bits) {
  var mask = (1 << bits) - 1;
  return value > 0 ? value & mask : (~-value & mask) + 1;
}

function accessor(read, write, size) {
  return {
    read,
    write,
    size
  };
}

function atomicReader(read, write, size, atomicArrayConstructor) {
  return {
    read,
    write,
    size,
    atomicArrayConstructor
  };
}

var byte = atomicReader(s => s.readByte(), (s, v) => s.writeByte(v), 1, Int8Array);
var ubyte = atomicReader(s => s.readUByte(), (s, v) => s.writeUByte(v), 1, Uint8Array);
var short = atomicReader(s => s.readShort(), (s, v) => s.writeShort(v), 2, Int16Array);
var ushort = atomicReader(s => s.readUShort(), (s, v) => s.writeUShort(v), 2, Uint16Array);
var int = atomicReader(s => s.readInt(), (s, v) => s.writeInt(v), 4, Int32Array);
var uint = atomicReader(s => s.readUInt(), (s, v) => s.writeUInt(v), 4, Uint32Array);
var float = atomicReader(s => s.readFloat(), (s, v) => s.writeFloat(v), 4, Float32Array);
var string = len => accessor(s => s.readByteString(len), (s, v) => s.writeByteString(len, v), len);
var bits = len => accessor(s => s.readBits(len), (s, v) => s.writeBits(len, v), Math.abs(len) / 8);
var array = (type, len) => accessor(s => readArray(s, type, len), (s, v) => writeArray(s, type, len, v), type.size * len);
var atomic_array = (type, len) => accessor(s => readAtomicArray(s, type, len), (s, v) => writeAtomicArray(s, type, len, v), type.size * len);
var struct = type => new StructBuilder(type);

var readArray = (s, type, len) => {
  var arr = new Array();

  for (var i = 0; i < len; i++) {
    arr[i] = type.read(s);
  }

  return arr;
};

var writeArray = (s, type, len, value) => {
  for (var i = 0; i < len; i++) {
    type.write(s, value[i]);
  }
};

var readAtomicArray = (s, type, len) => {
  var ctr = type.atomicArrayConstructor;
  var buffer = s.readArrayBuffer(len * type.size);
  return new ctr(buffer, 0, len * type.size);
};

var writeAtomicArray = (s, type, len, value) => {
  s.writeArrayBuffer(value.buffer, len);
};

class StructBuilder {
  constructor(ctr) {
    this.fields = [];
    this.size = 0;
    this.ctr = ctr;
  }

  field(f, r) {
    this.fields.push([f, r]);
    this.size += r.size;
    return this;
  }

  read(s) {
    var struct = new this.ctr();

    for (var i = 0; i < this.fields.length; i++) {
      var [name, reader] = this.fields[i];
      struct[name] = reader.read(s);
    }

    return struct;
  }

  write(s, value) {
    for (var i = 0; i < this.fields.length; i++) {
      var [name, _accessor] = this.fields[i];

      _accessor.write(s, value[name]);
    }
  }

}

/***/ }),

/***/ "./src/utils/tiler.ts":
/*!****************************!*\
  !*** ./src/utils/tiler.ts ***!
  \****************************/
/*! exports provided: Tiler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tiler", function() { return Tiler; });
class Tiler {
  constructor() {
    this.tiles = new Map();
  }

  put(x, y, tileId) {
    this.tiles.set(x + "," + y, tileId);
    return this;
  }

  get(x, y) {
    return this.tiles.get(x + "," + y);
  }

  size() {
    return this.tiles.size;
  }

  tile(cb) {
    for (var [key, _tileId] of this.tiles.entries()) {
      var [_x, _y] = key.split(',').map(Number.parseFloat);
      cb(_x, _y, _tileId);
    }
  }

}

/***/ }),

/***/ "./src/utils/timed.ts":
/*!****************************!*\
  !*** ./src/utils/timed.ts ***!
  \****************************/
/*! exports provided: constTimed, timed, delayed, DelayedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constTimed", function() { return constTimed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timed", function() { return timed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delayed", function() { return delayed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelayedValue", function() { return DelayedValue; });
function constTimed(value) {
  return () => value;
}
function timed(startTime, startValue, endTime, endValue, interpolator) {
  var dt = endTime - startTime;
  return time => {
    if (time < startTime) return startValue;
    if (time > endTime) return endValue;
    var t = (time - startTime) / dt;
    return interpolator(startValue, endValue, t);
  };
}
function delayed(dt, last, next, inter) {
  var now = performance.now();
  return timed(now, last, now + dt, next, inter);
}
class DelayedValue {
  constructor(delay, value, inter) {
    this.startValue = void 0;
    this.endValue = void 0;
    this.time = void 0;
    this.delay = delay;
    this.inter = inter;
    this.endValue = value;
    this.startValue = value;
    this.time = 0;
  }

  set(val) {
    if (this.endValue == val) return;
    this.startValue = this.get();
    this.time = performance.now();
    this.endValue = val;
  }

  get() {
    var t = performance.now() - this.time;
    if (t < 0) return this.startValue;
    if (t > this.delay) return this.endValue;
    return this.inter(this.startValue, this.endValue, t / this.delay);
  }

}

/***/ }),

/***/ "./src/utils/ui/canvasgrid.ts":
/*!************************************!*\
  !*** ./src/utils/ui/canvasgrid.ts ***!
  \************************************/
/*! exports provided: drawGrid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawGrid", function() { return drawGrid; });
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collections */ "./src/utils/collections.ts");


function drawGrid(canvas, widgets, cw, ch, bg) {
  if (bg === void 0) {
    bg = 'black';
  }

  var w = canvas.clientWidth;
  var h = canvas.clientHeight;
  var ctx = canvas.getContext('2d');
  var wcells = Object(_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(w / cw);
  var hcells = Object(_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(h / ch);
  var cells = wcells * hcells;
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, w, h);

  for (var [widget, i] of Object(_collections__WEBPACK_IMPORTED_MODULE_1__["enumerate"])(Object(_collections__WEBPACK_IMPORTED_MODULE_1__["take"])(widgets, cells))) {
    var _x = i % wcells * cw;

    var _y = Object(_mathutils__WEBPACK_IMPORTED_MODULE_0__["int"])(i / wcells) * ch;

    ctx.save();
    ctx.beginPath();
    ctx.rect(_x, _y, w, h);
    ctx.clip();
    widget(ctx, _x, _y);
    ctx.restore();
  }
}

/***/ }),

/***/ "./src/utils/ui/drawpanel.ts":
/*!***********************************!*\
  !*** ./src/utils/ui/drawpanel.ts ***!
  \***********************************/
/*! exports provided: PixelDataProvider, ScrollType, DrawPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PixelDataProvider", function() { return PixelDataProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollType", function() { return ScrollType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawPanel", function() { return DrawPanel; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collections */ "./src/utils/collections.ts");
/* harmony import */ var _imgutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../imgutils */ "./src/utils/imgutils.ts");
/* harmony import */ var _iter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../iter */ "./src/utils/iter.ts");
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mathutils */ "./src/utils/mathutils.ts");
/* harmony import */ var _pixelprovider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pixelprovider */ "./src/utils/pixelprovider.ts");
/* harmony import */ var _canvasgrid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canvasgrid */ "./src/utils/ui/canvasgrid.ts");






class PixelDataProvider {
  constructor(s, f) {
    this.s = s;
    this.f = f;
  }

  size() {
    return this.s;
  }

  get(i) {
    return this.f(i);
  }

}
var ScrollType;

(function (ScrollType) {
  ScrollType[ScrollType["ITEM"] = 0] = "ITEM";
  ScrollType[ScrollType["ROW"] = 1] = "ROW";
  ScrollType[ScrollType["PAGE"] = 2] = "PAGE";
})(ScrollType || (ScrollType = {}));

class DrawPanel {
  constructor(canvas, idsProvider, provider, selectCallback, cellW, cellH) {
    if (cellW === void 0) {
      cellW = 64;
    }

    if (cellH === void 0) {
      cellH = 64;
    }

    this.offset = 0;
    this.pageIds = new _collections__WEBPACK_IMPORTED_MODULE_0__["Deck"]();
    this.selected = new Set();
    this.canvas = canvas;
    this.idsProvider = idsProvider;
    this.provider = provider;
    this.selectCallback = selectCallback;
    this.cellW = cellW;
    this.cellH = cellH;

    canvas.onclick = e => {
      var idx = this.calcIdx(e.offsetX, e.offsetY);
      if (idx != -1) this.selectCallback(idx);
    };

    canvas.onwheel = e => {
      if (e.altKey) {
        var d = e.deltaY > 0 ? -4 : 4;
        this.cellH += d;
        this.cellW += d;
        this.draw();
      } else if (e.deltaY > 0) this.scroll(1, e.shiftKey ? ScrollType.PAGE : ScrollType.ROW);else if (e.deltaY < 0) this.scroll(-1, e.shiftKey ? ScrollType.PAGE : ScrollType.ROW);
    };
  }

  prepareIds() {
    this.pageIds.clear().pushAll(Object(_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(this.idsProvider()).skip(this.offset).take(this.cellsOnPage()));

    if (this.offset != 0 && Object(_collections__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(this.pageIds)) {
      this.offset = 0;
      this.prepareIds();
    }
  }

  calcIdx(x, y) {
    var cx = Object(_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(x / this.cellW);
    var cy = Object(_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(y / this.cellH);
    var idx = cy * this.horizontalCells() + cx;
    return idx < this.pageIds.length() ? this.pageIds.get(idx) : -1;
  }

  horizontalCells() {
    return Object(_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(this.canvas.clientWidth / this.cellW);
  }

  verticalCells() {
    return Object(_mathutils__WEBPACK_IMPORTED_MODULE_3__["int"])(this.canvas.clientHeight / this.cellH);
  }

  cellsOnPage() {
    return this.horizontalCells() * this.verticalCells();
  }

  getDelta(type) {
    switch (type) {
      case ScrollType.ITEM:
        return 1;

      case ScrollType.ROW:
        return this.verticalCells() == 1 ? 1 : this.horizontalCells();

      case ScrollType.PAGE:
        return this.cellsOnPage();
    }
  }

  seOffset(offset) {
    this.offset = offset;
  }

  scrollToId(id) {
    this.offset = 0;
    var found = !Object(_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(this.idsProvider()).skipWhile(i => {
      this.offset++;
      return i != id;
    }).isEmpty();
    this.offset = found ? this.offset - 1 : 0;
  }

  setCellSize(w, h) {
    this.cellW = w;
    this.cellH = h;
    this.draw();
  }

  select(id) {
    this.selected.add(id);
  }

  deselect(id) {
    this.selected.delete(id);
  }

  deselectAll() {
    this.selected.clear();
  }

  scroll(off, type) {
    var d = off * this.getDelta(type);
    var newOffset = this.offset;

    if (d > 0) {
      Object(_iter__WEBPACK_IMPORTED_MODULE_2__["iter"])(this.idsProvider()).skip(this.offset + this.cellsOnPage()).take(d).forEach(_ => newOffset++);
    } else {
      newOffset = Math.max(0, newOffset + d);
    }

    if (this.offset != newOffset) {
      this.offset = newOffset;
      this.draw();
    }
  }

  render(id) {
    var cw = this.cellW;
    var ch = this.cellH;
    return (ctx, x, y) => {
      ctx.font = "8px Arial";
      ctx.fillStyle = 'white';
      ctx.strokeStyle = 'white';
      ctx.textAlign = "center";
      var img = this.provider.get(id);

      if (img != null) {
        var pixels = Object(_pixelprovider__WEBPACK_IMPORTED_MODULE_4__["fit"])(cw, ch - 10, img, new Uint8Array([0, 0, 0, 255]));
        Object(_imgutils__WEBPACK_IMPORTED_MODULE_1__["drawToCanvas"])(pixels, ctx, x, y, _pixelprovider__WEBPACK_IMPORTED_MODULE_4__["BlendAlpha"]);
      }

      ctx.fillText(id + "", x + cw / 2, y + ch - 2);
      if (this.selected.has(id)) ctx.strokeRect(x + 0.5, y + 0.5, cw - 1, ch - 1);
    };
  }

  draw() {
    this.prepareIds();
    Object(_canvasgrid__WEBPACK_IMPORTED_MODULE_5__["drawGrid"])(this.canvas, Object(_collections__WEBPACK_IMPORTED_MODULE_0__["map"])(this.pageIds, i => this.render(i)), this.cellW, this.cellH);
  }

}

/***/ }),

/***/ "./src/utils/ui/renderers.ts":
/*!***********************************!*\
  !*** ./src/utils/ui/renderers.ts ***!
  \***********************************/
/*! exports provided: IconTextRenderer, renderGrid, sugggestionsMenu, renderMenu, menuButton, search */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IconTextRenderer", function() { return IconTextRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderGrid", function() { return renderGrid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sugggestionsMenu", function() { return sugggestionsMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderMenu", function() { return renderMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "menuButton", function() { return menuButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "search", function() { return search; });
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tippy.js */ "./node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _iter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../iter */ "./src/utils/iter.ts");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ "./src/utils/ui/ui.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




function IconTextRenderer(value) {
  var text = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["span"])().className('icon-text').text(value.text);
  if (value.style != null) text.className(value.style);
  if (value.icon != null) text.append(Object(_ui__WEBPACK_IMPORTED_MODULE_2__["span"])().className('icon pull-left ' + value.icon));
  return text;
}
function renderGrid(_x) {
  return _renderGrid.apply(this, arguments);
}

function _renderGrid() {
  _renderGrid = _asyncToGenerator(function* (grid) {
    var table = new _ui__WEBPACK_IMPORTED_MODULE_2__["Table"]();
    table.className("table-striped");
    Object(_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(yield grid.rows()).forEach(dataRow => {
      var columns = [...Object(_iter__WEBPACK_IMPORTED_MODULE_1__["iter"])(grid.columns()).enumerate().map((_ref) => {
        var [r, i] = _ref;
        return r(dataRow[i]);
      })];
      var row = table.row(columns);
      row.click(() => grid.onClick(dataRow, row));
    });
    return table;
  });
  return _renderGrid.apply(this, arguments);
}

function sugggestionsMenu(items) {
  var menu = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["div"])('menu menu-default');
  var selected = -1;
  var options = [];

  var _loop = function _loop(label, click) {
    var item = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["div"])('menu-item').text(label).click(() => click());
    options.push([item, click]);
    menu.append(item);
  };

  for (var [label, click] of items) {
    _loop(label, click);
  }

  if (options.length != 0) {
    selected = 0;
    options[selected][0].elem().classList.add('selected');
  }

  return {
    widget: menu.elem(),

    shift(d) {
      if (options.length == 0) return;
      var newSelected = Math.min(Math.max(0, selected + d), options.length - 1);

      if (newSelected != selected) {
        options[selected][0].elem().classList.remove('selected');
        options[newSelected][0].elem().classList.add('selected');
        selected = newSelected;
      }
    },

    select() {
      if (options.length == 0) return;else options[selected][1]();
    }

  };
}
function renderMenu(items) {
  var menu = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["div"])('menu menu-default');

  var _loop2 = function _loop2(label, click) {
    menu.append(Object(_ui__WEBPACK_IMPORTED_MODULE_2__["div"])('menu-item').text(label).click(() => click()));
  };

  for (var [label, click] of items) {
    _loop2(label, click);
  }

  return menu;
}
function menuButton(icon, menu) {
  var btn = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["tag"])('button').className('btn btn-default btn-dropdown').append(Object(_ui__WEBPACK_IMPORTED_MODULE_2__["span"])().className('icon ' + icon));
  menu.build(btn.elem());
  return btn.elem();
}
function search(hint, change) {
  var suggestContainer = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["div"])('suggest');
  var suggestModel = null;
  var textBox = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["tag"])('input').className('toolbar-control').attr('type', 'text').attr('placeholder', hint).change(s => change(s));
  var input = textBox.elem();
  input.addEventListener('keydown', e => {
    if (e.key == 'ArrowDown') suggestModel.shift(1);else if (e.key == 'ArrowUp') suggestModel.shift(-1);else if (e.key == 'Enter') suggestModel.select();
  });
  var searchBar = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["tag"])('button').className('btn btn-default btn-mini pull-right').append(Object(_ui__WEBPACK_IMPORTED_MODULE_2__["span"])().className('icon icon-search')).append(textBox).click(() => {
    textBox.elem().value = '';
    change('');
  });
  var inst = Object(tippy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(textBox.elem(), {
    allowHTML: true,
    placement: 'bottom-start',
    interactive: true,
    content: suggestContainer.elem(),
    trigger: 'focus',
    arrow: false,
    offset: [0, 0],
    appendTo: document.body
  });
  return {
    widget: searchBar.elem(),

    setValue(s) {
      input.value = s;
      inst.hide();
    },

    updateSuggestions(model) {
      suggestModel = model;
      var sugg = suggestContainer.elem();
      Object(_ui__WEBPACK_IMPORTED_MODULE_2__["replaceContent"])(sugg, model.widget);
      inst.show();
    }

  };
}

/***/ }),

/***/ "./src/utils/ui/ui.ts":
/*!****************************!*\
  !*** ./src/utils/ui/ui.ts ***!
  \****************************/
/*! exports provided: Element, Table, Properties, tag, div, span, table, props, label, button, panel, Progress, progress, VerticalPanel, verticalPanel, dragElement, closeModal, stopPropagation, addDragAndDrop, replaceContent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Table", function() { return Table; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Properties", function() { return Properties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tag", function() { return tag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "span", function() { return span; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "table", function() { return table; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "props", function() { return props; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "label", function() { return label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "button", function() { return button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "panel", function() { return panel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Progress", function() { return Progress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "progress", function() { return progress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalPanel", function() { return VerticalPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verticalPanel", function() { return verticalPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dragElement", function() { return dragElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closeModal", function() { return closeModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDragAndDrop", function() { return addDragAndDrop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceContent", function() { return replaceContent; });
class Element {
  constructor(element) {
    this.element = element;
  }

  className(name) {
    this.element.className = name;
    return this;
  }

  id(id) {
    this.element.id = id;
    return this;
  }

  text(text) {
    this.element.textContent = text;
    return this;
  }

  appendHtml(html) {
    this.element.appendChild(html);
    return this;
  }

  append(element) {
    this.element.appendChild(element.element);
    return this;
  }

  pos(x, y) {
    this.element.style.left = x;
    this.element.style.top = y;
    return this;
  }

  size(w, h) {
    this.element.style.width = w;
    this.element.style.height = h;
    return this;
  }

  width(w) {
    this.element.style.width = w;
    return this;
  }

  height(h) {
    this.element.style.height = h;
    return this;
  }

  elem() {
    return this.element;
  }

  attr(name, val) {
    this.element.setAttribute(name, val);
    return this;
  }

  css(name, val) {
    this.element.style[name] = val;
    return this;
  }

  click(e) {
    this.element.onclick = e;
    return this;
  }

  change(cb) {
    this.element.oninput = e => {
      cb(e.target.value);
    };

    return this;
  }

}

function create(tag) {
  return document.createElement(tag);
}

class Table extends Element {
  constructor() {
    super(create('table'));
    this.tbody = void 0;
    this.thead = void 0;
    this.thead = new Element(create('thead'));
    this.tbody = new Element(create('tbody'));
    this.append(this.thead);
    this.append(this.tbody);
  }

  head(cols) {
    var tr = new Element(create('tr'));

    for (var i = 0; i < cols.length; i++) {
      var c = cols[i];
      var td = new Element(create('th')).append(c);
      tr.append(td);
    }

    this.thead.append(tr);
    return this;
  }

  row(cols) {
    var tr = new Element(create('tr'));

    for (var i = 0; i < cols.length; i++) {
      var c = cols[i];
      var td = new Element(create('td')).append(c);
      tr.append(td);
    }

    this.tbody.append(tr);
    return tr;
  }

  removeRow(row) {
    this.tbody.elem().deleteRow(row);
    return this;
  }

}
class Properties extends Table {
  constructor() {
    super();
    this.labels = {};
    this.className('props');
  }

  prop(name, el) {
    this.row([div('property_name').text(name), el]);
    return this;
  }

  refresh(props) {
    var fields = Object.keys(props);

    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      var l = this.labels[field];

      if (l == undefined) {
        l = label('');
        this.labels[field] = l;
        this.prop(field, l);
      }

      l.text(props[field] + '');
    }

    return this;
  }

}
function tag(tag) {
  return new Element(create(tag));
}
function div(className) {
  return new Element(create('div')).className(className);
}
function span() {
  return new Element(create('span'));
}
function table() {
  return new Table();
}
function props() {
  return new Properties();
}
function label(text) {
  return div('label').text(text);
}
function button(caption) {
  return div('contour').append(div('button').text(caption));
}
function panel(title) {
  return div('frame').append(div('header').text(title)).append(div('hline')).append(div('content'));
}
class Progress extends Element {
  constructor(title, max) {
    if (max === void 0) {
      max = 100;
    }

    super(create('div'));
    this.title = void 0;
    this.progress = void 0;
    this.title = div('title').text(title);
    this.progress = new Element(create('progress')).attr('max', max);
    this.append(this.title).append(this.progress);
  }

  max(max) {
    this.progress.attr('max', max);
    return this;
  }

  setValue(val) {
    this.progress.attr('value', val);
    return this;
  }

}
function progress(title, max) {
  if (max === void 0) {
    max = 100;
  }

  return new Progress(title, max);
}
class VerticalPanel extends Element {
  constructor(className) {
    super(create('div'));
    this.rows = 0;
    this.className(className);
  }

  add(elem) {
    this.append(elem);
    return this.rows++;
  }

}
function verticalPanel(className) {
  return new VerticalPanel(className);
}
function dragElement(header, elment) {
  var startx = 0;
  var starty = 0;
  var onmouseup = null;
  var onmousemove = null;
  header.onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    e.preventDefault();
    startx = e.clientX;
    starty = e.clientY;
    onmouseup = document.onmouseup;
    onmousemove = document.onmousemove;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e.preventDefault();
    var x = startx - e.clientX;
    var y = starty - e.clientY;
    startx = e.clientX;
    starty = e.clientY;
    elment.style.top = elment.offsetTop - y + "px";
    elment.style.left = elment.offsetLeft - x + "px";
  }

  function closeDragElement() {
    document.onmouseup = onmouseup;
    document.onmousemove = onmousemove;
  }
}
function closeModal(window, cb, value) {
  window.classList.add('hidden');
  cb(value);
}
function stopPropagation(e) {
  e.stopPropagation();
  e.preventDefault();
}
function addDragAndDrop(elem, dropHandler) {
  elem.addEventListener("dragenter", stopPropagation, false);
  elem.addEventListener("dragover", stopPropagation, false);
  elem.addEventListener("drop", e => {
    stopPropagation(e);
    dropHandler(e);
  }, false);
}
function replaceContent(root, newchild) {
  var child = root.firstChild;
  if (child) root.replaceChild(newchild, child);else root.appendChild(newchild);
}

/***/ }),

/***/ "./src/utils/vecmath.ts":
/*!******************************!*\
  !*** ./src/utils/vecmath.ts ***!
  \******************************/
/*! exports provided: intersect2d, intersect2dT, direction3d, direction2d, projectXY, projectXZ, projectYZ, intersect3d, reflectVec3d, reflectPoint3d, normal2d, mirrorBasis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect2d", function() { return intersect2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect2dT", function() { return intersect2dT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "direction3d", function() { return direction3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "direction2d", function() { return direction2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectXY", function() { return projectXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectXZ", function() { return projectXZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectYZ", function() { return projectYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect3d", function() { return intersect3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reflectVec3d", function() { return reflectVec3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reflectPoint3d", function() { return reflectPoint3d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normal2d", function() { return normal2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mirrorBasis", function() { return mirrorBasis; });
/* harmony import */ var _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs_js/glmatrix */ "./src/libs_js/glmatrix.js");
/* harmony import */ var _mathutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mathutils */ "./src/utils/mathutils.ts");


function intersect2d(p1s, p1e, p2s, p2e) {
  var t = intersect2dT(p1s, p1e, p2s, p2e);
  if (t == null) return null;
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].lerp(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].create(), p1s, p1e, t);
}
function intersect2dT(p1s, p1e, p2s, p2e) {
  var d = (p1s[0] - p1e[0]) * (p2s[1] - p2e[1]) - (p1s[1] - p1e[1]) * (p2s[0] - p2e[0]);
  if (Math.abs(d) < _mathutils__WEBPACK_IMPORTED_MODULE_1__["EPS"]) return null;
  var res0 = ((p1s[0] * p1e[1] - p1s[1] * p1e[0]) * (p2s[0] - p2e[0]) - (p1s[0] - p1e[0]) * (p2s[0] * p2e[1] - p2s[1] * p2e[0])) / d;
  var res1 = ((p1s[0] * p1e[1] - p1s[1] * p1e[0]) * (p2s[1] - p2e[1]) - (p1s[1] - p1e[1]) * (p2s[0] * p2e[1] - p2s[1] * p2e[0])) / d;
  var dx1 = p1e[0] - p1s[0];
  var dy1 = p1e[1] - p1s[1];
  var dot1 = ((res0 - p1s[0]) * dx1 + (res1 - p1s[1]) * dy1) / _mathutils__WEBPACK_IMPORTED_MODULE_1__["sqrLen2d"](dx1, dy1);
  if (dot1 < 0.0 || dot1 > 1.0) return null;
  var dx2 = p2e[0] - p2s[0];
  var dy2 = p2e[1] - p2s[1];
  var dot2 = ((res0 - p2s[0]) * dx2 + (res1 - p2s[1]) * dy2) / _mathutils__WEBPACK_IMPORTED_MODULE_1__["sqrLen2d"](dx2, dy2);
  if (dot2 < 0.0 || dot2 > 1.0) return null;
  return dot1;
}
function direction3d(ps, pe) {
  var dir = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), pe, ps);
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(dir, dir);
}
function direction2d(ps, pe) {
  var dir = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].sub(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].create(), pe, ps);
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].normalize(dir, dir);
}
function projectXY(p) {
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(p[0], p[1]);
}
function projectXZ(p) {
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(p[0], p[2]);
}
function projectYZ(p) {
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(p[1], p[2]);
}
function intersect3d(p1s, p1e, p2s, p2e) {
  var dir1 = direction3d(p1s, p1e);
  var dir2 = direction3d(p2s, p2e);
  var p = dir1[1] * dir2[0] - dir2[1] * dir1[0] != 0 ? projectXY : dir1[0] * dir2[1] - dir2[0] * dir1[1] != 0 ? projectXZ : dir1[1] * dir2[2] - dir2[1] * dir1[2] != 0 ? projectYZ : null;
  if (p == null) return null;
  var p1s_ = p(p1s);
  var p2s_ = p(p2s);
  var p1e_ = p(p1e);
  var p2e_ = p(p2e);
  var t = intersect2dT(p1s_, p1e_, p2s_, p2e_);
  if (t == null) return null;
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].lerp(_libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), p1s, p1e, t);
}
function reflectVec3d(out, id, n) {
  var dot = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(n, id);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(out, n, dot * 2);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(out, id, out);
  return out;
}
var tmp = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
function reflectPoint3d(out, mirrorNormal, mirrorD, point) {
  var t = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(point, mirrorNormal) + mirrorD;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].scale(tmp, mirrorNormal, t * 2);
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].sub(out, point, tmp);
}
function normal2d(out, vec) {
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].set(out, vec[1], -vec[0]);
  return _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec2"].normalize(out, out);
}
var side = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var up = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var forward = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var oside = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var oup = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var oforward = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
var mirroredPos = _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
function mirrorBasis(out, mat, point, mirrorNormal, mirrorD) {
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(oside, mat[0], mat[4], mat[8]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(oup, mat[1], mat[5], mat[9]);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(oforward, mat[2], mat[6], mat[10]);
  reflectVec3d(side, oside, mirrorNormal);
  reflectVec3d(up, oup, mirrorNormal);
  reflectVec3d(forward, oforward, mirrorNormal);
  reflectPoint3d(mirroredPos, mirrorNormal, mirrorD, point);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(out);
  out[0] = side[0];
  out[1] = up[0];
  out[2] = forward[0];
  out[3] = 0;
  out[4] = side[1];
  out[5] = up[1];
  out[6] = forward[1];
  out[7] = 0;
  out[8] = side[2];
  out[9] = up[2];
  out[10] = forward[2];
  out[11] = 0;
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].negate(mirroredPos, mirroredPos);
  _libs_js_glmatrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(out, out, mirroredPos);
  return out;
}
/*
export function normal2d(v1:GLM.Vec2Array, v2:GLM.Vec2Array):GLM.Vec2Array {
  let tmp = normalize2d(subCopy2d(v2, v1));
  let norm = fromValues2d(-tmp[1], tmp[0]);
  release2d(tmp);
  return norm;
}

//
//   p1     p3
//    \ ang /
//     \ ^ /
//      \ /
//      p2
export function ang2d(p1:GLM.Vec2Array, p2:GLM.Vec2Array, p3:GLM.Vec2Array):number {
  let toNext = subCopy2d(p3, p2); normalize2d(toNext);
  let toPrev = subCopy2d(p1, p2); normalize2d(toPrev);
  let angToNext = Math.acos(toNext[0]);
  angToNext = toNext[1] < 0 ? MU.PI2 - angToNext : angToNext;
  let angToPrev = Math.acos(toPrev[0]);
  angToPrev = toPrev[1] < 0 ? MU.PI2 - angToPrev : angToPrev;
  release2d(toNext); release2d(toPrev);
  let ang = angToNext - angToPrev;
  ang = (ang < 0 ? MU.PI2 + ang : ang);
  return ang;
}

export function isCW(polygon:GLM.VecArray[]):boolean {
  let angsum = 0;
  let N = polygon.length;
  for (let i = 0; i < N; i++) {
    let curr = polygon[i];
    let prev = polygon[i == 0 ? N - 1 : i - 1];
    let next = polygon[i == N - 1 ? 0 : i + 1];
    angsum += ang2d(prev, curr, next);
  }
  return MU.rad2deg(angsum) == 180*(N-2);
}


export function projectionSpace(vtxs:GLM.Vec3Array[], n:GLM.Vec3Array) {
  let a = normalize3d(subCopy3d(vtxs[0], vtxs[1]));
  let c = normalize3d(crossCopy3d(n, a));
  let ret = [
    a[0], c[0], n[0],
    a[1], c[1], n[1],
    a[2], c[2], n[2]
  ];
  release3d(a); release3d(c); 
  return ret;
}

export function project3d(vtxs:GLM.Vec3Array[], normal:GLM.Vec3Array):GLM.Vec2Array[] {
  let mat = projectionSpace(vtxs, normal);
  let ret = [];
  for (let i = 0; i < vtxs.length; i++) {
    let vtx = GLM.vec3.transformMat3(GLM.vec3.create(), vtxs[i], mat);
    ret.push([vtx[0], vtx[1]]);
  }
  return ret;
}
*/

/***/ })

/******/ });
//# sourceMappingURL=app.bundle.js.map